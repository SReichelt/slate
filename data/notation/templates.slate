%notation%

/**
 * Applies a special style class to a rendered expression.  
 * The effect of this style class is defined in a CSS file.
 *
 * @param body The expression to decorate.
 * @param styleClass The name of the style class as it appears in CSS.
 */
$Style(body: %Expr, styleClass: %String): %Template {}

/**
 * Adds parentheses around an expression.
 *
 * @param body The inner expression.
 * @param style One of '()', '||', '[]', '{}', '{', or '<>'.
 *
 * @example `$Parens(body = a, style = '()')`
 * @example `$Parens(body = a, style = '||')`
 * @example `$Parens(body = a, style = '[]')`
 * @example `$Parens(body = a, style = '{}')`
 * @example `$Parens(body = a, style = '<>')`
 */
$Parens(body: %Expr, style: %String): %Template {}

/**
 * Ensures that parentheses are added around the given expression if necessary.  
 * Should be used to decorate arguments of the current symbol or template, i.e. its "inner expressions". 
 * Parentheses are added if the inner expression is itself decorated using `$OuterParens`. 
 * The parentheses style is determined by the type of the inner expression.
 *
 * @param body The inner expression.
 *
 * @param maxLevel Determines when parentheses are required:
 *                 * If `maxLevel` is set in `$InnerParens` and `minLevel` is set in the corresponding `$OuterParens` instance, parentheses are added if `minLevel` <= `maxLevel`.  
 *                   In terms of operator precedence, parentheses are omitted if the inner expression binds more strongly than `maxLevel`.
 *                 * Otherwise, parentheses are always added.
 *
 *                 Parentheses levels currently in use are:
 *                 * -3: Implication and equivalence.
 *                 * -2: Boolean operators and quantification.
 *                 * -1: Relations, both built-in and user-defined.
 *                 * 0: Separation of function domain and codomain (→).
 *                 * 1: Addition and subtraction.
 *                 * 2: Multiplication and function composition. Also used for the Cartesian product, so that no parentheses are added around A × B in A × B → C.
 *                 * 3: Exponentiation, or more precisely all expressions with superscripts or subscripts. In most cases, `maxLevel` should be less than this number, i.e. inner expressions with superscripts or subscripts do not require parentheses.
 *
 * @param left Parentheses will only be added if `left` is set in both `$InnerParens` and `$OuterParens`, or if `right` is set in both `$InnerParens` and `$OuterParens`. `left` can be set to false if the content surrounding the `$InnerParens` instance is sufficiently bounded on the left.
 * @param right Parentheses will only be added if `left` is set in both `$InnerParens` and `$OuterParens`, or if `right` is set in both `$InnerParens` and `$OuterParens`. `right` can be set to false if the content surrounding the `$InnerParens` instance is sufficiently bounded on the right.
 */
$InnerParens(body: %Expr, maxLevel?: %Int, left: %Bool = %true, right: %Bool = %true): %Template {}

/**
 * Ensures that parentheses are added around the given expression if necessary.  
 * Should be used to decorate the entire current symbol or template.  
 * Parentheses are added if the expression is instantiated at a location decorated with `$InnerParens`.  
 * The parentheses style is determined by the type of the expression.
 *
 * @param body The inner expression, i.e. the symbol or template being defined.
 *
 * @param minLevel Determines when parentheses are required:
 *                 * If `minLevel` is set in `$OuterParens` and `maxLevel` is set in the corresponding `$InnerParens` instance, parentheses are added if `minLevel` <= `maxLevel`.  
 *                   In terms of operator precedence, parentheses are omitted if the outer expression binds less strongly than `minLevel`.
 *                 * Otherwise, parentheses are always added.
 *
 *                 Parentheses levels currently in use are:
 *                 * -3: Implication and equivalence.
 *                 * -2: Boolean operators and quantification.
 *                 * -1: Relations, both built-in and user-defined.
 *                 * 0: Separation of function domain and codomain (→).
 *                 * 1: Addition and subtraction.
 *                 * 2: Multiplication and function composition. Also used for the Cartesian product, so that no parentheses are added around A × B in A × B → C.
 *                 * 3: Exponentiation, or more precisely all expressions with superscripts or subscripts. In most cases, `maxLevel` should be less than this number, i.e. inner expressions with superscripts or subscripts do not require parentheses.
 *
 * @param left Parentheses will only be added if `left` is set in both `$InnerParens` and `$OuterParens`, or if `right` is set in both `$InnerParens` and `$OuterParens`. `left` can be set to false if inner expression is sufficiently bounded on the left.
 * @param right Parentheses will only be added if `left` is set in both `$InnerParens` and `$OuterParens`, or if `right` is set in both `$InnerParens` and `$OuterParens`. `right` can be set to false if the inner expression is sufficiently bounded on the right.
 */
$OuterParens(body: %Expr, minLevel?: %Int, left: %Bool = %true, right: %Bool = %true): %Template {}

/**
 * Arranges a two-dimensional array of expressions as a table.
 *
 * @param items A two-dimensional array of expressions, where each inner array represents a row. Rows do not necessarily need to have the same length.
 * @param style Determines how the items are arranged. Currently supported values are:
 *              * 'matrix': Standard table with horizontally centered cells that are spaced apart. Also used for vectors.
 *              * 'aligned': The first column is right-aligned, the other columns are left-aligned. No horizontal space is added between columns.
 *              * 'cases': Several left-aligned columns with large horizontal spacing. Used to render cases with conditions.
 *              * 'single-case': Very similar to 'cases', but omits extra padding around the entire table because a single case is displayed in an "inline" fashion.
 *              * 'vertical-tuple': Used to display large tuples in a vertical format (see `$VerticalTuple`), in particular the objects and morphisms of individual categories. In contrast to 'matrix', cells are left-aligned.
 *              * 'binom': Binomial coefficient, similar to a matrix but with less spacing.
 *              * 'construction': Used to define the contents of a construction. Includes a vertical line between the first two columns.
 *
 * @example `$Table(items = [[a, b], [c, d]], style = 'matrix')`
 */
$Table(items: %Expr[,], style: %String): %Template {}

/**
 * Adds a subscript and/or superscript to an expression. More generally, subscripts and superscripts can be added at all four corners.
 *
 * @param body The main expression. `$SubSup` implicitly decorates `body` with `$InnerParens`, i.e. parentheses are added whenever the contents of `body` are decorated with `$OuterParens`, regardless of the level.
 * @param sub A subscript to be added after `body`.
 * @param sup A superscript to be added after `body`.
 * @param preSub A subscript to be added before `body`.
 * @param preSup A superscript to be added before `body`.
 *
 * @example `$SubSup(body = a, sub = b)`
 * @example `$SubSup(body = a, sup = c)`
 * @example `$SubSup(body = a, sub = b, sup = c)`
 * @example `$SubSup(body = a, sub = b, sup = c, preSub = d, preSup = e)`
 */
$SubSup(body: %Expr, sub?: %Expr, sup?: %Expr, preSub?: %Expr, preSup?: %Expr): %Template {}

/**
 * Adds expressions above and/or below a main expression.
 *
 * @param body The main expression.
 * @param over An expression to be added above `body`.
 * @param under An expression to be added below `body`.
 * @param style Set to 'shallow' to reduce vertical space. The contents of `body` typically dictate whether this is appropriate.
 *
 * @example `$OverUnder(body = a, over = b, style = 'shallow')`
 * @example `$OverUnder(body = a, under = c, style = 'shallow')`
 * @example `$OverUnder(body = a, over = b, under = c, style = 'shallow')`
 * @example `$OverUnder(body = A, over = b, under = c)`
 */
$OverUnder(body: %Expr, over?: %Expr, under?: %Expr, style?: %String): %Template {}

/**
 * A fraction that is layed out vertically.
 *
 * @param numerator The expression at the top.
 * @param denominator The expression at the bottom.
 *
 * @example `$Fraction(numerator = a, denominator = b)`
 */
$Fraction(numerator: %Expr, denominator: %Expr): %Template {}

/**
 * A radical symbol with optional degree.
 *
 * @param radicand The expression under the radical symbol.
 * @param degree An optional expression to be placed on the left of the radical symbol.
 *
 * @example `$Radical(radicand = a)`
 * @example `$Radical(radicand = a, degree = b)`
 */
$Radical(radicand: %Expr, degree?: %Expr): %Template {}

/**
 * The colon to use for ":=" and ":⇔". Used internally by other templates.
 */
$DefinitionColon: %Template {
  notation = $Style(
    body = ':',
    styleClass = 'def-colon'
  )
}

/**
 * An horizontal ellipsis that is aligned to the bottom of the expression.
 */
$BottomEllipsis: %Template {
  /* Not using unicode character '…' because it has too much space in TeX font. */
  notation = '...'
}

/**
 * An horizontal ellipsis that is aligned to the middle of the expression.
 */
$MiddleEllipsis: %Template {
  /* Not using unicode character '⋯' because it has too much space in TeX font. */
  notation = '⋅⋅⋅'
}

/**
 * A group of expressions separated by a character. Used e.g. for `$Tuple` and `$Enumeration`.
 *
 * @param items The list of expressions.
 * @param separator The separator character, optionally including a following space.
 *
 * @example `$Group(items = [a, b, c])`
 */
$Group(items: %Expr[], separator: %String = ', '): %Template {
  notation = %for(
    param = items,
    dimension = 0,
    item = items,
    separator = separator
  )
}

/**
 * A group of expressions separated by a character and surrounded by parentheses.
 *
 * @param items The list of expressions.
 * @param separator The separator character, optionally including a following space.
 * @param style The parentheses style to use (see `$Parens`).
 *
 * @example `$Tuple(items = [a, b, c])`
 * @example `$Tuple(items = [a, b, c], style = '[]')`
 */
$Tuple(items: %Expr[], separator: %String = ', ', style: %String = '()'): %Template {
  notation = $Parens(
    body = $Group(
      items = items,
      separator = separator
    ),
    style = style
  )
}

/**
 * A group of expressions arranged vertically and surrounded by parentheses. Used to display the objects and morphisms of individual categories in a readable fashion.
 *
 * For vectors, use `$Vector` instead.
 *
 * @param items The list of expressions.
 * @param style The parentheses style to use (see `$Parens`).
 *
 * @example `$VerticalTuple(items = [a, b, c])`
 * @example `$VerticalTuple(items = [a, b, c], style = '[]')`
 */
$VerticalTuple(items: %Expr[], style: %String = '()'): %Template {
  notation = $Style(
    body = $Parens(
      body = $Table(
        items = %for(items, 0, [[items]]),
        style = 'vertical-tuple'
      ),
      style = style
    ),
    styleClass = 'vertical-tuple'
  )
}

/**
 * A two-dimensional array of expressions, arranged as a matrix, surrounded by brackets.
 *
 * @param items A two-dimensional array of expressions, where each inner array represents a row.
 *
 * @example `$Matrix(items = [[a, b], [c, d]])`
 */
$Matrix(items: %Expr[,]): %Template {
  notation = $Parens(
    body = $Table(
      items = items,
      style = 'matrix'
    ),
    style = '[]'
  )
}

/**
 * A vector, i.e. a single-column matrix.
 *
 * @param items The vector elements.
 *
 * @example `$Vector(items = [a, b])`
 */
$Vector(items: %Expr[]): %Template {
  notation = $Matrix(
    items = %for(items, 0, [[items]])
  )
}

/**
 * The standard notation for function application. Often used to define functions as well.
 *
 * @param function The function.
 * @param arguments The list of function arguments.
 * @param style The parentheses style to use (see `$Parens`).
 * @param maxParenLevel Parentheses are displayed around `function` if its outer parentheses level is at most `maxParenLevel` (see `$OuterParens`). By default, parentheses are displayed if `function` contains an operator but not if it contains a subscript or superscript.
 *
 * @example `$Function(function = f, arguments = [x])`
 * @example `$Function(function = f, arguments = [a, b, c])`
 * @example `$Function(function = f, arguments = [x], style = '[]')`
 */
$Function(function: %Expr, arguments: %Expr[], style: %String = '()', maxParenLevel: %Int = 2): %Template {
  notation = $OuterParens(
    body = [
      $InnerParens(
        body = function,
        maxLevel = maxParenLevel
      ),
      $Parens(
        body = $Group(
          items = arguments
        ),
        style = style
      )
    ],
    minLevel = 3
  )
}

/**
 * The standard notation for a constructor name.
 *
 * @param name The constructor name.
 *
 * @example `$ConstructorName(name = 'construct')`
 */
$ConstructorName(name: %String): %Template {
  notation = $Style(
    body = name,
    styleClass = 'ctor'
  )
}

/**
 * The standard notation for a constructor with arguments.
 *
 * @param name The constructor name.
 * @param arguments The list of constructor arguments.
 *
 * @example `$Constructor(name = 'construct', arguments = [a, b, c])`
 */
$Constructor(name: %String, arguments: %Expr[]): %Template {
  notation = $Function(
    function = $ConstructorName(
      name = name
    ),
    arguments = arguments
  )
}

/**
 * A binary operator (although it can be used with more than two operands if the operator is associative).
 *
 * @param symbol The operator symbol.
 * @param operands The list of operands. If more than two operands are given, the operator symbol is displayed between each pair of operands.
 * @param space The space to use between the operator symbol and its operands. The default is U+2009. For multiplication, use U+200A.
 * @param minParenLevel If this operator is used at a location with inner parentheses of level `minParenLevel` or greater (see `$InnerParens`), parentheses are added around the `$Operator` expression. By default, parentheses are added whenever this operator appears inside another operator, but not if it appears inside a relation.
 * @param maxParenLevel If an operand has outer parentheses of level `maxParenLevel` or less (see `$OuterParens`), parentheses are added around this operand. By default, parentheses are added around all operands that also contain operators, but not around operands with subscripts or superscripts.
 *
 * @example `$Operator(symbol = ∗, operands = [a, b])`
 */
$Operator(symbol: %Expr, operands: %Expr[], space: %String = ' ', minParenLevel: %Int = 0, maxParenLevel: %Int = 2): %Template {
  notation = $OuterParens(
    body = %for(
      param = operands,
      dimension = 0,
      item = $InnerParens(
        body = operands,
        maxLevel = maxParenLevel,
        left = %not(%first),
        right = %not(%last)
      ),
      separator = [
        space,
        $InnerParens(
          body = symbol,
          maxLevel = 2
        ),
        space
      ]
    ),
    minLevel = minParenLevel
  )
}

/**
 * A unary operator in prefix notation, i.e. the operator symbol is written in front of the operand.
 *
 * @param symbol The operator symbol.
 * @param operand The operand.
 * @param space An optional space to use between the operator symbol and its operand.
 * @param minParenLevel If this operator is used at a location with inner parentheses of level `minParenLevel` or greater (see `$InnerParens`), parentheses are added around the `$PrefixUnaryOperator` expression. By default, parentheses are added whenever this operator appears inside another operator, but not if it appears inside a relation. Set to 3 for operators that bind strongly.
 * @param maxParenLevel If the operand has outer parentheses of level `maxParenLevel` or less (see `$OuterParens`), parentheses are added around it. By default, parentheses are added around all composite operands.
 *
 * @example `$PrefixUnaryOperator(symbol = ≀, operand = a)`
 */
$PrefixUnaryOperator(symbol: %Expr, operand: %Expr, space: %String = '', minParenLevel: %Int = 0, maxParenLevel?: %Int): %Template {
  notation = $OuterParens(
    body = [
      $InnerParens(
        body = symbol,
        maxLevel = 2
      ),
      space,
      $InnerParens(
        body = operand,
        maxLevel = maxParenLevel
      )
    ],
    minLevel = minParenLevel
  )
}

/**
 * A unary operator in postfix notation, i.e. the operator symbol is written after the operand.
 *
 * @param symbol The operator symbol.
 * @param operand The operand.
 * @param space An optional space to use between operand and the operator symbol.
 * @param minParenLevel If this operator is used at a location with inner parentheses of level `minParenLevel` or greater (see `$InnerParens`), parentheses are added around the `$PostfixUnaryOperator` expression. By default, parentheses are added whenever this operator appears inside another operator, but not if it appears inside a relation. Set to 3 for operators that bind strongly.
 * @param maxParenLevel If the operand has outer parentheses of level `maxParenLevel` or less (see `$OuterParens`), parentheses are added around it. By default, parentheses are added around all composite operands.
 *
 * @example `$PostfixUnaryOperator(symbol = ≀, operand = a)`
 */
$PostfixUnaryOperator(symbol: %Expr, operand: %Expr, space: %String = '', minParenLevel: %Int = 0, maxParenLevel?: %Int): %Template {
  notation = $OuterParens(
    body = [
      $InnerParens(
        body = operand,
        maxLevel = maxParenLevel
      ),
      space,
      $InnerParens(
        body = symbol,
        maxLevel = 2
      )
    ],
    minLevel = minParenLevel
  )
}

/**
 * A unary operator in prefix notation where the symbol can be regarded as a function. 
 * Often, the symbol is a word. 
 * This is equivalent to `$PrefixUnaryOperator` except for the default space and parentheses.
 *
 * @param symbol The operator symbol.
 * @param operand The operand.
 * @param space The space to use between the operator symbol and its operand.
 * @param minParenLevel If this operator is used at a location with inner parentheses of level `minParenLevel` or greater (see `$InnerParens`), parentheses are added around the `$FunctionLikeOperator` expression. By default, parentheses are added whenever this operator appears inside another operator, but not if it appears inside a relation.
 * @param maxParenLevel If the operand has outer parentheses of level `maxParenLevel` or less (see `$OuterParens`), parentheses are added around it. By default, parentheses are added around all operands containing operators, but not around operands with subscripts or superscripts.
 *
 * @example `$FunctionLikeOperator(symbol = 'calc', operand = a)`
 */
$FunctionLikeOperator(symbol: %Expr, operand: %Expr, space: %String = ' ', minParenLevel: %Int = 0, maxParenLevel: %Int = 2): %Template {
  notation = $PrefixUnaryOperator(
    symbol = symbol,
    operand = operand,
    space = space,
    minParenLevel = minParenLevel,
    maxParenLevel = maxParenLevel
  )
}

/**
 * A unary operator in prefix notation where the symbol is decorated with additional expressions above and/or below. 
 * Often, the symbol is a word.
 *
 * @param symbol The operator symbol.
 * @param operand The operand.
 * @param over An expression to be added above the symbol.
 * @param under An expression to be added below the symbol.
 * @param style For most symbols, this can be set to 'shallow' to reduce vertical space between the symbol and the expressions above and below (see `$OverUnder`).
 * @param space The space to use between the operator symbol and its operand.
 * @param minParenLevel If this operator is used at a location with inner parentheses of level `minParenLevel` or greater (see `$InnerParens`), parentheses are added around the `$OverUnderOperator` expression. By default, parentheses are added whenever this operator appears inside another operator, but not if it appears inside a relation.
 * @param maxParenLevel If the operand has outer parentheses of level `maxParenLevel` or less (see `$OuterParens`), parentheses are added around it. By default, parentheses are added around all operands containing operators, but not around operands with subscripts or superscripts.
 *
 * @example `$OverUnderOperator(symbol = 'calc', operand = a, under = b, style = 'shallow')`
 * @example `$OverUnderOperator(symbol = 'calc', operand = a, over = c, under = b, style = 'shallow')`
 */
$OverUnderOperator(symbol: %Expr, operand: %Expr, over?: %Expr, under?: %Expr, style?: %String, space: %String = ' ', minParenLevel: %Int = 0, maxParenLevel: %Int = 2): %Template {
  notation = $FunctionLikeOperator(
    symbol = $OverUnder(
      body = symbol,
      over = over,
      under = under,
      style = style
    ),
    operand = operand,
    space = space,
    minParenLevel = minParenLevel,
    maxParenLevel = maxParenLevel
  )
}

/**
 * A unary operator in prefix notation where the symbol is magnified and decorated with additional expressions above and/or below.
 *
 * @param symbol The operator symbol.
 * @param operand The operand.
 * @param over An expression to be added above the symbol.
 * @param under An expression to be added below the symbol.
 * @param space The space to use between the operator symbol and its operand.
 * @param minParenLevel If this operator is used at a location with inner parentheses of level `minParenLevel` or greater (see `$InnerParens`), parentheses are added around the `$LargeOperator` expression. By default, parentheses are added whenever this operator appears inside another operator, but not if it appears inside a relation.
 * @param maxParenLevel If the operand has outer parentheses of level `maxParenLevel` or less (see `$OuterParens`), parentheses are added around it. By default, parentheses are added around all operands containing operators, but not around operands with subscripts or superscripts.
 *
 * @example `$LargeOperator(symbol = '⨂', operand = a, over = c, under = b)`
 */
$LargeOperator(symbol: %Expr, operand: %Expr, over?: %Expr, under?: %Expr, space: %String = ' ', minParenLevel: %Int = 0, maxParenLevel: %Int = 2): %Template {
  notation = $OverUnderOperator(
    symbol = $Style(
      body = symbol,
      styleClass = 'largesym'
    ),
    operand = operand,
    over = over,
    under = under,
    space = space,
    minParenLevel = minParenLevel,
    maxParenLevel = maxParenLevel
  )
}

/**
 * A binary relation (although it can be used with more than two operands if the relation is transitive).
 *
 * @param symbol The relation symbol.
 * @param operands The list of operands. If more than two operands are given, the relation symbol is displayed between each pair of operands.
 * @param space The space to use between the relation symbol and its operands.
 * @param parenLevel The parentheses level of the relation (see `$InnerParens`). Usually should be left at the default.
 *
 * @example `$Relation(symbol = ≺, operands = [a, b])`
 */
$Relation(symbol: %Expr, operands: %Expr[], space: %String = ' ', parenLevel: %Int = -1): %Template {
  notation = $Operator(
    symbol = symbol,
    operands = operands,
    space = space,
    minParenLevel = parenLevel,
    maxParenLevel = parenLevel
  )
}

/**
 * A unary relation written in text form.
 *
 * @param symbol The name of the relation, usually a verb.
 * @param operand The operand.
 * @param parenLevel The parentheses level of the relation (see `$InnerParens`). Usually should be left at the default.
 *
 * @example `$Verb(symbol = %neg('wobbles', 'does not wobble'), operand = a)`
 */
$Verb(symbol: %Expr, operand: %Expr, parenLevel: %Int = -1): %Template {
  notation = $PostfixUnaryOperator(
    symbol = symbol,
    operand = operand,
    space = ' ',
    minParenLevel = parenLevel,
    maxParenLevel = parenLevel
  )
}

/**
 * A binary relation written in text form.
 *
 * @param symbol The name of the relation, usually a verb.
 * @param operands The list of operands, usually a subject and an object.
 * @param parenLevel The parentheses level of the relation (see `$InnerParens`). Usually should be left at the default.
 *
 * @example `$TextualRelation(symbol = %neg('wobbles', 'does not wobble'), operands = [a, b])`
 */
$TextualRelation(symbol: %Expr, operands: %Expr[], parenLevel: %Int = -1): %Template {
  notation = $Relation(
    symbol = symbol,
    operands = operands,
    space = ' ',
    parenLevel = parenLevel
  )
}

/**
 * A property of the form "`a` is `b`", where `b` is usually an adjective.
 *
 * Use `$NounProperty` for the case where `b` is a noun.
 *
 * @param operand The operand of the property (`a` above).
 * @param property The property (`b` above).
 * @param article An article to be prepended to `b`. Used by `$NounProperty` which is defined as a special case of `$Property`.
 *
 * @example `$Property(operand = a, property = 'nice')`
 */
$Property(operand: %Expr, property: %Expr, article?: %String): %Template {
  notation = $Verb(
    symbol = [%neg('is', 'is not'), %opt(article, [' ', article]), ' ', property],
    operand = operand
  )
}

/**
 * A property of the form "`a` is `b` regarding `c`", where `b` is usually an adjective.
 *
 * Use `$NounRelation` for the case where `b` is a noun.
 *
 * @param operands The operands of the property (`a` and `c` above).
 * @param property The property (`b` above).
 * @param article An article to be prepended to `b`. Used by `$NounRelation` which is defined as a special case of `$RelationalProperty`.
 * @param preposition The preposition between the adjective and the right operand.
 *
 * @example `$RelationalProperty(operands = [a, c], property = 'nicer', preposition = 'than')`
 */
$RelationalProperty(operands: %Expr[], property: %Expr, article?: %String, preposition: %String): %Template {
  notation = $TextualRelation(
    symbol = [%neg('is', 'is not'), %opt(article, [' ', article]), ' ', property, ' ', preposition],
    operands = operands
  )
}

/**
 * A property of the form "`a` is a `b`", where `b` is a noun.
 *
 * @param operand The operand of the property (`a` above).
 * @param singular The singular form of the noun (`b` above).
 * @param plural The plural form of the noun.
 * @param article Either "a" or "an", depending on whether the noun starts with a vowel.
 *
 * @example `$NounProperty(operand = a, singular = 'foo', plural = 'foos')`
 */
$NounProperty(operand: %Expr, singular: %Expr, plural: %Expr, article: %String = 'a'): %Template {
  notation = $Property(
    operand = operand,
    property = singular,
    article = article
  )
}

/**
 * A property of the form "`a` is a `b` regarding `c`", where `b` is a noun.
 *
 * @param operands The operands of the property (`a` and `c` above).
 * @param singular The singular form of the noun (`b` above).
 * @param plural The plural form of the noun.
 * @param article Either "a" or "an", depending on whether the noun starts with a vowel.
 * @param preposition The preposition between the noun and the right operand.
 *
 * @example `$NounRelation(operands = [a, c], singular = 'foo', plural = 'foos')`
 */
$NounRelation(operands: %Expr[], singular: %Expr, plural: %Expr, article: %String = 'a', preposition: %String = 'of'): %Template {
  notation = $RelationalProperty(
    operands = operands,
    property = singular,
    article = article,
    preposition = preposition
  )
}

/**
 * A property of the form "`a` has a `b`", where `b` is a noun.
 *
 * @param operand The operand of the property (`a` above).
 * @param singular The singular form of the noun (`b` above).
 * @param plural The plural form of the noun.
 * @param article Either "a" or "an", depending on whether the noun starts with a vowel.
 *
 * @example `$Feature(operand = a, singular = 'foo', plural = 'foos')`
 */
$Feature(operand: %Expr, singular: %Expr, plural: %Expr, article: %String = 'a'): %Template {
  notation = $Verb(
    symbol = [%neg('has', 'does not have'), ' ', article, ' ', singular],
    operand = operand
  )
}

/**
 * A property asserting that a tuple forms a specific structure.
 *
 * @param operands The fields of the tuple.
 * @param singular The singular form of the structure name.
 * @param plural The plural form of the structure name.
 * @param article Either "a" or "an", depending on whether the name starts with a vowel.
 *
 * @example `$Structure(operands = [a, b, c], singular = 'foo', plural = 'foos')`
 */
$Structure(operands: %Expr[], singular: %Expr, plural: %Expr, article: %String = 'a'): %Template {
  notation = $Verb(
    symbol = [%neg('forms', 'does not form'), ' ', article, ' ', singular],
    operand = $Tuple(
      items = operands
    )
  )
}

/**
 * A symmetrical relation between two or more operands, expressed as a property of the form "`a` and `b` are `c`".
 *
 * @param operands The operands of the property (`a` and `b` above).
 * @param property The property (`c` above).
 *
 * @example `$MultiProperty(operands = [a, b], property = 'similar')`
 */
$MultiProperty(operands: %Expr[], property: %Expr): %Template {
  notation = $Verb(
    symbol = [%neg('are', 'are not'), ' ', property],
    operand = [
      %for(
        param = operands,
        dimension = 0,
        item = operands,
        separator = ' and '
      )
    ]
  )
}

/**
 * A word that is parameterized by an argument. Can be used at locations where usually a single word would be expected.
 *
 * @param word The parameterized word.
 * @param argument The argument which is prepended to the word.
 *
 * @example `$DependentWord(word = 'like', argument = a)`
 */
$DependentWord(word: %Expr, argument: %Expr): %Template {
  notation = [
    $InnerParens(
      body = argument,
      maxLevel = 2
    ),
    '-',
    word
  ]
}

/**
 * A boolean operator, usually written in text form.
 *
 * @param symbol The name of the operator.
 * @param operands The list of operands, usually two or more formulas.
 * @param parenLevel The parentheses level of the operator (see `$InnerParens`). Usually should be left at the default.
 *
 * @example `$BooleanOperator(symbol = 'and/or', operands = [a, b])`
 */
$BooleanOperator(symbol: %Expr, operands: %Expr[], space: %String = ' ', parenLevel: %Int = -2): %Template {
  notation = $Operator(
    symbol = symbol,
    operands = operands,
    space = space,
    minParenLevel = parenLevel,
    maxParenLevel = parenLevel
  )
}

/**
 * A unary boolean operator in prefix notation, usually written in text form.
 *
 * @param symbol The name of the operator.
 * @param operand The operand, usually a formula.
 * @param parenLevel The parentheses level of the operator (see `$InnerParens`). Usually should be left at the default.
 *
 * @example `$UnaryBooleanOperator(symbol = 'just', operand = a)`
 */
$UnaryBooleanOperator(symbol: %Expr, operand: %Expr, space: %String = ' ', parenLevel: %Int = -2): %Template {
  notation = $PrefixUnaryOperator(
    symbol = symbol,
    operand = operand,
    space = space,
    minParenLevel = parenLevel,
    maxParenLevel = parenLevel
  )
}

$Negation(operand: %Expr): %Template {
  notation = $UnaryBooleanOperator(
    symbol = 'not',
    operand = operand
  )
}

$True: %Template {
  notation = 'true'
}

$False: %Template {
  notation = 'false'
}

$Conjunction(operands: %Expr[]): %Template {
  notation = $BooleanOperator(
    symbol = 'and',
    operands = operands
  )
}

$Disjunction(operands: %Expr[]): %Template {
  notation = $BooleanOperator(
    symbol = 'or',
    operands = operands
  )
}

$Quantification(symbol: %String, parameters: %Expr, formula: %Expr, parenLevel: %Int = -2): %Template {
  notation = $OuterParens(
    body = [symbol, ' ', parameters, ' : ', $InnerParens(
      body = formula,
      maxLevel = parenLevel,
      right = %false
    )],
    minLevel = parenLevel,
    left = %false
  )
}

$PlainQuantification(symbol: %String, parameters: %Expr, parenLevel: %Int = -2): %Template {
  notation = $OuterParens(
    body = [symbol, ' ', parameters],
    minLevel = parenLevel,
    left = %false
  )
}

$UniversalQuantification(parameters: %Expr, formula: %Expr): %Template {
  notation = $Quantification(
    symbol = '∀',
    parameters = parameters,
    formula = formula
  )
}

$ExistentialQuantification(parameters: %Expr, formula: %Expr): %Template {
  notation = $Quantification(
    symbol = %neg('∃', '∄'),
    parameters = parameters,
    formula = formula
  )
}

$PlainExistentialQuantification(parameters: %Expr): %Template {
  notation = $PlainQuantification(
    symbol = %neg('∃', '∄'),
    parameters = parameters
  )
}

$UniqueExistentialQuantification(parameters: %Expr, formula: %Expr): %Template {
  notation = $Quantification(
    symbol = '∃!',
    parameters = parameters,
    formula = formula
  )
}

$PlainUniqueExistentialQuantification(parameters: %Expr): %Template {
  notation = $PlainQuantification(
    symbol = '∃!',
    parameters = parameters
  )
}

$SubsetParameter(subset: %Expr, superset: %Expr): %Template {
  notation = $Relation(
    symbol = '⊆',
    operands = [subset, superset],
    space = ' '
  )
}

$ElementParameter(element: %Expr, set: %Expr): %Template {
  notation = $Relation(
    symbol = '∈',
    operands = [element, set],
    space = ' '
  )
}

$VariableDefinition(left: %Expr, right: %Expr): %Template {
  notation = $Relation(
    symbol = [$DefinitionColon, '='],
    operands = [left, right],
    space = ' '
  )
}

$MultiEqualityRelation(operands: %Expr[]): %Template {
  notation = $Relation(
    symbol = %neg('=', '≠'),
    operands = operands
  )
}

$EqualityRelation(left: %Expr, right: %Expr): %Template {
  notation = $MultiEqualityRelation(
    operands = [left, right]
  )
}

$EqualityDefinition(left: %Expr, right: %Expr): %Template {
  notation = $Relation(
    symbol = [$DefinitionColon, '='],
    operands = [left, right]
  )
}

$ConstructionDefinition(left: %Expr, right: %Expr): %Template {
  notation = $Relation(
    symbol = [$DefinitionColon, '=', $DefinitionColon],
    operands = [left, right]
  )
}

$MultiEquivalenceRelation(operands: %Expr[]): %Template {
  notation = $Relation(
    symbol = %neg('⇔', '⇎'),
    operands = operands,
    space = '  ',
    parenLevel = -3
  )
}

$EquivalenceRelation(left: %Expr, right: %Expr): %Template {
  notation = $MultiEquivalenceRelation(
    operands = [left, right]
  )
}

$EquivalenceDefinition(left: %Expr, right: %Expr): %Template {
  notation = $Relation(
    symbol = [$DefinitionColon, '⇔'],
    operands = [left, right],
    space = '  ',
    parenLevel = -3
  )
}

$ImplicationRelation(left: %Expr, right: %Expr): %Template {
  notation = $Relation(
    symbol = %neg('⇒', '⇏'),
    operands = [left, right],
    space = '  ',
    parenLevel = -3
  )
}

$ElementRelation(element: %Expr, set: %Expr): %Template {
  notation = $Relation(
    symbol = %neg('∈', '∉'),
    operands = [element, set]
  )
}

$SubsetRelation(subset: %Expr, superset: %Expr): %Template {
  notation = $Relation(
    symbol = %neg('⊆', '⊈'),
    operands = [subset, superset]
  )
}

$EmbeddingDefinition(subset: %Expr, superset: %Expr): %Template {
  notation = $Relation(
    symbol = ['⊆', $DefinitionColon],
    operands = [subset, superset]
  )
}

$FunctionOperator(symbol: %Expr = '→', operands: %Expr[], space: %String = ' ', minParenLevel: %Int = 0, maxParenLevel: %Int = 0): %Template {
  notation = $Operator(
    symbol = symbol,
    operands = operands,
    space = space,
    minParenLevel = minParenLevel,
    maxParenLevel = maxParenLevel
  )
}

$FunctionPrefix(function: %Expr, body: %Expr, space: %String = ' ', minParenLevel: %Int = 0): %Template {
  notation = $Operator(
    symbol = $DefinitionColon,
    operands = [function, body],
    space = space,
    minParenLevel = minParenLevel,
    maxParenLevel = -1
  )
}

$FunctionDefinition(function: %Expr, symbol: %Expr = '→', operands: %Expr[], space: %String = ' ', minParenLevel: %Int = 0, maxParenLevel: %Int = 0): %Template {
  notation = $FunctionPrefix(
    function = function,
    body = $FunctionOperator(
      symbol = symbol,
      operands = operands,
      space = space,
      maxParenLevel = maxParenLevel
    ),
    space = space,
    minParenLevel = minParenLevel
  )
}

$Binding(variable: %Expr, value: %Expr): %Template {
  notation = [variable, '↦', value]
}

$Set(body: %Expr): %Template {
  notation = $Parens(
    body = body,
    style = '{}'
  )
}

$Enumeration(items: %Expr[]): %Template {
  notation = $Set(
    body = $Group(
      items = items
    )
  )
}

$SetBuilder(element: %Expr, constraint: %Expr): %Template {
  notation = $Set(
    body = [element, ' : ', constraint]
  )
}

$Construction(constructors: %Expr[,]): %Template {
  notation = $Set(
    body = $Table(
      items = constructors,
      style = 'construction'
    )
  )
}

$SingleCase(case: %Expr[]): %Template {
  notation = $OuterParens(
    body = $Table(
      items = [case],
      style = 'single-case'
    ),
    left = %false,
    right = %true
  )
}

$Cases(cases: %Expr[,]): %Template {
  notation = $OuterParens(
    body = $Parens(
      body = $Table(
        items = cases,
        style = 'cases'
      ),
      style = '{'
    ),
    left = %false,
    right = %true
  )
}

$DependentProofStep(result: %Expr, source?: %Expr): %Template {
  notation = [
    %opt(
      source,
      $OverUnder(
        body = '⇒',
        over = source,
        style = 'shallow'
      ),
      '⇒'
    ),
    ' ',
    result
  ]
}

$SourceProofStep(result: %Expr, source: %Expr): %Template {
  notation = [
    source,
    ' ⇒ ',
    result
  ]
}

/**
 * Notation used for a subset that can be described using a relation symbol with an argument.
 *
 * @param set The superset.
 * @param symbol The relation symbol to use in the subscript.
 * @param limit The argument on the right side of the relation symbol.
 *
 * @example `$Segment(set = A, symbol = ≺, limit = b)`
 */
$Segment(set: %Expr, symbol: %Expr, limit: %Expr): %Template {
  notation = $SubSup(
    body = set,
    sub = $PrefixUnaryOperator(
      symbol = symbol,
      operand = limit
    )
  )
}

/**
 * A binomial coefficient.
 *
 * @param top The number of elements to choose from.
 * @param bottom The number of elements to choose.
 *
 * @example `$BinomialCoefficient(top = a, bottom = b)`
 */
$BinomialCoefficient(top: %Expr, bottom: %Expr): %Template {
  notation = $Parens(
    body = $Table(
      items = [[top], [bottom]],
      style = 'binom'
    ),
    style = '()'
  )
}

/**
 * The standard notation for lambda abstraction.
 *
 * @param variable The bound variable, possibly including a type.
 * @param term The term on the right side of the dot.
 *
 * @example `$LambdaAbstraction(variable = a, term = b)`
 */
$LambdaAbstraction(variable: %Expr, term: %Expr): %Template {
  notation = $OuterParens(
    body = [
      'λ',
      $InnerParens(
        body = variable,
        maxLevel = 3
      ),
      '. ',
      $InnerParens(
        body = term,
        maxLevel = 1
      )
    ],
    minLevel = 2
  )
}

/**
 * The standard notation for lambda application, which can be regarded as function application but is usually written without parentheses.
 *
 * @param function The left term of the lambda application.
 * @param argument The right term of the lambda application.
 *
 * @example `$LambdaApplication(function = a, argument = b)`
 */
$LambdaApplication(function: %Expr, argument: %Expr): %Template {
  notation = $OuterParens(
    body = [
      $InnerParens(
        body = function,
        maxLevel = 2
      ),
      ' ',
      $InnerParens(
        body = argument,
        maxLevel = 2
      )
    ],
    minLevel = 2
  )
}

/**
 * The standard notation for substitution in lambda terms.
 *
 * @param term The term that the substitution is applied to.
 * @param variable The variable being substituted.
 * @param replacement The term that is substituted for the variable.
 *
 * @example `$LambdaSubstitution(term = a, variable = b, replacement = c)`
 */
$LambdaSubstitution(term: %Expr, variable: %Expr, replacement: %Expr): %Template {
  notation = $Function(
    function = term,
    arguments = [$EqualityDefinition(
      left = variable,
      right = replacement
    )],
    style = '[]'
  )
}
