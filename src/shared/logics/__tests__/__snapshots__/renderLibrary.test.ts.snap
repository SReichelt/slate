// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`render hlm library: 1.1.1 Essentials/Sets/Empty%20set 1`] = `
"Definition 1.1.1.  We define:

  ∅ := {}

Remarks.

This defines the empty set as an enumeration with no elements. Note that sets are a built-in concept in the HLM logic.

References.

* https://en.wikipedia.org/wiki/Empty_set
* https://mathworld.wolfram.com/EmptySet.html
* https://proofwiki.org/wiki/Definition:Empty_Set
* https://ncatlab.org/nlab/show/empty+set
* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.empty_def"
`;

exports[`render hlm library: 1.1.2 Essentials/Sets/Empty%20set%20is%20subset%20of%20any%20set 1`] = `
"Proposition 1.1.2.  Let S be a set. Then:

  ∅ ⊆ S

Proof.  Let x ∈ ∅. Then x ∈ S:

x ∈ ∅ ⇒^def ⭍

References.

* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.empty_subset"
`;

exports[`render hlm library: 1.1.3 Essentials/Sets/empty 1`] = `
"Definition 1.1.3.  Let S be a set. We define:

  S is empty  :⇔  S = ∅
    ⇔  S ⊆ ∅
    ⇔  ∄ x ∈ S
    ⇔  |S| = 0

  S is nonempty  :⇔  S is not empty

Equivalence.

1⇒2. Assume S = ∅. Then S ⊆ ∅:
     S = ∅ ⇒^def S ⊆ ∅
2⇒3. Assume S ⊆ ∅. Then ∄ x ∈ S:
     Let x ∈ S.
     S ⊆ ∅ ⇒^def ∀ s ∈ S : s ∈ ∅
      ⇒ x ∈ ∅
      ⇒^def ⭍
3⇒1. Assume ∄ x ∈ S. Then S = ∅:
     ⊆. Let a ∈ S. Then a ∈ ∅:
        We have ∃ x ∈ S:
          Choose x := a.
     ⊇. 1.1.2 ⇒ ∅ ⊆ S

Remarks.

In HLM, multiple alternative definitions can be given for an operator or predicate, if they can be shown to be equal/equivalent. In proofs, the most convenient alternative can be selected at will, which reduces the number of necessary steps. Sometimes, it also makes sense to prove a property according to one alternative and then use it according to another.

References.

* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.nonempty"
`;

exports[`render hlm library: 1.1.4 Essentials/Sets/finite 1`] = `
"Definition 1.1.4.  Let S be a set. We define:

  S is finite  :⇔  |S| is finite
    ⇔  ∃ k ∈ ℕ, f : S ↔ ℕ_(<k)
    ⇔  ∃ l ∈ ℕ, g : ℕ_(<l) ↔ S
    ⇔  ∃ m ∈ ℕ, h : S → ℕ_(<m) : h is injective
    ⇔  ∃ n ∈ ℕ, i : S → ℕ_(≤n) : i is injective

  S is infinite  :⇔  S is not finite

Equivalence.

1⇒2. Assume |S| is finite. Then ∃ k ∈ ℕ, f : S ↔ ℕ_(<k):
     We have |S| = |ℕ_(<|S|)| by definition.
      ⇒^def ∃ r : S ↔ ℕ_(<|S|)
     Choose k := |S|, f := r.
2⇒3. Let k ∈ ℕ, f : S ↔ ℕ_(<k) be a bijection. Then ∃ l ∈ ℕ, g : ℕ_(<l) ↔ S:
     Choose l := k, g := f^-1.
3⇒1. Let l ∈ ℕ, g : ℕ_(<l) ↔ S be a bijection. Then |S| is finite:
     We show that |S| ∈ ℕ:
     We have |ℕ_(<l)| = |S|:
       We show that ∃ s : S ↔ ℕ_(<l):
       Choose s := g.
      ⇒^[l = |ℕ_(<l)|] l = |S|
     l ∈ ℕ ⇒^[l = |S|] |S| ∈ ℕ
2⇒4. Let k ∈ ℕ, f : S ↔ ℕ_(<k) be a bijection. Then ∃ m ∈ ℕ, h : S → ℕ_(<m) : h is injective:
     def ⇒ f is injective
     Choose m := k, h := f.
4⇒5. Let m ∈ ℕ, h : S → ℕ_(<m) be an injective function. Then ∃ n ∈ ℕ, i : S → ℕ_(≤n) : i is injective:
     1.7.1.17.6 ⇒ ℕ_(<m) ⊆ ℕ_(≤m)
     Choose n := m, i := h∣_S^(ℕ_(≤m)).

Remarks.

This definition uses functions as well as the natural and cardinal numbers, all of which are defined in later sections (see \`$../Functions/Functions\`, \`$../Numbers/Natural/\\"Natural numbers\\"\`, \`$../Numbers/Cardinal/\\"Cardinal numbers\\"\`). That is not a problem as long as no circularities exist. In other words, definitions and theorems are ordered by topic instead of by dependency.

These are just some example proofs, which will be completed later.

References.

* https://en.wikipedia.org/wiki/Finite_set
* https://mathworld.wolfram.com/FiniteSet.html
* https://proofwiki.org/wiki/Definition:Finite_Set
* https://ncatlab.org/nlab/show/finite+set
* https://leanprover-community.github.io/mathlib_docs/data/set/finite.html#set.finite"
`;

exports[`render hlm library: 1.1.5 Essentials/Sets/Subsets%20of%20finite%20sets%20are%20finite 1`] = `
"Proposition 1.1.5.  Let S be a finite set, T ⊆ S. Then:

  T is finite

Proof.  We show that ∃ m ∈ ℕ, f : T → ℕ_(<m) : f is injective:

S is finite ⇒^def ∃ n ∈ ℕ, g : S → ℕ_(<n) : g is injective

Choose m := n, f := g∣_T. We show that g∣_T is injective:

  1.4.17 ⇒ g∣_T is injective

Remarks.

This is just an example proof. It could be rewritten in a very concise way as a proof about cardinals.

References.

* https://leanprover-community.github.io/mathlib_docs/data/set/finite.html#set.finite_subset"
`;

exports[`render hlm library: 1.1.6 Essentials/Sets/countable 1`] = `
"Definition 1.1.6.  Let S be a set. We define:

  S is countable  :⇔  |S| is countable
    ⇔  ∃ f : S → ℕ : f is injective

  S is uncountable  :⇔  S is not countable

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Countable_set
* https://mathworld.wolfram.com/CountableSet.html
* https://proofwiki.org/wiki/Definition:Countable_Set
* https://ncatlab.org/nlab/show/countable+set
* https://leanprover-community.github.io/mathlib_docs/data/set/countable.html#set.countable"
`;

exports[`render hlm library: 1.1.7 Essentials/Sets/countably%20infinite 1`] = `
"Definition 1.1.7.  Let S be a set. We define:

  S is countably infinite  :⇔  |S| is countably infinite
    ⇔  S is countable and S is infinite
    ⇔  ∃ f : S ↔ ℕ

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Countable_set
* https://mathworld.wolfram.com/CountablyInfinite.html
* https://proofwiki.org/wiki/Definition:Countably_Infinite_Set
* https://ncatlab.org/nlab/show/countable+set (called \\"denumerable\\" here)"
`;

exports[`render hlm library: 1.1.8 Essentials/Sets/Intersection 1`] = `
"Definition 1.1.8.  Let U be a set, S, T ⊆ U. We define:

  S ∩ T := {x ∈ U : x ∈ S and x ∈ T}

Remarks.

Due to the type system of HLM, it is impossible to define the intersection of two arbitrary sets. Instead, both sets must be declared as subsets of a common superset \`U\`, although the intersection is, of course, independent of \`U\`. Since a suitable value for \`U\` can always be inferred automatically, \`U\` can be omitted from the notation.

References.

* https://en.wikipedia.org/wiki/Intersection_(set_theory)
* https://mathworld.wolfram.com/Intersection.html
* https://proofwiki.org/wiki/Definition:Set_Intersection
* https://ncatlab.org/nlab/show/intersection
* https://leanprover-community.github.io/mathlib_docs/core/init/data/set.html#set.inter"
`;

exports[`render hlm library: 1.1.9 Essentials/Sets/Intersection%20is%20associative 1`] = `
"Proposition 1.1.9.  Let U be a set, R, S, T ⊆ U. Then:

  (R ∩ S) ∩ T = R ∩ (S ∩ T)

No proof.

References.

* https://proofwiki.org/wiki/Intersection_is_Associative
* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.inter_assoc"
`;

exports[`render hlm library: 1.1.10 Essentials/Sets/Intersection%20is%20commutative 1`] = `
"Proposition 1.1.10.  Let U be a set, S, T ⊆ U. Then:

  S ∩ T = T ∩ S

No proof.

References.

* https://proofwiki.org/wiki/Intersection_is_Commutative
* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.inter_comm"
`;

exports[`render hlm library: 1.1.11 Essentials/Sets/Intersection%20is%20subset%20of%20argument 1`] = `
"Proposition 1.1.11.  Let U be a set, S, T ⊆ U. Then:

  S ∩ T ⊆ S

No proof.

References.

* https://proofwiki.org/wiki/Intersection_is_Subset
* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.inter_subset_left"
`;

exports[`render hlm library: 1.1.12 Essentials/Sets/Union 1`] = `
"Definition 1.1.12.  Let U be a set, S, T ⊆ U. We define:

  S ∪ T := {x ∈ U : x ∈ S or x ∈ T}

Remarks.

Due to the type system of HLM, it is impossible to define the union of two arbitrary sets. Instead, both sets must be declared as subsets of a common superset \`U\`, although the intersection is, of course, independent of \`U\`. Since a suitable value for \`U\` can always be inferred automatically, \`U\` can be omitted from the notation.

References.

* https://en.wikipedia.org/wiki/Union_(set_theory)
* https://mathworld.wolfram.com/Union.html
* https://proofwiki.org/wiki/Definition:Set_Union
* https://ncatlab.org/nlab/show/union
* https://leanprover-community.github.io/mathlib_docs/core/init/data/set.html#set.union"
`;

exports[`render hlm library: 1.1.13 Essentials/Sets/Union%20is%20associative 1`] = `
"Proposition 1.1.13.  Let U be a set, R, S, T ⊆ U. Then:

  (R ∪ S) ∪ T = R ∪ (S ∪ T)

No proof.

References.

* https://proofwiki.org/wiki/Union_is_Associative
* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.union_assoc"
`;

exports[`render hlm library: 1.1.14 Essentials/Sets/Union%20is%20commutative 1`] = `
"Proposition 1.1.14.  Let U be a set, S, T ⊆ U. Then:

  S ∪ T = T ∪ S

No proof.

References.

* https://proofwiki.org/wiki/Union_is_Commutative
* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.union_comm"
`;

exports[`render hlm library: 1.1.15 Essentials/Sets/Union%20is%20superset%20of%20argument 1`] = `
"Proposition 1.1.15.  Let U be a set, S, T ⊆ U. Then:

  S ⊆ S ∪ T

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.subset_union_left"
`;

exports[`render hlm library: 1.1.16 Essentials/Sets/Relative%20complement 1`] = `
"Definition 1.1.16.  Let U be a set, S, T ⊆ U. We define:

  S ∖ T := {x ∈ U : x ∈ S and x ∉ T}
   = {x ∈ S : x ∉ T}

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement
* https://mathworld.wolfram.com/SetDifference.html
* https://proofwiki.org/wiki/Definition:Set_Difference
* https://leanprover-community.github.io/mathlib_docs/core/init/data/set.html#set.diff"
`;

exports[`render hlm library: 1.1.17 Essentials/Sets/Disjoint%20union 1`] = `
"Definition 1.1.17.  Let S, T be sets. We define:

  S ⊎ T :=: {l(s) | s ∈ S, r(t) | t ∈ T}

  l(s) = l(s')  :⇔  s = s'  (s ∈ S, s' ∈ S)

  r(t) = r(t')  :⇔  t = t'  (t ∈ T, t' ∈ T)

For S' ⊆ S and T' ⊆ T, we canonically treat elements of S' ⊎ T' as elements of S ⊎ T.

Remarks.

In contrast to the definition of set union, the disjoint union of sets is a \\"construction,\\" which is an HLM-specific concept very similar to an inductive definition in type theory. The disjoint union has two \\"constructors.\\"

Note that the set and its constructors are introduced at the same time, hence the non-standard notation \\":=:\\". The notation on both sides can be specified freely.

A construction always includes definitions of equality for each constructor. In this case, those definitions are what one might expect. (Different constructors are never considered equal.)

References.

* https://en.wikipedia.org/wiki/Disjoint_union
* https://mathworld.wolfram.com/DisjointUnion.html
* https://proofwiki.org/wiki/Definition:Disjoint_Union_(Set_Theory)
* https://ncatlab.org/nlab/show/disjoint+union#special_cases
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#sum"
`;

exports[`render hlm library: 1.1.18 Essentials/Sets/Cartesian%20product 1`] = `
"Definition 1.1.18.  Let S, T be sets. We define:

  S × T :=: {(s, t) | s ∈ S, t ∈ T}

  (s, t) = (s', t')  :⇔  s = s' and t = t'  (s ∈ S, t ∈ T, s' ∈ S, t' ∈ T)

For S' ⊆ S and T' ⊆ T, we canonically treat elements of S' × T' as elements of S × T.

Remarks.

The Cartesian product is, again, a \\"construction.\\" Note that HLM does not have any built-in notion of \\"tuple\\" – it is actually defined here as a constructor, with the usual notation.

References.

* https://en.wikipedia.org/wiki/Cartesian_product
* https://mathworld.wolfram.com/CartesianProduct.html
* https://proofwiki.org/wiki/Definition:Cartesian_Product
* https://ncatlab.org/nlab/show/cartesian+product
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#prod"
`;

exports[`render hlm library: 1.1.19 Essentials/Sets/Power%20set 1`] = `
"Definition 1.1.19.  Let S be a set. We define:

  𝒫(S) :=: {(T) | T ⊆ S}

  (T) = (T')  :⇔  T = T'  (T ⊆ S, T' ⊆ S)

For S' ⊆ S, we canonically treat elements of 𝒫(S') as elements of 𝒫(S).

Remarks.

The power set is another example of a construction. It is slightly nonstandard in that its elements are not actual subsets but terms that are built using the constructor of this construction. To highlight this difference, parentheses are used. There is no significant practical difference, however.

References.

* https://en.wikipedia.org/wiki/Power_set
* https://mathworld.wolfram.com/PowerSet.html
* https://proofwiki.org/wiki/Definition:Power_Set
* https://ncatlab.org/nlab/show/power+set
* https://coq.inria.fr/library/Coq.Sets.Powerset.html
* https://leanprover-community.github.io/mathlib_docs/core/init/data/set.html#set.powerset"
`;

exports[`render hlm library: 1.1.20 Essentials/Sets/Truth%20values 1`] = `
"Definition 1.1.20.  We define:

  𝓣𝓻𝓾𝓽𝓱 :=: {[p] | p is a proposition}

  [p] = [q]  :⇔  [p  ⇔  q]  (p is a proposition, q is a proposition)

We write “let p be a truth value” for “let p ∈ 𝓣𝓻𝓾𝓽𝓱.”

Remarks.

This definition captures propositions up to equivalence. Since HLM uses classical logic, it can be proved to contain only two values, true and false. It can therefore be used interchangeably with the set \`$../Numbers/Natural/Subsets/\\"Binary digits\\"\` of binary digits.

References.

* https://en.wikipedia.org/wiki/Truth_value
* https://proofwiki.org/wiki/Definition:Truth_Value
* https://ncatlab.org/nlab/show/truth+value"
`;

exports[`render hlm library: 1.1.21 Essentials/Sets/maximal%20subset 1`] = `
"Definition 1.1.21.  Let S be a set, T ⊆ S, let p_I be a proposition for each I ⊆ S. We define:

  T is a maximal subset I of S such that p_I  :⇔  p_T and ∀ I ⊆ S s.t. p_I and T ⊆ I : T = I"
`;

exports[`render hlm library: 1.1.22.1 Essentials/Sets/Generalized%20operators/Generalized%20intersection 1`] = `
"Definition 1.1.22.1.  Let U be a set, I be a set, let S_i ⊆ U for each i ∈ I. We define:

  ⋂_(i ∈ I) S_i := {x ∈ U : ∀ j ∈ I : x ∈ S_j}

Remarks.

Similarly to the definition of the intersection of two sets, we have to specify a common superset \`U\` for all sets. As a side effect, \`I\` is allowed to be empty, in which case the result is simply \`U\`.

References.

* https://en.wikipedia.org/wiki/Intersection_(set_theory)#Arbitrary_intersections
* https://proofwiki.org/wiki/Definition:Set_Intersection/Family_of_Sets"
`;

exports[`render hlm library: 1.1.22.2 Essentials/Sets/Generalized%20operators/Generalized%20intersection%20using%20power%20set 1`] = `
"Definition 1.1.22.2.  Let U be a set, S ⊆ 𝒫(U). We define:

  ⋂S := ⋂_((T) ∈ S) T

References.

* https://en.wikipedia.org/wiki/Intersection_(set_theory)#Arbitrary_intersections"
`;

exports[`render hlm library: 1.1.22.3 Essentials/Sets/Generalized%20operators/Generalized%20union 1`] = `
"Definition 1.1.22.3.  Let U be a set, I be a set, let S_i ⊆ U for each i ∈ I. We define:

  ⋃_(i ∈ I) S_i := {x ∈ U : ∃ j ∈ I : x ∈ S_j}

References.

* https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions
* https://proofwiki.org/wiki/Definition:Set_Union/Family_of_Sets"
`;

exports[`render hlm library: 1.1.22.4 Essentials/Sets/Generalized%20operators/Generalized%20union%20using%20power%20set 1`] = `
"Definition 1.1.22.4.  Let U be a set, S ⊆ 𝒫(U). We define:

  ⋃S := ⋃_((T) ∈ S) T

References.

* https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions"
`;

exports[`render hlm library: 1.1.22.5 Essentials/Sets/Generalized%20operators/Generalized%20disjoint%20union 1`] = `
"Definition 1.1.22.5.  Let I be a set, let S_i be a set for each i ∈ I, let ≃ be a dependent equality on S_i (i ∈ I). We define:

  ⨄_(i ∈ I)^≃ S_i :=: {(j, s) | j ∈ I, s ∈ S_j}

  (j, s) = (k, t)  :⇔  j = k and s ≃ t  (j ∈ I, s ∈ S_j, k ∈ I, t ∈ S_k)

Remarks.

In HLM, the disjoint union additionally needs to be equipped with a \\"dependent equality\\" \`≃\` that allows us to ask whether \`%equals(s, t)\` given \`%equals(j, k)\`.

References.

* https://en.wikipedia.org/wiki/Disjoint_union#Set_theory_definition
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#sigma"
`;

exports[`render hlm library: 1.1.22.6 Essentials/Sets/Generalized%20operators/Generalized%20cartesian%20product 1`] = `
"Definition 1.1.22.6.  Let I be a set, let S_i be a set for each i ∈ I. We define:

  ∏_(i ∈ I) S_i :=: {(s_j)_(j ∈ I) | s_j ∈ S_j for each j ∈ I}

  (s_j)_(j ∈ I) = (t_j)_(j ∈ I)  :⇔  ∀ j ∈ I : s_j = t_j  (s_j ∈ S_j for each j ∈ I, t_j ∈ S_j for each j ∈ I)

Remarks.

The generalized Cartesian product over an index set can be constructed in HLM via its integrated bound variable concept. It is essentially the same as a set of dependent functions.

References.

* https://en.wikipedia.org/wiki/Cartesian_product#Infinite_Cartesian_products
* https://proofwiki.org/wiki/Definition:Cartesian_Product/Family_of_Sets
* https://ncatlab.org/nlab/show/cartesian+product#in_sets"
`;

exports[`render hlm library: 1.1.23.1 Essentials/Sets/Choice/Choice%20functions 1`] = `
"Definition 1.1.23.1.  Let S be a set. We define:

  𝓒𝓱𝓸𝓲𝓬𝓮(S) := {f : (𝒫(S) ∖ {(∅)}) → S : ∀ T ⊆ S s.t. T is nonempty : f(T) ∈ T}

We write “let f be a choice function on S” for “let f ∈ 𝓒𝓱𝓸𝓲𝓬𝓮(S).”

References.

* https://en.wikipedia.org/wiki/Axiom_of_choice#Variants"
`;

exports[`render hlm library: 1.1.23.2 Essentials/Sets/Choice/choice 1`] = `
"Definition 1.1.23.2.  Let S be a set. We define:

  S has a choice function  :⇔  𝓒𝓱𝓸𝓲𝓬𝓮(S) is nonempty"
`;

exports[`render hlm library: 1.1.23.3 Essentials/Sets/Choice/axiom%20of%20choice 1`] = `
"Axiom 1.1.23.3 (Axiom of choice).  We define:

  AC  :⇔  ∀ sets S : S has a choice function

Remarks.

This is the simplest formulation of the axiom of choice that can be formalized in HLM. The standard formulation is not directly applicable because an indexed family of arbitrary sets cannot be defined as an object – there is no suitable equality definition.

It is possible to state, as a theorem, that AC implies that the Cartesian product \`$../\\"Generalized operators\\"/\\"Generalized cartesian product\\"\` of any family of nonempty sets is nonempty. However, whether this is provable in HLM remains to be investigated. The equivalence with Zorn's lemma and the well-ordering theorem is likely to hold.

HLM actually does not have \\"axioms\\" as a concept; an axiom is simply a predicate. Thus, at the moment, every theorem (or definition) that requires the axiom of choice (or a weaker form) must be prefixed accordingly:
* The simplest solution is to add \\"assume AC\\" as a condition. However, this condition will likely propagate to all dependent results, even if the axiom of choice is not needed in particular cases.
* A preferred method is to replace this with \\"assume \`S\` has a choice function\\" for a suitable \`S\`.
* Better yet, build the result explicitly from a given choice function.

Hopefully this will not be too inconvenient. It does have a few advantages:
* In particular cases where the axiom of choice is not needed, this fact becomes clear immediately.
* It is possible to state and prove relationships between the axiom of choice and other statements. (Again, it is preferable to state these equivalences as theorems about particular sets.)

As a last resort, HLM could be extended in two different ways:
* A choice operator could be included in the logic. (This would likely imply global choice, though.)
* The user interface could provide a mode that hides all references to the axiom of choice, and manages them automatically based on dependencies.

References.

* https://en.wikipedia.org/wiki/Axiom_of_choice
* https://mathworld.wolfram.com/AxiomofChoice.html
* https://proofwiki.org/wiki/Axiom:Axiom_of_Choice
* https://ncatlab.org/nlab/show/axiom+of+choice
* https://leanprover-community.github.io/mathlib_docs/core/init/classical.html#classical.choice (actually a choice operator, which is stronger)"
`;

exports[`render hlm library: 1.1.24.1 Essentials/Sets/Multisets/Multisets 1`] = `
"Definition 1.1.24.1.  Let S be a set. We define:

  𝓜𝓾𝓵𝓽𝓲𝓢𝓮𝓽(S) :=: {{s^(m_s)} | m_s ∈ ℕ for each s ∈ S}

  {s^(m_s)} = {s^(m'_s)}  :⇔  ∀ s ∈ S : m_s = m'_s  (m_s ∈ ℕ for each s ∈ S, m'_s ∈ ℕ for each s ∈ S)

We write “let 𝑻 be a/an S-multiset” for “let 𝑻 ∈ 𝓜𝓾𝓵𝓽𝓲𝓢𝓮𝓽(S).”

Remarks.

Note that we only formalize multi-subsets of a given set \`S\`. Arbitrary multisets cannot be defined because there is no suitable notion of equality.

A multi-subset of \`S\` is essentially the same as a function from \`S\` to \`$../../Numbers/Natural/\\"Natural numbers\\"\`.

References.

* https://en.wikipedia.org/wiki/Multiset
* https://mathworld.wolfram.com/Multiset.html
* https://proofwiki.org/wiki/Definition:Multiset
* https://ncatlab.org/nlab/show/multiset
* https://coq.inria.fr/library/Coq.Sets.Multiset.html
* https://leanprover-community.github.io/mathlib_docs/data/multiset/basic.html#multiset"
`;

exports[`render hlm library: 1.1.24.2 Essentials/Sets/Multisets/multiplicity 1`] = `
"Definition 1.1.24.2.  Let S be a set, 𝑻 be a/an S-multiset, t ∈ S. We define

  mult_𝑻(t)

by:

  mult_{s^(m_s)}(t) := m_t  (m_s ∈ ℕ for each s ∈ S)"
`;

exports[`render hlm library: 1.1.24.3 Essentials/Sets/Multisets/Set 1`] = `
"Definition 1.1.24.3.  Let S be a set, 𝑻 be a/an S-multiset. We define:

  Set(𝑻) := {s ∈ S : mult_𝑻(s) ≠ 0}

We write “let t ∈ 𝑻” for “let t ∈ Set(𝑻).”"
`;

exports[`render hlm library: 1.1.24.4 Essentials/Sets/Multisets/Items 1`] = `
"Definition 1.1.24.4.  Let S be a set, 𝑻 be a/an S-multiset, t ∈ S. We define:

  Items_𝑻(t) := {(t, n) : n ∈ ℕ_(<(mult_𝑻(t)))}"
`;

exports[`render hlm library: 1.1.24.5 Essentials/Sets/Multisets/Elements 1`] = `
"Definition 1.1.24.5.  Let S be a set, 𝑻 be a/an S-multiset. We define:

  Elems(𝑻) := {(t, n) : t ∈ S, n ∈ ℕ_(<(mult_𝑻(t)))}
   = ⋃_(t ∈ S) Items_𝑻(t)

Equality.  No proof."
`;

exports[`render hlm library: 1.1.24.6 Essentials/Sets/Multisets/cardinality 1`] = `
"Definition 1.1.24.6.  Let S be a set, 𝑻 be a/an S-multiset. We define:

  |𝑻| := |Elems(𝑻)|
   = {∑_(i ∈ Set(𝑻)) mult_𝑻(i) if 𝑻 is finite, |Set(𝑻)| if 𝑻 is infinite
   = {∑_(i ∈ S) mult_𝑻(i) if 𝑻 is finite, |Set(𝑻)| if 𝑻 is infinite

Equality.  No proof."
`;

exports[`render hlm library: 1.1.24.7 Essentials/Sets/Multisets/finite 1`] = `
"Definition 1.1.24.7.  Let S be a set, 𝑻 be a/an S-multiset. We define:

  𝑻 is finite  :⇔  |𝑻| is finite
    ⇔  Elems(𝑻) is finite
    ⇔  Set(𝑻) is finite

  𝑻 is infinite  :⇔  𝑻 is not finite

Equivalence.  No proof."
`;

exports[`render hlm library: 1.2.1 Essentials/Properties/Properties 1`] = `
"Definition 1.2.1.  Let S be a set. We define:

  𝓟𝓻𝓹(S) :=: {[p_s]_(s ∈ S) | p_s is a proposition for each s ∈ S}

  [p_s]_(s ∈ S) = [q_s]_(s ∈ S)  :⇔  ∀ s ∈ S : [p_s  ⇔  q_s]  (p_s is a proposition for each s ∈ S, q_s is a proposition for each s ∈ S)

We write “let p be a property on S” for “let p ∈ 𝓟𝓻𝓹(S).”

Remarks.

This definition encodes a property (aka unary relation) on \`S\` as a proposition depending on an element of \`S\` (up to equivalence). Since it is equally possible to encode a unary relation on \`S\` as a subset of \`S\`, this definition is interchangeable with \`$../Sets/\\"Power set\\"\`. The given definition is just more convenient.

References.

* https://en.wikipedia.org/wiki/Property_(mathematics)
* https://proofwiki.org/wiki/Definition:Propositional_Function"
`;

exports[`render hlm library: 1.2.2 Essentials/Properties/has%20property 1`] = `
"Definition 1.2.2.  Let S be a set, p be a property on S, s ∈ S. We define

  s is p

by:

  s is [p_t]_(t ∈ S)  :⇔  p_s  (p_t is a proposition for each t ∈ S)

  s is not p  :⇔  not [s is p]

Remarks.

\\"\`s\` is \`p\`\\" is shorthand for \\"\`s\` has property \`p\`.\\""
`;

exports[`render hlm library: 1.2.3 Essentials/Properties/implies 1`] = `
"Definition 1.2.3.  Let S be a set, p, q be properties on S. We define:

  (p ⇒ q)  :⇔  ∀ s ∈ S s.t. s is p : s is q

Remarks.

This definition is the equivalent of ⊆.

References.

* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#contains (for endorelations only)
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#subrelation (ditto)"
`;

exports[`render hlm library: 1.2.4 Essentials/Properties/conjunction 1`] = `
"Definition 1.2.4.  Let S be a set, p, q be properties on S. We define:

  p ∧ q := [s is p and s is q]_(s ∈ S)

Remarks.

This definition is the equivalent of \`$../Sets/Intersection\`."
`;

exports[`render hlm library: 1.2.5 Essentials/Properties/disjunction 1`] = `
"Definition 1.2.5.  Let S be a set, p, q be properties on S. We define:

  p ∨ q := [s is p or s is q]_(s ∈ S)

Remarks.

This definition is the equivalent of \`$../Sets/Union\`."
`;

exports[`render hlm library: 1.2.6 Essentials/Properties/generalized%20conjunction 1`] = `
"Definition 1.2.6.  Let S be a set, P ⊆ 𝓟𝓻𝓹(S). We define:

  ⋀P := [∀ p ∈ P : s is p]_(s ∈ S)

Remarks.

This definition is the equivalent of \`$../Sets/\\"Generalized operators\\"/\\"Generalized intersection using power set\\"\`."
`;

exports[`render hlm library: 1.2.7 Essentials/Properties/generalized%20disjunction 1`] = `
"Definition 1.2.7.  Let S be a set, P ⊆ 𝓟𝓻𝓹(S). We define:

  ⋁P := [∃ p ∈ P : s is p]_(s ∈ S)

Remarks.

This definition is the equivalent of \`$../Sets/\\"Generalized operators\\"/\\"Generalized union using power set\\"\`."
`;

exports[`render hlm library: 1.2.8 Essentials/Properties/restriction 1`] = `
"Definition 1.2.8.  Let S be a set, p be a property on S, T ⊆ S. We define:

  p∣_T := [t is p]_(t ∈ T)"
`;

exports[`render hlm library: 1.2.9 Essentials/Properties/Equality%20is%20extensional 1`] = `
"Proposition 1.2.9.  Let S be a set, s, t ∈ S. Then the following are equivalent:

  1. s = t
  2. ∀ p ∈ 𝓟𝓻𝓹(S) : [s is p  ⇔  t is p]

No proof."
`;

exports[`render hlm library: 1.3.1 Essentials/Relations/Relations 1`] = `
"Definition 1.3.1.  Let S, T be sets. We define:

  𝓡𝓮𝓵(S, T) :=: {[p_s,t]_s ∈ S,t ∈ T | p_s,t is a proposition for each s ∈ S and t ∈ T}

  [p_s,t]_s ∈ S,t ∈ T = [q_s,t]_s ∈ S,t ∈ T  :⇔  ∀ s ∈ S, t ∈ T : [p_s,t  ⇔  q_s,t]  (p_s,t is a proposition for each s ∈ S and t ∈ T, q_s,t is a proposition for each s ∈ S and t ∈ T)

𝓟𝓻𝓹(S × T) =: 𝓡𝓮𝓵(S, T) via
r = [(s, t) is r]_s ∈ S,t ∈ T

  Well-definedness.  No proof.

We write “let ≺ be a relation from S to T” for “let ≺ ∈ 𝓡𝓮𝓵(S, T).”

Remarks.

This definition encodes a relation from \`S\` to \`T\` as a proposition depending on an element of \`S\` and an element of \`T\` (up to equivalence). It would be equally possible to encode relations as subsets of the Cartesian product; the given definition is just more convenient.

References.

* https://en.wikipedia.org/wiki/Binary_relation
* https://mathworld.wolfram.com/Relation.html
* https://proofwiki.org/wiki/Definition:Relation
* https://ncatlab.org/nlab/show/relation#binary_relations
* https://leanprover-community.github.io/mathlib_docs/data/rel.html#rel"
`;

exports[`render hlm library: 1.3.2 Essentials/Relations/related 1`] = `
"Definition 1.3.2.  Let S, T be sets, ≺ be a relation from S to T, s ∈ S, t ∈ T. We define

  s ≺ t

by:

  s [p_u,v]_u ∈ S,v ∈ T t  :⇔  p_s,t  (p_u,v is a proposition for each u ∈ S and v ∈ T)"
`;

exports[`render hlm library: 1.3.3 Essentials/Relations/converse 1`] = `
"Definition 1.3.3.  Let S, T be sets, ≺ be a relation from S to T. We define:

  ≺^T := [s ≺ t]_t ∈ T,s ∈ S

References.

* https://en.wikipedia.org/wiki/Converse_relation
* https://proofwiki.org/wiki/Definition:Inverse_Relation
* https://leanprover-community.github.io/mathlib_docs/data/rel.html#rel.inv"
`;

exports[`render hlm library: 1.3.4 Essentials/Relations/mapping 1`] = `
"Definition 1.3.4.  Let S, T be sets, ≺ be a relation from S to T. We define:

  ≺ is a mapping  :⇔  ∀ s ∈ S : ∃! t ∈ T : s ≺ t

Remarks.

In this library, \\"mapping\\" and \\"function\\" are not synonymous but interchangeable, via a definition that transforms a mapping to a function (see \`$../Functions/\\"mapping as function\\"\`). The difference is not fundamental but a matter of convenience.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)
* https://mathworld.wolfram.com/Function.html
* https://proofwiki.org/wiki/Definition:Mapping"
`;

exports[`render hlm library: 1.3.5 Essentials/Relations/mapping%20value 1`] = `
"Definition 1.3.5.  Let S, T be sets, ≺ be a mapping from S to T, s ∈ S. For t ∈ T, we define:

  ≺(s) = t  :⇔  s ≺ t

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)#Functional_notation"
`;

exports[`render hlm library: 1.3.6 Essentials/Relations/Endorelations 1`] = `
"Definition 1.3.6 (Endorelations).  Let S be a set. We define:

  𝓡𝓮𝓵(S) :=: {[p_s,t]_(s,t ∈ S) | p_s,t is a proposition for each s, t ∈ S}

  [p_s,t]_(s,t ∈ S) = [q_s,t]_(s,t ∈ S)  :⇔  ∀ s, t ∈ S : [p_s,t  ⇔  q_s,t]  (p_s,t is a proposition for each s, t ∈ S, q_s,t is a proposition for each s, t ∈ S)

𝓡𝓮𝓵(S, S) =: 𝓡𝓮𝓵(S) via
≺ = [s ≺ t]_(s,t ∈ S)

  Well-definedness.  No proof.

We write “let ≺ be a relation on S” for “let ≺ ∈ 𝓡𝓮𝓵(S).”

Remarks.

Since endorelations are used often, we encode them as a separate construction with an appropriate embedding, mainly to improve rendering.

References.

* https://en.wikipedia.org/wiki/Binary_relation#Relations_over_a_set
* https://mathworld.wolfram.com/Relation.html
* https://proofwiki.org/wiki/Definition:Endorelation
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Relation"
`;

exports[`render hlm library: 1.3.7 Essentials/Relations/restriction 1`] = `
"Definition 1.3.7.  Let S be a set, ≺ be a relation on S, T ⊆ S. We define:

  ≺∣_T := ≺∣_(T×T)"
`;

exports[`render hlm library: 1.3.8 Essentials/Relations/equality 1`] = `
"Definition 1.3.8.  Let S be a set. We define:

  (=_S) := [s = t]_(s,t ∈ S)

References.

* https://en.wikipedia.org/wiki/Binary_relation#Particular_binary_relations: identity relation
* https://proofwiki.org/wiki/Definition:Diagonal_Relation
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#eq"
`;

exports[`render hlm library: 1.3.9 Essentials/Relations/reflexive 1`] = `
"Definition 1.3.9.  Let S be a set, ⪯ be a relation on S. We define:

  ⪯ is reflexive  :⇔  ∀ s ∈ S : s ⪯ s

References.

* https://en.wikipedia.org/wiki/Reflexive_relation
* https://mathworld.wolfram.com/Reflexive.html
* https://proofwiki.org/wiki/Definition:Reflexive_Relation
* https://ncatlab.org/nlab/show/reflexive+relation
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Reflexive
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#reflexive"
`;

exports[`render hlm library: 1.3.10 Essentials/Relations/connex 1`] = `
"Definition 1.3.10.  Let S be a set, ≺ be a relation on S. We define:

  ≺ is connex  :⇔  ∀ s, t ∈ S : [s ≺ t or t ≺ s]

References.

* https://en.wikipedia.org/wiki/Connex_relation
* https://proofwiki.org/wiki/Definition:Total_Relation
* https://ncatlab.org/nlab/show/total+relation
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#total"
`;

exports[`render hlm library: 1.3.11 Essentials/Relations/symmetric 1`] = `
"Definition 1.3.11.  Let S be a set, ≺ be a relation on S. We define:

  ≺ is symmetric  :⇔  ∀ s, t ∈ S s.t. s ≺ t : t ≺ s
    ⇔  ≺ = ≺^T

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Symmetric_relation
* https://mathworld.wolfram.com/SymmetricRelation.html
* https://proofwiki.org/wiki/Definition:Symmetric_Relation
* https://ncatlab.org/nlab/show/symmetric+relation
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Symmetric
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#symmetric"
`;

exports[`render hlm library: 1.3.12 Essentials/Relations/antisymmetric 1`] = `
"Definition 1.3.12.  Let S be a set, ⪯ be a relation on S. We define:

  ⪯ is antisymmetric  :⇔  ∀ s, t ∈ S s.t. s ⪯ t and t ⪯ s : s = t

References.

* https://en.wikipedia.org/wiki/Antisymmetric_relation
* https://mathworld.wolfram.com/AntisymmetricRelation.html
* https://proofwiki.org/wiki/Definition:Antisymmetric_Relation
* https://ncatlab.org/nlab/show/antisymmetric+relation
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Antisymmetric
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#anti_symmetric"
`;

exports[`render hlm library: 1.3.13 Essentials/Relations/transitive 1`] = `
"Definition 1.3.13.  Let S be a set, ≺ be a relation on S. We define:

  ≺ is transitive  :⇔  ∀ s, t, u ∈ S s.t. s ≺ t and t ≺ u : s ≺ u

References.

* https://en.wikipedia.org/wiki/Transitive_relation
* https://mathworld.wolfram.com/Transitive.html
* https://proofwiki.org/wiki/Definition:Transitive_Relation
* https://ncatlab.org/nlab/show/transitive+relation
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Transitive
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#transitive"
`;

exports[`render hlm library: 1.3.14 Essentials/Relations/preorder 1`] = `
"Definition 1.3.14.  Let S be a set, ⪯ be a relation on S. We define:

  ⪯ is a preorder  :⇔  ⪯ is reflexive and ⪯ is transitive

References.

* https://en.wikipedia.org/wiki/Preorder
* https://mathworld.wolfram.com/Preorder.html
* https://proofwiki.org/wiki/Definition:Preordering
* https://ncatlab.org/nlab/show/preorder
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Preorder
* https://leanprover-community.github.io/mathlib_docs/core/init/algebra/order.html#preorder"
`;

exports[`render hlm library: 1.3.15 Essentials/Relations/partial%20order 1`] = `
"Definition 1.3.15.  Let S be a set, ⪯ be a relation on S. We define:

  ⪯ is a partial order  :⇔  ⪯ is reflexive and ⪯ is antisymmetric and ⪯ is transitive
    ⇔  ⪯ is a preorder and ⪯ is antisymmetric

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition
* https://mathworld.wolfram.com/PartialOrder.html
* https://proofwiki.org/wiki/Definition:Ordering
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Order
* https://leanprover-community.github.io/mathlib_docs/core/init/algebra/order.html#partial_order"
`;

exports[`render hlm library: 1.3.16 Essentials/Relations/total%20order 1`] = `
"Definition 1.3.16.  Let S be a set, ⪯ be a relation on S. We define:

  ⪯ is a total order  :⇔  ⪯ is connex and ⪯ is antisymmetric and ⪯ is transitive
    ⇔  ⪯ is a partial order and ⪯ is connex

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Total_order
* https://mathworld.wolfram.com/TotallyOrderedSet.html
* https://proofwiki.org/wiki/Definition:Total_Ordering
* https://leanprover-community.github.io/mathlib_docs/core/init/algebra/order.html#linear_order"
`;

exports[`render hlm library: 1.3.17 Essentials/Relations/lower%20bound 1`] = `
"Definition 1.3.17.  Let S be a set, ≺ be a relation on S, T ⊆ S, s ∈ S. We define:

  s is a ≺-lower bound of T  :⇔  ∀ t ∈ T : s ≺ t"
`;

exports[`render hlm library: 1.3.18 Essentials/Relations/upper%20bound 1`] = `
"Definition 1.3.18.  Let S be a set, ≺ be a relation on S, T ⊆ S, s ∈ S. We define:

  s is a ≺-upper bound of T  :⇔  ∀ t ∈ T : t ≺ s
    ⇔  s is a ≺^T-lower bound of T

Equivalence.  No proof."
`;

exports[`render hlm library: 1.3.19 Essentials/Relations/least%20element 1`] = `
"Definition 1.3.19.  Let S be a set, ⪯ be a relation on S, T ⊆ S, t ∈ T. We define:

  t is a ⪯-least element of T  :⇔  t is a ⪯-lower bound of T

References.

* https://en.wikipedia.org/wiki/Greatest_and_least_elements"
`;

exports[`render hlm library: 1.3.20 Essentials/Relations/greatest%20element 1`] = `
"Definition 1.3.20.  Let S be a set, ⪯ be a relation on S, T ⊆ S, t ∈ T. We define:

  t is a ⪯-greatest element of T  :⇔  t is a ⪯-upper bound of T
    ⇔  t is a ⪯^T-least element of T

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Greatest_and_least_elements"
`;

exports[`render hlm library: 1.3.21 Essentials/Relations/well-order 1`] = `
"Definition 1.3.21.  Let S be a set, ⪯ be a relation on S. We define:

  ⪯ is a well-order  :⇔  ⪯ is a total order and ∀ T ⊆ S s.t. T is nonempty : ∃ t ∈ T : t is a ⪯-least element of T

References.

* https://en.wikipedia.org/wiki/Well-order
* https://mathworld.wolfram.com/WellOrderedSet.html
* https://proofwiki.org/wiki/Definition:Well-Ordering
* https://ncatlab.org/nlab/show/well-order"
`;

exports[`render hlm library: 1.3.22 Essentials/Relations/equivalence 1`] = `
"Definition 1.3.22.  Let S be a set, ≺ be a relation on S. We define:

  ≺ is an equivalence relation  :⇔  ≺ is a preorder and ≺ is symmetric

References.

* https://en.wikipedia.org/wiki/Equivalence_relation
* https://mathworld.wolfram.com/EquivalenceRelation.html
* https://proofwiki.org/wiki/Definition:Equivalence_Relation
* https://ncatlab.org/nlab/show/equivalence+relation
* https://coq.inria.fr/library/Coq.Sets.Relations_1.html#Equivalence
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#equivalence"
`;

exports[`render hlm library: 1.3.23 Essentials/Relations/Equivalence%20classes 1`] = `
"Definition 1.3.23.  Let S be a set, ∼ be an equivalence relation on S. We define:

  S∕∼ :=: {[s]_∼ | s ∈ S}

  [s]_∼ = [t]_∼  :⇔  s ∼ t  (s ∈ S, t ∈ S)

    Reflexivity.  No proof.

    Symmetry.  No proof.

    Transitivity.  No proof.

Remarks.

This definition uses the \\"construction\\" concept to define quotient sets and equivalence classes, which is straightforward because the requirements for an equality definition are precisely the properties of an equivalence relation.

A more traditional definition where equivalence classes are subsets of \`S\` is possible as well, of course. Then the set of equivalence classes is a subset of the power set. However, the given definition has the advantage that well-definedness proofs can be stated more easily. On the other hand, there is the drawback that since equivalence classes are not sets, it is not directly possible to ask about their cardinality, etc. Moreover, there should be a general definition of a partition, and a theorem that equivalence classes form a partition; this requires the powerset approach.

In the end, there may need to be two different but interchangeable definitions of equivalence classes.

References.

* https://en.wikipedia.org/wiki/Equivalence_class
* https://mathworld.wolfram.com/EquivalenceClass.html
* https://proofwiki.org/wiki/Definition:Equivalence_Class
* https://ncatlab.org/nlab/show/equivalence+class
* https://leanprover-community.github.io/mathlib_docs/core/init/data/quot.html#quotient"
`;

exports[`render hlm library: 1.3.24 Essentials/Relations/succession 1`] = `
"Definition 1.3.24 (Succession).  Let S, T be sets, ⪯ be a partial order on S, ⊑ be a partial order on T. We define:

  ⪯ ≪ ⊑ := [{[{s_a ⪯ s_b if a = l(s_a) (s_a ∈ S), false if a = r(t_a) (t_a ∈ T)] if b = l(s_b) (s_b ∈ S), [{true if a = l(s_a) (s_a ∈ S), t_a ⊑ t_b if a = r(t_a) (t_a ∈ T)] if b = r(t_b) (t_b ∈ T)]_(a,b ∈ S ⊎ T)

Remarks.

This definition constructs a partial order on the disjoint union of two sets \`S\` and \`T\` from partial orders on \`S\` and \`T\`. Elements of \`S\` are always considered smaller than elements of \`T\`. This is used to define addition of ordinal numbers (see \`$../Numbers/Ordinal/sum\`).

References.

* https://en.wikipedia.org/wiki/Ordinal_arithmetic#Addition
* https://leanprover-community.github.io/mathlib_docs/data/sum.html#sum.lex"
`;

exports[`render hlm library: 1.3.25 Essentials/Relations/lexicographical%20order 1`] = `
"Definition 1.3.25 (Lexicographical order).  Let S, T be sets, ⪯ be a partial order on S, ⊑ be a partial order on T. We define:

  ⪯ ∠ ⊑ := [s ⪯ s' and [s ≠ s' or t ⊑ t']]_((s,t),(s',t') ∈ S×T)

Remarks.

This definition constructs a partial order on the Cartesian product of two sets \`S\` and \`T\` from partial orders on \`S\` and \`T\`, combining the two partial orders lexicographically. It is used to define multiplication of ordinal numbers (see \`$../Numbers/Ordinal/product\`).

References.

* https://en.wikipedia.org/wiki/Lexicographical_order#Cartesian_products
* https://mathworld.wolfram.com/LexicographicOrder.html
* https://proofwiki.org/wiki/Definition:Lexicographic_Order
* https://ncatlab.org/nlab/show/lexicographic+order
* https://leanprover-community.github.io/mathlib_docs/core/init/wf.html#prod.lex"
`;

exports[`render hlm library: 1.3.26.1 Essentials/Relations/Closures/closure 1`] = `
"Definition 1.3.26.1.  Let S, T be sets, ≺ be a relation from S to T, p be a property on 𝓡𝓮𝓵(S, T). We define:

  cl_p(≺) := ⋀{⊂ ∈ 𝓡𝓮𝓵(S, T) : [≺ ⇒ ⊂] and ⊂ is p}

Remarks.

This is an attempt at a general definition of the closure of a relation with respect to a property, i.e. the smallest relation that contains the original relation and satisfies the property. Note that it only works for properties that are closed under generalized conjunctions aka intersections, which should probably be included as a requirement.

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures"
`;

exports[`render hlm library: 1.3.26.2 Essentials/Relations/Closures/reflexive%20closure 1`] = `
"Definition 1.3.26.2.  Let S be a set, ≺ be a relation on S. We define:

  ≺^= := cl_reflexive(≺)
   = ≺ ∨ (=_S)

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Reflexive_closure
* https://mathworld.wolfram.com/ReflexiveClosure.html
* https://proofwiki.org/wiki/Definition:Reflexive_Closure
* https://leanprover-community.github.io/mathlib_docs/logic/relation.html#relation.refl_gen"
`;

exports[`render hlm library: 1.3.26.3 Essentials/Relations/Closures/symmetric%20closure 1`] = `
"Definition 1.3.26.3.  Let S be a set, ≺ be a relation on S. We define:

  ≺^↔ := cl_symmetric(≺)
   = ≺ ∨ ≺^T

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Symmetric_closure
* https://proofwiki.org/wiki/Definition:Symmetric_Closure"
`;

exports[`render hlm library: 1.3.26.4 Essentials/Relations/Closures/reflexive%20symmetric%20closure 1`] = `
"Definition 1.3.26.4.  Let S be a set, ≺ be a relation on S. We define:

  ≺^⇔ := cl_(reflexive ∧ symmetric)(≺)
   = (≺^=)^↔
   = (≺^↔)^=

Equality.  No proof."
`;

exports[`render hlm library: 1.3.26.5 Essentials/Relations/Closures/transitive%20closure 1`] = `
"Definition 1.3.26.5.  Let S be a set, ≺ be a relation on S. We define:

  ≺^+ := cl_transitive(≺)

References.

* https://en.wikipedia.org/wiki/Transitive_closure
* https://mathworld.wolfram.com/TransitiveClosure.html
* https://proofwiki.org/wiki/Definition:Transitive_Closure_(Relation_Theory)
* https://ncatlab.org/nlab/show/transitive+closure
* https://leanprover-community.github.io/mathlib_docs/logic/relation.html#relation.trans_gen"
`;

exports[`render hlm library: 1.3.26.6 Essentials/Relations/Closures/reflexive%20transitive%20closure 1`] = `
"Definition 1.3.26.6.  Let S be a set, ≺ be a relation on S. We define:

  ≺^∗ := cl_preorder(≺)
   = (≺^+)^=
   = (≺^=)^+

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures: reflexive transitive closure
* https://proofwiki.org/wiki/Definition:Reflexive_Transitive_Closure
* https://ncatlab.org/nlab/show/transitive+closure
* https://leanprover-community.github.io/mathlib_docs/logic/relation.html#relation.refl_trans_gen"
`;

exports[`render hlm library: 1.3.26.7 Essentials/Relations/Closures/reflexive%20symmetric%20transitive%20closure 1`] = `
"Definition 1.3.26.7.  Let S be a set, ≺ be a relation on S. We define:

  ≺^≡ := cl_equivalence relation(≺)

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures: reflexive transitive symmetric closure"
`;

exports[`render hlm library: 1.3.27.1 Essentials/Relations/Dependent%20equality/Dependent%20equality 1`] = `
"Definition 1.3.27.1.  Let I be a set, let S_i be a set for each i ∈ I. We define:

  𝓓𝓮𝓹𝓔𝓺((S_i)_(i∈I)) :=: {(≡_a,b)_(a = b)^((S_i)_(i∈I)) | ≡_a,b is a relation from S_a to S_b for each a, b ∈ I s.t. a = b, [∀ i ∈ I : ≡_i,i = (=_(S_i))]}

  (≡_a,b)_(a = b)^((S_i)_(i∈I)) = (≡'_a,b)_(a = b)^((S_i)_(i∈I))  :⇔  ∀ a, b ∈ I : ≡_a,b = ≡'_a,b  (≡_a,b is a relation from S_a to S_b for each a, b ∈ I s.t. a = b, ≡'_a,b is a relation from S_a to S_b for each a, b ∈ I s.t. a = b with suitable conditions)

We write “let ≃ be a dependent equality on S_i (i ∈ I)” for “let ≃ ∈ 𝓓𝓮𝓹𝓔𝓺((S_i)_(i∈I)).”

Remarks.

This somewhat technical construction exposes the equality relation on \`S[i = i]\` in such a way that it becomes possible to ask whether \`%equals(s, t)\` for \`%in(s, S[i = a])\` and \`%in(t, S[i = b])\` whenever a \`%equals(a, b)\`.

It might seem that asking whether \`%equals(s, t)\` should simply be allowed in this case, but the type system of HLM restricts it to the case when \`a\` and \`b\` are literally the same expression. If \`%equals(a, b)\` is given as a proposition, the equality can carry information that needs to be transported from \`I\` to \`S\`.

E.g. in category theory, \`I\` may be a set of objects (which are equal whenever they are isomorphic), and \`S[i = i]\` may be a set of morphisms from or to \`i\`. To check whether two of these morphisms are equal, one of them first needs to be composed with a specific isomorphism.

Dependent equality is a prerequisite to formalizing arbitrary disjoint unions (see \`$../../Sets/\\"Generalized operators\\"/\\"Generalized disjoint union\\"\`)."
`;

exports[`render hlm library: 1.3.27.2 Essentials/Relations/Dependent%20equality/dependently%20equal 1`] = `
"Definition 1.3.27.2.  Let I be a set, let S_i be a set for each i ∈ I, let ≃ be a dependent equality on S_i (i ∈ I), a, b ∈ I, s ∈ S_a, t ∈ S_b. We define

  s ≃ t

by:

  s (≡_j,k)_(j = k)^((S_i)_(i∈I)) t  :⇔  s ≡_a,b t  (≡_j,k is a relation from S_j to S_k for each j, k ∈ I s.t. j = k, [∀ i ∈ I : ≡_i,i = (=_(S_i))])"
`;

exports[`render hlm library: 1.4.1 Essentials/Functions/Functions 1`] = `
"Definition 1.4.1.  Let X, Y be sets. We define:

  (X → Y) :=: {(X → Y, x ↦ y_x) | y_x ∈ Y for each x ∈ X}

  (X → Y, x ↦ y_x) = (X → Y, x ↦ y'_x)  :⇔  ∀ x ∈ X : y_x = y'_x  (y_x ∈ Y for each x ∈ X, y'_x ∈ Y for each x ∈ X)

We write “let f : X → Y be a function” for “let f ∈ (X → Y).”

We write “f :  X → Y, x ↦ y_x” for “f := (X → Y, x ↦ y_x).”

Remarks.

This definition uses binders as a built-in feature of the HLM logic. It is equivalent to the usual set-theoretic definition, which is called \\"mapping\\" in this library to distinguish the two definitions (see \`$../Relations/mapping\`, \`$\\"mapping as function\\"\`).

The major advantage of the definition using binders is that given an explicitly defined function, determining the value at a specific input is simply a matter of resolving definitions.

Function [extensionality](https://en.wikipedia.org/wiki/Extensionality) is a consequence of the requirement to specify an equality definition for the constructor.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)
* https://mathworld.wolfram.com/Function.html
* https://proofwiki.org/wiki/Definition:Mapping
* https://ncatlab.org/nlab/show/function
* https://coq.inria.fr/library/Coq.Program.Basics.html#arrow"
`;

exports[`render hlm library: 1.4.2 Essentials/Functions/value 1`] = `
"Definition 1.4.2.  Let X, Y be sets, f : X → Y be a function, x ∈ X. We define

  f(x)

by:

  (X → Y, z ↦ y_z)(x) := y_x  (y_z ∈ Y for each z ∈ X)

Remarks.

This explicit definition works due to the special way that functions are defined. Within proofs, it enables unfolding of function application if the function has an explicit definition.
The corresponding definition for mappings (see \`$../Relations/\\"mapping value\\"\`) is an implicit definition instead.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)#Functional_notation
* https://coq.inria.fr/library/Coq.Program.Basics.html#apply
* https://leanprover-community.github.io/mathlib_docs/core/init/function.html#function.app"
`;

exports[`render hlm library: 1.4.3 Essentials/Functions/Image 1`] = `
"Definition 1.4.3.  Let X, Y be sets, f : X → Y be a function, S ⊆ X. We define:

  f(S) := {f(x) : x ∈ S}

References.

* https://en.wikipedia.org/wiki/Image_(mathematics)
* https://proofwiki.org/wiki/Definition:Image_(Set_Theory)/Mapping/Subset
* https://leanprover-community.github.io/mathlib_docs/core/init/data/set.html#set.image"
`;

exports[`render hlm library: 1.4.4 Essentials/Functions/Preimage 1`] = `
"Definition 1.4.4.  Let X, Y be sets, f : X → Y be a function, S ⊆ Y. We define:

  f^-1(S) := {x ∈ X : f(x) ∈ S}

References.

* https://en.wikipedia.org/wiki/Preimage"
`;

exports[`render hlm library: 1.4.5 Essentials/Functions/mapping%20as%20function 1`] = `
"Definition 1.4.5.  Let S, T be sets, ≺ be a mapping from S to T. We define:

  (≺)_(S→T) :  S → T, s ↦ ≺(s)

Remarks.

This definition shows that mappings and functions, as defined in this library, are interchangeable. (The other direction is straightforward as well.)"
`;

exports[`render hlm library: 1.4.6 Essentials/Functions/identity 1`] = `
"Definition 1.4.6.  Let X be a set. We define:

  id_X :  X → X, x ↦ x

References.

* https://en.wikipedia.org/wiki/Identity_function
* https://proofwiki.org/wiki/Definition:Identity_Mapping
* https://coq.inria.fr/library/Coq.Init.Datatypes.html#id
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#id"
`;

exports[`render hlm library: 1.4.7 Essentials/Functions/generalized%20restriction 1`] = `
"Definition 1.4.7.  Let X be a set, A ⊆ X, B be a set, Y ⊆ B, f : X → Y be a function. We define:

  f∣_A^B :  A → B, x ↦ f(x)

Remarks.

This definition is a slight extension of \`$restriction\` that simultaneously extends the codomain to a superset \`B\` of \`Y\`.

It might seem tempting to remove the need for this definition by implicitly treating a function to \`Y\` as a function to a superset \`B\` of \`Y\`, without explicitly specifying \`B\`. However, this could lead to confusion as the resulting function may not be surjective even though the original function is."
`;

exports[`render hlm library: 1.4.8 Essentials/Functions/codomain%20restriction 1`] = `
"Definition 1.4.8.  Let X be a set, A ⊆ X, Y be a set, B ⊆ Y, f : X → Y be a function such that f(A) ⊆ B. We define:

  f∣_A^B :  A → B, x ↦ f(x)

Remarks.

This definition is a slight extension of \`$restriction\` that simultaneously restricts the codomain to a subset \`B\` of \`Y\`, under the condition that the range is contained in this subset. It is compatible with the previous definition.

References.

* https://proofwiki.org/wiki/Definition:Restriction/Mapping"
`;

exports[`render hlm library: 1.4.9 Essentials/Functions/restriction 1`] = `
"Definition 1.4.9.  Let X be a set, A ⊆ X, Y be a set, f : X → Y be a function. We define:

  f∣_A := f∣_A^Y

References.

* https://en.wikipedia.org/wiki/Restriction_(mathematics)
* https://proofwiki.org/wiki/Definition:Restriction/Mapping
* https://ncatlab.org/nlab/show/restriction
* https://leanprover-community.github.io/mathlib_docs/data/subtype.html#subtype.restrict"
`;

exports[`render hlm library: 1.4.10 Essentials/Functions/composition 1`] = `
"Definition 1.4.10.  Let X, Y, Z be sets, f : X → Y, g : Y → Z be functions. We define:

  g ∘ f :  X → Z, x ↦ g(f(x))

References.

* https://en.wikipedia.org/wiki/Function_composition
* https://mathworld.wolfram.com/Composition.html
* https://proofwiki.org/wiki/Definition:Composition_of_Mappings
* https://ncatlab.org/nlab/show/composition
* https://coq.inria.fr/library/Coq.Program.Basics.html#compose
* https://leanprover-community.github.io/mathlib_docs/core/init/function.html#function.comp"
`;

exports[`render hlm library: 1.4.11 Essentials/Functions/Composition%20is%20associative 1`] = `
"Proposition 1.4.11.  Let W, X, Y, Z be sets, f : W → X, g : X → Y, h : Y → Z be functions. Then:

  (h ∘ g) ∘ f = h ∘ (g ∘ f)

No proof.

References.

* https://en.wikipedia.org/wiki/Function_composition#Properties
* https://mathworld.wolfram.com/Composition.html
* https://proofwiki.org/wiki/Composition_of_Mappings_is_Associative
* https://coq.inria.fr/library/Coq.Program.Combinators.html#compose_assoc
* https://leanprover-community.github.io/mathlib_docs/core/init/function.html#function.comp.assoc"
`;

exports[`render hlm library: 1.4.12 Essentials/Functions/cartesian%20product 1`] = `
"Definition 1.4.12.  Let V, W, X, Y be sets, f : V → W, g : X → Y be functions. We define:

  f × g :  V × X → W × Y, (v, x) ↦ (f(v), g(x))

Remarks.

This definition is not standard in mathematics but convenient in some cases."
`;

exports[`render hlm library: 1.4.13 Essentials/Functions/injective 1`] = `
"Definition 1.4.13.  Let X, Y be sets, f : X → Y be a function. We define:

  f is injective  :⇔  ∀ a, b ∈ X s.t. f(a) = f(b) : a = b
    ⇔  ∀ c ∈ Y, d, e ∈ f^-1({c}) : d = e
    ⇔  ∀ y ∈ f(X) : ∃! x ∈ X : f(x) = y
    ⇔  X is empty or ∃ g : Y → X : g ∘ f = id_X

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Injective_function
* https://mathworld.wolfram.com/Injection.html
* https://proofwiki.org/wiki/Definition:Injection
* https://ncatlab.org/nlab/show/injection
* https://leanprover-community.github.io/mathlib_docs/core/init/function.html#function.injective"
`;

exports[`render hlm library: 1.4.14 Essentials/Functions/surjective 1`] = `
"Definition 1.4.14.  Let X, Y be sets, f : X → Y be a function. We define:

  f is surjective  :⇔  ∀ y ∈ Y : ∃ x ∈ X : f(x) = y
    ⇔  Y ⊆ f(X)
    ⇔  f(X) = Y

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Surjective_function
* https://mathworld.wolfram.com/Surjection.html
* https://proofwiki.org/wiki/Definition:Surjection
* https://ncatlab.org/nlab/show/surjection
* https://leanprover-community.github.io/mathlib_docs/core/init/function.html#function.surjective"
`;

exports[`render hlm library: 1.4.15 Essentials/Functions/bijective 1`] = `
"Definition 1.4.15.  Let X, Y be sets, f : X → Y be a function. We define:

  f is bijective  :⇔  f is injective and f is surjective
    ⇔  ∀ y ∈ Y : ∃! x ∈ X : f(x) = y
    ⇔  ∃ g : Y → X : [g ∘ f = id_X and f ∘ g = id_Y]
    ⇔  ∃! g : Y → X : [g ∘ f = id_X and f ∘ g = id_Y]

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Bijective_function
* https://mathworld.wolfram.com/Bijection.html
* https://proofwiki.org/wiki/Definition:Bijection
* https://proofwiki.org/wiki/Bijection_iff_Left_and_Right_Inverse
* https://ncatlab.org/nlab/show/bijection
* https://leanprover-community.github.io/mathlib_docs/core/init/function.html#function.bijective
* https://leanprover-community.github.io/mathlib_docs/logic/function/basic.html#function.bijective_iff_has_inverse"
`;

exports[`render hlm library: 1.4.16 Essentials/Functions/Generalized%20restriction%20preserves%20injectivity 1`] = `
"Proposition 1.4.16.  Let X be a set, A ⊆ X, B be a set, Y ⊆ B, f : X → Y be an injective function. Then:

  f∣_A^B is injective

No proof."
`;

exports[`render hlm library: 1.4.17 Essentials/Functions/Restriction%20preserves%20injectivity 1`] = `
"Corollary 1.4.17.  Let X be a set, A ⊆ X, Y be a set, f : X → Y be an injective function. Then:

  f∣_A is injective

No proof."
`;

exports[`render hlm library: 1.4.18 Essentials/Functions/Generalized%20extension%20preserves%20surjectivity 1`] = `
"Proposition 1.4.18.  Let X be a set, A ⊆ X, B be a set, Y ⊆ B, f : X → Y be a function such that f∣_A^B is surjective. Then:

  f is surjective

No proof."
`;

exports[`render hlm library: 1.4.19 Essentials/Functions/Extension%20preserves%20surjectivity 1`] = `
"Corollary 1.4.19.  Let X be a set, A ⊆ X, Y be a set, f : X → Y be a function such that f∣_A is surjective. Then:

  f is surjective

No proof."
`;

exports[`render hlm library: 1.4.20 Essentials/Functions/Surjectivity%20by%20codomain%20restriction 1`] = `
"Proposition 1.4.20.  Let X be a set, A ⊆ X, Y be a set, f : X → Y be a function. Then:

  f∣_A^(f(A)) is surjective

No proof."
`;

exports[`render hlm library: 1.4.21 Essentials/Functions/Bijections 1`] = `
"Definition 1.4.21.  Let X, Y be sets. We define:

  (X ↔ Y) := {f : X → Y : f is bijective}

We write “let f : X ↔ Y be a bijection” for “let f ∈ (X ↔ Y).”

Remarks.

Bijections are important enough to warrant their own notation. A bidirectional arrow seems appropriate, even though it does not appear to be standard.

References.

* https://en.wikipedia.org/wiki/Bijective_function
* https://mathworld.wolfram.com/Bijection.html
* https://proofwiki.org/wiki/Definition:Bijection
* https://ncatlab.org/nlab/show/bijection"
`;

exports[`render hlm library: 1.4.22 Essentials/Functions/inverse 1`] = `
"Definition 1.4.22.  Let X, Y be sets, f : X ↔ Y be a bijection. For g : Y ↔ X, we define:

  f^-1 = g  :⇔  g ∘ f = id_X
    ⇔  f ∘ g = id_Y

Equivalence.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Inverse_function
* https://mathworld.wolfram.com/InverseFunction.html
* https://proofwiki.org/wiki/Definition:Inverse_Mapping
* https://ncatlab.org/nlab/show/inverse
* https://leanprover-community.github.io/mathlib_docs/logic/function/basic.html#function.inv_fun"
`;

exports[`render hlm library: 1.4.23 Essentials/Functions/Inverse%20of%20inverse%20yields%20original 1`] = `
"Proposition 1.4.23.  Let X, Y be sets, f : X ↔ Y be a bijection. Then:

  (f^-1)^-1 = f

No proof."
`;

exports[`render hlm library: 1.4.24 Essentials/Functions/Application%20of%20function%20and%20inverse%20is%20neutral 1`] = `
"Corollary 1.4.24.  Let X, Y be sets, f : X ↔ Y be a bijection, x ∈ X. Then:

  f^-1(f(x)) = x

No proof."
`;

exports[`render hlm library: 1.4.25 Essentials/Functions/Application%20of%20function%20after%20inverse%20is%20neutral 1`] = `
"Corollary 1.4.25.  Let X, Y be sets, f : X ↔ Y be a bijection, y ∈ Y. Then:

  f(f^-1(y)) = y

No proof."
`;

exports[`render hlm library: 1.4.26 Essentials/Functions/power%20to%20natural%20number 1`] = `
"Definition 1.4.26.  Let X be a set, f : X → X be a function, n ∈ ℕ. We define

  f^n

by:

  f^0 := id_X
  f^(x+1) := f ∘ f^x  (x ∈ ℕ)

References.

* https://en.wikipedia.org/wiki/Iterated_function
* https://mathworld.wolfram.com/IteratedMap.html"
`;

exports[`render hlm library: 1.4.27 Essentials/Functions/power%20to%20integer 1`] = `
"Definition 1.4.27.  Let X be a set, f : X ↔ X be a bijection, a ∈ ℤ. We define:

  f^a := {f^a if a ≥ 0, (f^-1)^(−a) if a < 0"
`;

exports[`render hlm library: 1.4.28 Essentials/Functions/Power%20of%20identity%20is%20identity 1`] = `
"Proposition 1.4.28.  Let X be a set, a ∈ ℤ. Then:

  (id_X)^a = id_X

No proof."
`;

exports[`render hlm library: 1.5.1 Essentials/Operations/Operations 1`] = `
"Definition 1.5.1.  Let X, Y, Z be sets. We define:

  𝓞𝓹(X, Y, Z) :=: {(X × Y → Z, (x, y) ↦ z_x,y) | z_x,y ∈ Z for each x ∈ X and y ∈ Y}

  (X × Y → Z, (x, y) ↦ z_x,y) = (X × Y → Z, (x, y) ↦ z'_x,y)  :⇔  ∀ x ∈ X, y ∈ Y : z_x,y = z'_x,y  (z_x,y ∈ Z for each x ∈ X and y ∈ Y, z'_x,y ∈ Z for each x ∈ X and y ∈ Y)

X × Y → Z =: 𝓞𝓹(X, Y, Z) via
f = (X × Y → Z, (x, y) ↦ f(x, y))

  Well-definedness.  No proof.

We write “let ∗ : X × Y → Z be an operation” for “let ∗ ∈ 𝓞𝓹(X, Y, Z).”

We write “∗ :  X × Y → Z, (x, y) ↦ z_x,y” for “∗ := (X × Y → Z, (x, y) ↦ z_x,y).”

References.

* https://proofwiki.org/wiki/Definition:Operation/Binary_Operation"
`;

exports[`render hlm library: 1.5.2 Essentials/Operations/value 1`] = `
"Definition 1.5.2.  Let X, Y, Z be sets, ∗ : X × Y → Z be an operation, x ∈ X, y ∈ Y. We define

  x ∗ y

by:

  x (X × Y → Z, (a, b) ↦ c_a,b) y := c_x,y  (c_a,b ∈ Z for each a ∈ X and b ∈ Y)
   = ∗(x, y)

Equality.  No proof."
`;

exports[`render hlm library: 1.5.3 Essentials/Operations/Inner%20operations 1`] = `
"Definition 1.5.3 (Inner operations).  Let X be a set. We define:

  𝓞𝓹(X) := 𝓞𝓹(X, X, X)

We write “let ∗ : X × X → X be an operation on X” for “let ∗ ∈ 𝓞𝓹(X).”

References.

* https://en.wikipedia.org/wiki/Binary_operation
* https://mathworld.wolfram.com/BinaryOperation.html
* https://proofwiki.org/wiki/Definition:Operation/Binary_Operation"
`;

exports[`render hlm library: 1.5.4 Essentials/Operations/associative 1`] = `
"Definition 1.5.4.  Let X be a set, ∗ : X × X → X be an operation on X. We define:

  ∗ is associative  :⇔  ∀ x, y, z ∈ X : (x ∗ y) ∗ z = x ∗ (y ∗ z)

References.

* https://en.wikipedia.org/wiki/Associative_property
* https://mathworld.wolfram.com/Associative.html
* https://proofwiki.org/wiki/Definition:Associative_Operation
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#associative"
`;

exports[`render hlm library: 1.5.5 Essentials/Operations/commutative 1`] = `
"Definition 1.5.5.  Let X, Z be sets, ∗ : X × X → Z be an operation. We define:

  ∗ is commutative  :⇔  ∀ x, y ∈ X : x ∗ y = y ∗ x

References.

* https://en.wikipedia.org/wiki/Commutative_property
* https://mathworld.wolfram.com/Commutative.html
* https://proofwiki.org/wiki/Definition:Commutative/Operation
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#commutative"
`;

exports[`render hlm library: 1.5.6 Essentials/Operations/left%20identity%20element 1`] = `
"Definition 1.5.6.  Let X, Y be sets, ∗ : X × Y → Y be an operation, e ∈ X. We define:

  e is a left identity for ∗  :⇔  ∀ a ∈ Y : e ∗ a = a

References.

* https://en.wikipedia.org/wiki/Identity_element
* https://proofwiki.org/wiki/Definition:Identity_(Abstract_Algebra)/Left_Identity
* https://ncatlab.org/nlab/show/identity+element"
`;

exports[`render hlm library: 1.5.7 Essentials/Operations/right%20identity%20element 1`] = `
"Definition 1.5.7.  Let X, Y be sets, ∗ : X × Y → X be an operation, e ∈ Y. We define:

  e is a right identity for ∗  :⇔  ∀ a ∈ X : a ∗ e = a

References.

* https://en.wikipedia.org/wiki/Identity_element
* https://proofwiki.org/wiki/Definition:Identity_(Abstract_Algebra)/Right_Identity
* https://ncatlab.org/nlab/show/identity+element"
`;

exports[`render hlm library: 1.5.8 Essentials/Operations/identity%20element 1`] = `
"Definition 1.5.8.  Let X be a set, ∗ : X × X → X be an operation on X, e ∈ X. We define:

  e is an identity for ∗  :⇔  e is a left identity for ∗ and e is a right identity for ∗
    ⇔  ∀ a ∈ X : a ∗ e = e ∗ a = a

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Identity_element
* https://proofwiki.org/wiki/Definition:Identity_(Abstract_Algebra)/Two-Sided_Identity
* https://ncatlab.org/nlab/show/identity+element"
`;

exports[`render hlm library: 1.5.9 Essentials/Operations/left%20absorbing%20element 1`] = `
"Definition 1.5.9.  Let X, Y be sets, ∗ : X × Y → X be an operation, z ∈ X. We define:

  z is a left absorbing element for ∗  :⇔  ∀ a ∈ Y : z ∗ a = z

References.

* https://en.wikipedia.org/wiki/Absorbing_element
* https://proofwiki.org/wiki/Definition:Left_Zero"
`;

exports[`render hlm library: 1.5.10 Essentials/Operations/right%20absorbing%20element 1`] = `
"Definition 1.5.10.  Let X, Y be sets, ∗ : X × Y → Y be an operation, z ∈ Y. We define:

  z is a right absorbing element for ∗  :⇔  ∀ a ∈ X : a ∗ z = z

References.

* https://en.wikipedia.org/wiki/Absorbing_element
* https://proofwiki.org/wiki/Definition:Right_Zero"
`;

exports[`render hlm library: 1.5.11 Essentials/Operations/absorbing%20element 1`] = `
"Definition 1.5.11.  Let X be a set, ∗ : X × X → X be an operation on X, z ∈ X. We define:

  z is an absorbing element for ∗  :⇔  z is a left absorbing element for ∗ and z is a right absorbing element for ∗
    ⇔  ∀ a ∈ X : a ∗ z = z ∗ a = z

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Absorbing_element
* https://proofwiki.org/wiki/Definition:Zero_Element#Zero"
`;

exports[`render hlm library: 1.5.12 Essentials/Operations/left-distributive 1`] = `
"Definition 1.5.12.  Let X, Y be sets, ∗ : X × Y → Y be an operation, ⋆ : Y × Y → Y be an operation on Y. We define:

  ∗ is left-distributive over ⋆  :⇔  ∀ x ∈ X, y, z ∈ Y : x ∗ (y ⋆ z) = (x ∗ y) ⋆ (x ∗ z)

References.

* https://en.wikipedia.org/wiki/Distributive_property
* https://mathworld.wolfram.com/Distributive.html
* https://proofwiki.org/wiki/Definition:Distributive_Operation/Left
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#left_distributive"
`;

exports[`render hlm library: 1.5.13 Essentials/Operations/right-distributive 1`] = `
"Definition 1.5.13.  Let X, Y be sets, ∗ : Y × X → Y be an operation, ⋆ : Y × Y → Y be an operation on Y. We define:

  ∗ is right-distributive over ⋆  :⇔  ∀ x ∈ X, y, z ∈ Y : (y ⋆ z) ∗ x = (y ∗ x) ⋆ (z ∗ x)

References.

* https://en.wikipedia.org/wiki/Distributive_property
* https://mathworld.wolfram.com/Distributive.html
* https://proofwiki.org/wiki/Definition:Distributive_Operation/Right
* https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#right_distributive"
`;

exports[`render hlm library: 1.5.14 Essentials/Operations/distributive 1`] = `
"Definition 1.5.14.  Let X be a set, ∗, ⋆ : X × X → X be operations on X. We define:

  ∗ is distributive over ⋆  :⇔  ∗ is left-distributive over ⋆ and ∗ is right-distributive over ⋆

References.

* https://en.wikipedia.org/wiki/Distributive_property
* https://mathworld.wolfram.com/Distributive.html
* https://proofwiki.org/wiki/Definition:Distributive_Operation
* https://ncatlab.org/nlab/show/distributive+law"
`;

exports[`render hlm library: 1.5.15 Essentials/Operations/left%20operation%20restriction 1`] = `
"Definition 1.5.15.  Let X, Y be sets, A ⊆ Y, ∗ : X × Y → Y be an operation such that ∀ x ∈ X, y ∈ A : x ∗ y ∈ A. We define:

  ∗∣_(X×A) := ∗∣_(X×A)^A"
`;

exports[`render hlm library: 1.5.16 Essentials/Operations/right%20operation%20restriction 1`] = `
"Definition 1.5.16.  Let X, Y be sets, A ⊆ X, ∗ : X × Y → X be an operation such that ∀ x ∈ A, y ∈ Y : x ∗ y ∈ A. We define:

  ∗∣_(A×Y) := ∗∣_(A×Y)^A"
`;

exports[`render hlm library: 1.5.17 Essentials/Operations/inner%20operation%20restriction 1`] = `
"Definition 1.5.17.  Let X be a set, A ⊆ X, ∗ : X × X → X be an operation on X such that ∀ x, y ∈ A : x ∗ y ∈ A. We define:

  ∗∣_A := ∗∣_(A×A)^A

References.

* https://proofwiki.org/wiki/Definition:Restriction/Operation"
`;

exports[`render hlm library: 1.5.18.1 Essentials/Operations/Iterated%20operations/Iterated%20operations 1`] = `
"Definition 1.5.18.1.  Let X be a set. We define:

  𝓑𝓲𝓰𝓞𝓹(X) :=: {[e ∗ ⋅⋅⋅] | ∗ : X × X → X is an operation on X, e ∈ X such that (X, ∗, e) forms a commutative monoid}

  [e ∗ ⋅⋅⋅] = [f ⋆ ⋅⋅⋅]  :⇔  ∗ = ⋆ and e = f  (∗ : X × X → X is an operation on X, e ∈ X, ⋆ : X × X → X is an operation on X, f ∈ X with suitable conditions)

We write “let ⨂ be an iterated operation on X” for “let ⨂ ∈ 𝓑𝓲𝓰𝓞𝓹(X).”

References.

* https://en.wikipedia.org/wiki/Iterated_binary_operation
* https://proofwiki.org/wiki/Definition:Iterated_Binary_Operation"
`;

exports[`render hlm library: 1.5.18.2 Essentials/Operations/Iterated%20operations/identity%20element 1`] = `
"Definition 1.5.18.2.  Let X be a set, ⨂ be an iterated operation on X. We define

  e_⨂

by:

  e_[e∗⋅⋅⋅] := e  (∗ : X × X → X is an operation on X, e ∈ X such that (X, ∗, e) forms a commutative monoid)"
`;

exports[`render hlm library: 1.5.18.3 Essentials/Operations/Iterated%20operations/operation 1`] = `
"Definition 1.5.18.3.  Let X be a set, ⨂ be an iterated operation on X, x, y ∈ X. We define:

  x ⨂ y := x ∗ y if ⨂ = [e ∗ ⋅⋅⋅] (∗ : X × X → X is an operation on X, e ∈ X such that (X, ∗, e) forms a commutative monoid)"
`;

exports[`render hlm library: 1.5.18.4 Essentials/Operations/Iterated%20operations/indexed%20by%20natural%20number 1`] = `
"Definition 1.5.18.4.  Let X be a set, ⨂ be an iterated operation on X, n ∈ ℕ, let a_i ∈ X for each i ∈ ℕ_(<n). We define

  ⨂_(i < n) a_i

by:

  ⨂_(i < 0) a_i := e_⨂
  ⨂_(i < m+1) a_i := (⨂_(j < m) a_j) ⨂ a_m  (m ∈ ℕ)"
`;

exports[`render hlm library: 1.5.18.5 Essentials/Operations/Iterated%20operations/Iterated%20operation%20indexed%20by%20natural%20number%20is%20distributive 1`] = `
"Proposition 1.5.18.5.  Let X be a set, ⨂ be an iterated operation on X, n ∈ ℕ, let a_i, b_i ∈ X for each i ∈ ℕ_(<n). Then:

  ⨂_(i < n) (a_i ⨂ b_i) = (⨂_(i < n) a_i) ⨂ (⨂_(i < n) b_i)

No proof."
`;

exports[`render hlm library: 1.5.18.6 Essentials/Operations/Iterated%20operations/indexed%20by%20integer 1`] = `
"Definition 1.5.18.6.  Let X be a set, ⨂ be an iterated operation on X, j, k ∈ ℤ, let a_i ∈ X for each i ∈ {j, ..., k}. We define:

  ⨂_(i = j)^k a_i := ⨂_(i < k−j+1) a_(i+j)"
`;

exports[`render hlm library: 1.5.18.7 Essentials/Operations/Iterated%20operations/indexed%20by%20finite%20set 1`] = `
"Definition 1.5.18.7.  Let X be a set, ⨂ be an iterated operation on X, I be a finite set, let a_i ∈ X for each i ∈ I. For x ∈ X, we define:

  ⨂_(i ∈ I) a_i = x  :⇔  ∀ n ∈ ℕ, f : ℕ_(<n) ↔ I : ⨂_(j < n) a_(f(j)) = x
    ⇔  ∃ n ∈ ℕ, f : ℕ_(<n) ↔ I : ⨂_(j < n) a_(f(j)) = x

Equivalence.  No proof.

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.5.18.8 Essentials/Operations/Iterated%20operations/Operation%20on%20empty%20set 1`] = `
"Proposition 1.5.18.8.  Let X be a set, ⨂ be an iterated operation on X, let a_i ∈ X for each i ∈ ∅. Then:

  ⨂_(i ∈ ∅) a_i = e_⨂

No proof."
`;

exports[`render hlm library: 1.5.18.9 Essentials/Operations/Iterated%20operations/Natural%20number%20equalities 1`] = `
"Proposition 1.5.18.9.  Let X be a set, ⨂ be an iterated operation on X, n ∈ ℕ, let a_i ∈ X for each i ∈ ℕ_(<n). Then:

  ⨂_(i < n) a_i = ⨂_(i = 0)^(n−1) a_i = ⨂_(i ∈ ℕ_(<n)) a_i

No proof."
`;

exports[`render hlm library: 1.5.18.10 Essentials/Operations/Iterated%20operations/Integer%20equalities 1`] = `
"Proposition 1.5.18.10.  Let X be a set, ⨂ be an iterated operation on X, j, k ∈ ℤ, let a_i ∈ X for each i ∈ {j, ..., k}. Then:

  ⨂_(i = j)^k a_i = ⨂_(i ∈ {j,...,k}) a_i

No proof."
`;

exports[`render hlm library: 1.5.18.11 Essentials/Operations/Iterated%20operations/indexed%20by%20set%20with%20finite%20support 1`] = `
"Definition 1.5.18.11.  Let X be a set, ⨂ be an iterated operation on X, I be a set, let a_i ∈ X for each i ∈ I, let J := {i ∈ I : a_i ≠ e_⨂}, assume J is finite. We define:

  ⨂_(i ∈ I) a_i := ⨂_(j ∈ J) a_j"
`;

exports[`render hlm library: 1.5.18.12 Essentials/Operations/Iterated%20operations/indexed%20by%20finite%20multiset 1`] = `
"Definition 1.5.18.12.  Let X be a set, ⨂ be an iterated operation on X, S be a set, 𝑰 be a/an S-multiset such that 𝑰 is finite, let a_i ∈ X for each i ∈ 𝑰. We define:

  ⨂_(i ∈ 𝑰) a_i := ⨂_((t,n) ∈ Elems(𝑰)) a_t
   = ⨂_(j ∈ Set(𝑰)) (⨂_(k < mult_𝑰(j)) a_j)
   = ⨂_(j ∈ S) (⨂_(k < mult_𝑰(j)) a_j)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.1 Essentials/Sequences/Tuples 1`] = `
"Definition 1.6.1.  Let S be a set, α be an ordinal number. We define:

  S^α :=: {(a_k)_(k < α) | a_k ∈ S for each k ∈ 𝓞𝓻𝓭_(<α)}

  (a_k)_(k < α) = (b_k)_(k < α)  :⇔  ∀ k ∈ 𝓞𝓻𝓭_(<α) : a_k = b_k  (a_k ∈ S for each k ∈ 𝓞𝓻𝓭_(<α), b_k ∈ S for each k ∈ 𝓞𝓻𝓭_(<α))

We write “let 𝐚 be a/an α-tuple on S” for “let 𝐚 ∈ S^α.”

Remarks.

This is a slightly generalized notion of \\"tuple\\" where the length \`α\` can be an arbitrary ordinal number. If \`α\` is a natural number, it matches the common definition.

We could define tuples simply as functions, but a custom construction has several advantages, including the ability to easily destruct a tuple into its elements, and the ability to omit \`S\` from the constructor.

In this definition, the codomain is a fixed set \`S\`. If each item is an element of a different set, a generalized Cartesian product \`$../Sets/\\"Generalized operators\\"/\\"Generalized cartesian product\\"\` can be used instead.

References.

* https://en.wikipedia.org/wiki/Tuple
* https://mathworld.wolfram.com/n-Tuple.html
* https://proofwiki.org/wiki/Definition:Ordered_Tuple/On_Set
* https://ncatlab.org/nlab/show/tuple
* https://coq.inria.fr/library/Coq.Vectors.VectorDef.html
* https://leanprover-community.github.io/mathlib_docs/core/data/vector.html#vector (finite) or https://leanprover-community.github.io/mathlib_docs/data/seq/seq.html#seq (infinite)"
`;

exports[`render hlm library: 1.6.2 Essentials/Sequences/tuple 1`] = `
"Definition 1.6.2 (Tuple).

We write:

\`$tuple(S = S, items = [a_0, a_1, \\"...\\", \\"a_n-1\\"])\` := \`$Tuples(S = S, α = n).sequence(_1 = {#(k: %Element($../Numbers/Ordinal/Subsets/\\"Segment (less)\\"(α = n))), {a = a_k}})\`"
`;

exports[`render hlm library: 1.6.3 Essentials/Sequences/tuple%20from%20function 1`] = `
"Definition 1.6.3.  Let S be a set, α be an ordinal number, f : 𝓞𝓻𝓭_(<α) → S be a function. We define:

  tpl(f) := (f(k))_(k < α)

Remarks.

This definition produces a tuple from a function."
`;

exports[`render hlm library: 1.6.4 Essentials/Sequences/Finite%20sequences 1`] = `
"Definition 1.6.4.  Let S be a set. We define:

  S^∗ :=: {(𝐚)_(S^n) | n ∈ ℕ, 𝐚 is a/an n-tuple on S}

  (𝐚)_(S^m) = (𝐛)_(S^n)  :⇔  m = n and 𝐚 = (b_j)_(j < m) if 𝐛 = (b_k)_(k < n) (b_k ∈ S for each k ∈ 𝓞𝓻𝓭_(<n))  (m ∈ ℕ, 𝐚 is a/an m-tuple on S, n ∈ ℕ, 𝐛 is a/an n-tuple on S)

We write “let 𝒂 be a finite sequence on S” for “let 𝒂 ∈ S^∗.”

Remarks.

Finite sequences could alternatively be defined inductively (i.e. as lists). However, since we also need a definition for tuples of a given length, we base our definition on that.

References.

* https://en.wikipedia.org/wiki/Sequence
* https://mathworld.wolfram.com/Sequence.html
* https://proofwiki.org/wiki/Definition:Finite_Sequence
* https://ncatlab.org/nlab/show/free+monoid
* https://coq.inria.fr/library/Coq.Init.Datatypes.html#list
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#list"
`;

exports[`render hlm library: 1.6.5 Essentials/Sequences/finite%20sequence%20length 1`] = `
"Definition 1.6.5.  Let S be a set, 𝒂 be a finite sequence on S. We define

  |𝒂|

by:

  |(𝐚)_(S^n)| := n  (n ∈ ℕ, 𝐚 is a/an n-tuple on S)

References.

* https://coq.inria.fr/library/Coq.Init.Datatypes.html#length
* https://leanprover-community.github.io/mathlib_docs/core/init/data/list/basic.html#list.length"
`;

exports[`render hlm library: 1.6.6 Essentials/Sequences/Infinite%20sequences 1`] = `
"Definition 1.6.6.  Let S be a set. We define:

  S^ω :=: {(a_n)_(n ∈ ℕ) | a_n ∈ S for each n ∈ ℕ}

  (a_n)_(n ∈ ℕ) = (b_n)_(n ∈ ℕ)  :⇔  ∀ n ∈ ℕ : a_n = b_n  (a_n ∈ S for each n ∈ ℕ, b_n ∈ S for each n ∈ ℕ)

S^ω =: S^ω via
(a_j)_(j < ω) = (a_k)_(k ∈ ℕ)

  Well-definedness.  No proof.

We write “let 𝐚 be a sequence on S” for “let 𝐚 ∈ S^ω.”

Remarks.

We omit the word \\"infinite\\" because infinite sequences are used much more frequently than finite ones.

We could define infinite sequences simply as functions, but a custom construction has several advantages, including the ability to easily destruct a sequence into its elements, and the ability to omit \`S\` from the constructor.

Even though the more general definition \`$Tuples\` covers infinite sequences as a special case, we use this additional definition (with an appropriate embedding) to make the constructor look nicer.

References.

* https://en.wikipedia.org/wiki/Sequence
* https://mathworld.wolfram.com/Sequence.html
* https://proofwiki.org/wiki/Definition:Sequence/Infinite_Sequence
* https://ncatlab.org/nlab/show/sequence
* https://coq.inria.fr/library/Coq.Lists.Streams.html#Stream
* https://leanprover-community.github.io/mathlib_docs/core/data/stream.html#stream"
`;

exports[`render hlm library: 1.6.7 Essentials/Sequences/sequence%20from%20function 1`] = `
"Definition 1.6.7.  Let S be a set, f : ℕ → S be a function. We define:

  seq(f) := (f(n))_(n ∈ ℕ)

Remarks.

This definition produces an infinite sequence from a function."
`;

exports[`render hlm library: 1.6.8 Essentials/Sequences/Ordinal-indexed%20sequences 1`] = `
"Definition 1.6.8.  Let S be a set. We define:

  S^⋆ :=: {(𝐚)_(S^α) | α is an ordinal number, 𝐚 is a/an α-tuple on S}

  (𝐚)_(S^α) = (𝐛)_(S^β)  :⇔  α = β and 𝐚 = (b_j)_(j < α) if 𝐛 = (b_k)_(k < β) (b_k ∈ S for each k ∈ 𝓞𝓻𝓭_(<β))  (α is an ordinal number, 𝐚 is a/an α-tuple on S, β is an ordinal number, 𝐛 is a/an β-tuple on S)

S^∗ ⊆: S^⋆ via
(𝐚)_(S^n) = (𝐚)_(S^n)

  Well-definedness.  No proof.

We write “let 𝒂 be an ordinal-indexed sequence on S” for “let 𝒂 ∈ S^⋆.”

References.

* https://en.wikipedia.org/wiki/Ordinal_number#Transfinite_sequence (but we use arbitrary ordinals, not only limit ordinals)"
`;

exports[`render hlm library: 1.6.9 Essentials/Sequences/ordinal-indexed%20sequence%20length 1`] = `
"Definition 1.6.9.  Let S be a set, 𝒂 be an ordinal-indexed sequence on S. We define

  |𝒂|

by:

  |(𝐚)_(S^α)| := α  (α is an ordinal number, 𝐚 is a/an α-tuple on S)"
`;

exports[`render hlm library: 1.6.10 Essentials/Sequences/finite 1`] = `
"Definition 1.6.10.  Let S be a set, 𝒂 be an ordinal-indexed sequence on S. We define:

  𝒂 is finite  :⇔  |𝒂| is finite"
`;

exports[`render hlm library: 1.6.11 Essentials/Sequences/starts%20with 1`] = `
"Definition 1.6.11.  Let S be a set, 𝐚 be a sequence on S, n ∈ ℕ, 𝐛 be a/an n-tuple on S. We define

  𝐚 starts with 𝐛

by:

  (a_k)_(k ∈ ℕ) starts with (b_k)_(k < n)  :⇔  ∀ k ∈ ℕ_(<n) : a_k = b_k  (a_k ∈ S for each k ∈ ℕ, b_k ∈ S for each k ∈ 𝓞𝓻𝓭_(<n))"
`;

exports[`render hlm library: 1.6.12 Essentials/Sequences/starts%20with%20finite%20sequence 1`] = `
"Definition 1.6.12.  Let S be a set, 𝐚 be a sequence on S, 𝒃 be a finite sequence on S. We define

  𝐚 starts with 𝒃

by:

  𝐚 starts with (𝐛)_(S^n)  :⇔  𝐚 starts with 𝐛  (n ∈ ℕ, 𝐛 is a/an n-tuple on S)"
`;

exports[`render hlm library: 1.6.13 Essentials/Sequences/index%20in%20well-ordered%20set 1`] = `
"Definition 1.6.13.  Let S be a set, ⪯ be a well-order on S, α := [S, ⪯], s ∈ S, T := {t ∈ S ∖ {s} : t ⪯ s}. We define:

  idx_⪯(s) := [T, ⪯∣_T]

Remarks.

This is a helper definition which yields the index of \`s\` within the sequence defined by the given well-order. This index is an ordinal number which is defined using the set of all elements less than \`s\`."
`;

exports[`render hlm library: 1.6.14 Essentials/Sequences/indexed%20element%20in%20well-ordered%20set 1`] = `
"Definition 1.6.14.  Let S be a set, ⪯ be a well-order on S, α := [S, ⪯], β ∈ 𝓞𝓻𝓭_(<α). For s ∈ S, we define:

  S_⪯[β] = s  :⇔  idx_⪯(s) = β

Well-definedness.  No proof.

Remarks.

This is just the inverse of the previous definition."
`;

exports[`render hlm library: 1.6.15 Essentials/Sequences/sequence%20from%20well-ordered%20set 1`] = `
"Definition 1.6.15.  Let S be a set, ⪯ be a well-order on S, α := [S, ⪯]. We define:

  seq_⪯(S) := ((S_⪯[β])_(β < α))_(S^α)

Remarks.

This definition produces an ordinal-indexed sequence from a well-ordered set.

References.

* https://en.wikipedia.org/wiki/Well-order#Ordinal_numbers"
`;

exports[`render hlm library: 1.7.1.1 Essentials/Numbers/Natural/Natural%20numbers 1`] = `
"Definition 1.7.1.1.  We define:

  ℕ :=: {(0), (n+1) | n ∈ ℕ}

  (m+1) = (n+1)  :⇔  m = n  (m ∈ ℕ, n ∈ ℕ)

Remarks.

The set of natural numbers is defined as a construction with two constructors, which, in this case, exactly matches the corresponding definition of an [inductive data type](https://en.wikipedia.org/wiki/Recursive_data_type). We merely use a custom notation for the \\"successor\\" constructor, but we could just as well write \\"S(\`n\`)\\". The notation is justified by \`$\\"Addition of one yields successor\\"\`.

In this library, the natural numbers start at 0, which is known to be far more convenient than starting at 1.

References.

* https://en.wikipedia.org/wiki/Natural_number
* https://mathworld.wolfram.com/NonnegativeInteger.html
* https://proofwiki.org/wiki/Definition:Natural_Numbers
* https://ncatlab.org/nlab/show/natural+number
* https://coq.inria.fr/library/Coq.Init.Nat.html
* https://coq.inria.fr/library/Coq.NArith.BinNat.html
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#nat
* http://oeis.org/A001477"
`;

exports[`render hlm library: 1.7.1.2 Essentials/Numbers/Natural/number 1`] = `
"Definition 1.7.1.2 (Positional notation).

We write:
* 0 := \`$\\"Natural numbers\\".zero\`
* 1 := \`$\\"Natural numbers\\".successor(n = $number(value = 0))\`
* 2 := \`$\\"Natural numbers\\".successor(n = $number(value = 1))\`
* 3 := \`$\\"Natural numbers\\".successor(n = $number(value = 2))\`
* ...

Remarks.

Positional notation is implemented as a macro, i.e. using additional code that is injected into the proof checker. Therefore, no definition is given here.

References.

* https://en.wikipedia.org/wiki/Positional_notation
* https://coq.inria.fr/library/Coq.Init.Nat.html#of_uint_acc"
`;

exports[`render hlm library: 1.7.1.3 Essentials/Numbers/Natural/sum 1`] = `
"Definition 1.7.1.3.  Let m, n ∈ ℕ. We define

  m + n

by:

  m + (0) := m
  m + (x+1) := ((m + x)+1)  (x ∈ ℕ)

Remarks.

Such inductive definitions are possible due to the definition of natural numbers as a construction (i.e. inductive data type). Note that some of the \\"+\\" symbols appearing in this definition are part of the notation of the successor constructor.

References.

* https://en.wikipedia.org/wiki/Natural_number#Addition
* https://proofwiki.org/wiki/Definition:Addition/Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#add
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.add
* https://leanprover-community.github.io/mathlib_docs/core/init/core.html#nat.add"
`;

exports[`render hlm library: 1.7.1.4 Essentials/Numbers/Natural/Addition%20of%20one%20yields%20successor 1`] = `
"Proposition 1.7.1.4.  Let n ∈ ℕ. Then:

  (n+1) = n + 1

No proof.

Remarks.

This proposition justifies the notation for the successor constructor.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.add_one"
`;

exports[`render hlm library: 1.7.1.5 Essentials/Numbers/Natural/Sum%20is%20associative 1`] = `
"Proposition 1.7.1.5.

  + is associative

No proof.

References.

* https://en.wikipedia.org/wiki/Proofs_involving_the_addition_of_natural_numbers#Proof_of_associativity
* https://proofwiki.org/wiki/Natural_Number_Addition_is_Associative
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.add_assoc"
`;

exports[`render hlm library: 1.7.1.6 Essentials/Numbers/Natural/Left-addition%20of%20zero%20is%20neutral 1`] = `
"Lemma 1.7.1.6.  Let n ∈ ℕ. Then:

  (0) + n = n

Proof.  By induction on n.

* (0) = (0): Trivial.
* Let x ∈ ℕ. Then (((0) + x)+1) = (x+1):
  We have (x+1) = (x+1).
   ⇒^1.7.1.6 (((0) + x)+1) = (x+1)

References.

* https://en.wikipedia.org/wiki/Proofs_involving_the_addition_of_natural_numbers#Proof_of_identity_element
* https://proofwiki.org/wiki/Identity_Element_of_Natural_Number_Addition_is_Zero
* https://proofwiki.org/wiki/Natural_Number_Addition_Commutes_with_Zero
* https://coq.inria.fr/library/Coq.Arith.PeanoNat.html#Nat.add_0_l
* https://coq.inria.fr/library/Coq.NArith.BinNat.html#N.add_0_l
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.zero_add"
`;

exports[`render hlm library: 1.7.1.7 Essentials/Numbers/Natural/Successor%20can%20be%20pulled%20over%20addition 1`] = `
"Lemma 1.7.1.7.  Let m, n ∈ ℕ. Then:

  (m+1) + n = ((m + n)+1)

Proof.  By induction on n.

* (m+1) = (m+1): Trivial.
* Let x ∈ ℕ. Then (((m+1) + x)+1) = (((m + x)+1)+1):
  We have (((m + x)+1)+1) = (((m + x)+1)+1).
   ⇒^1.7.1.7 (((m+1) + x)+1) = (((m + x)+1)+1)

References.

* https://coq.inria.fr/library/Coq.Arith.PeanoNat.html#Nat.add_succ_l
* https://coq.inria.fr/library/Coq.NArith.BinNat.html#N.add_succ_l
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.succ_add"
`;

exports[`render hlm library: 1.7.1.8 Essentials/Numbers/Natural/Sum%20is%20commutative 1`] = `
"Proposition 1.7.1.8.

  + is commutative

No proof.

References.

* https://en.wikipedia.org/wiki/Proofs_involving_the_addition_of_natural_numbers#Proof_of_commutativity
* https://proofwiki.org/wiki/Natural_Number_Addition_is_Commutative
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.add_comm"
`;

exports[`render hlm library: 1.7.1.9 Essentials/Numbers/Natural/less%20or%20equal 1`] = `
"Definition 1.7.1.9.  Let m, n ∈ ℕ. We define:

  m ≤ n  :⇔  ∃ x ∈ ℕ : m + x = n
    ⇔  {true if m = 0, y ≤ n and y ≠ n if m = y + 1 (y ∈ ℕ)
    ⇔  m = n or {false if n = 0, m ≤ z if n = z + 1 (z ∈ ℕ)

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Natural_number#Order
* https://proofwiki.org/wiki/Definition:Ordering_on_Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#leb
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.leb
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.le"
`;

exports[`render hlm library: 1.7.1.10 Essentials/Numbers/Natural/less 1`] = `
"Definition 1.7.1.10.  Let m, n ∈ ℕ. We define:

  m < n  :⇔  m ≱ n
    ⇔  m + 1 ≤ n
    ⇔  m ≤ n and m ≠ n
    ⇔  ∃ x ∈ ℕ_+ : m + x = n
    ⇔  m ≠ n and {true if m = 0, y < n if m = y + 1 (y ∈ ℕ)
    ⇔  {false if n = 0, m < z or m = z if n = z + 1 (z ∈ ℕ)

Equivalence.  No proof.

References.

* https://coq.inria.fr/library/Coq.Init.Nat.html#ltb
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.ltb
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.lt
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.lt_of_le_and_ne"
`;

exports[`render hlm library: 1.7.1.11 Essentials/Numbers/Natural/Less%20or%20equal%20is%20a%20total%20order 1`] = `
"Proposition 1.7.1.11.

  ≤ is a total order

No proof.

References.

* https://en.wikipedia.org/wiki/Natural_number#Order
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.linear_order"
`;

exports[`render hlm library: 1.7.1.12 Essentials/Numbers/Natural/Less%20and%20less%20or%20equal%20combine%20to%20less 1`] = `
"Proposition 1.7.1.12.  Let a, b, c ∈ ℕ such that a < b ≤ c. Then:

  a < c

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.lt_of_lt_of_le"
`;

exports[`render hlm library: 1.7.1.13 Essentials/Numbers/Natural/Less%20or%20equal%20and%20less%20combine%20to%20less 1`] = `
"Proposition 1.7.1.13.  Let a, b, c ∈ ℕ such that a ≤ b < c. Then:

  a < c

No proof."
`;

exports[`render hlm library: 1.7.1.14 Essentials/Numbers/Natural/Zero%20is%20the%20smallest%20number 1`] = `
"Proposition 1.7.1.14.  Let n ∈ ℕ. Then:

  n ≥ 0

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.zero_le"
`;

exports[`render hlm library: 1.7.1.15 Essentials/Numbers/Natural/Zero%20is%20the%20only%20number%20less%20than%20or%20equal%20to%20zero 1`] = `
"Proposition 1.7.1.15.  Let n ∈ ℕ such that n ≤ 0. Then:

  n = 0

No proof."
`;

exports[`render hlm library: 1.7.1.16 Essentials/Numbers/Natural/Successor%20is%20always%20greater 1`] = `
"Proposition 1.7.1.16.  Let n ∈ ℕ. Then:

  n + 1 > n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.lt_succ_self"
`;

exports[`render hlm library: 1.7.1.17.1 Essentials/Numbers/Natural/Subsets/Segment%20(less) 1`] = `
"Definition 1.7.1.17.1.  Let n ∈ ℕ. We define:

  ℕ_(<n) := {m ∈ ℕ : m < n}

References.

* https://mathworld.wolfram.com/InitialSegment.html
* https://proofwiki.org/wiki/Definition:Initial_Segment_of_Natural_Numbers/Zero-Based
* https://leanprover-community.github.io/mathlib_docs/core/init/data/fin/basic.html#fin"
`;

exports[`render hlm library: 1.7.1.17.2 Essentials/Numbers/Natural/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.7.1.17.2.  Let n ∈ ℕ. We define:

  ℕ_(≤n) := {m ∈ ℕ : m ≤ n}
   = ℕ_(<(n+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.7.1.17.3 Essentials/Numbers/Natural/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.7.1.17.3.  Let n ∈ ℕ. We define:

  ℕ_(≥n) := {m ∈ ℕ : m ≥ n}
   = ℕ ∖ ℕ_(<n)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.1.17.4 Essentials/Numbers/Natural/Subsets/Segment%20(greater) 1`] = `
"Definition 1.7.1.17.4.  Let n ∈ ℕ. We define:

  ℕ_(>n) := {m ∈ ℕ : m > n}
   = ℕ ∖ ℕ_(≤n)
   = ℕ_(≥(n+1))
   = ℕ_(≥n) ∖ {n}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.1.17.5 Essentials/Numbers/Natural/Subsets/Positive%20numbers 1`] = `
"Definition 1.7.1.17.5.  We define:

  ℕ_+ := ℕ_(>0)
   = {n ∈ ℕ : n > 0}
   = {n ∈ ℕ : n ≠ 0}
   = ℕ ∖ {0}
   = ℕ_(≥1)
   = {n ∈ ℕ : n ≥ 1}
   = {n ∈ ℕ : ∃ m ∈ ℕ : m + 1 = n}
   = {n ∈ ℕ : ∃! m ∈ ℕ : m + 1 = n}
   = {m + 1 : m ∈ ℕ}

Equality.  No proof.

References.

* https://proofwiki.org/wiki/Axiom:Axiomatization_of_1-Based_Natural_Numbers
* https://leanprover-community.github.io/mathlib_docs/data/pnat/basic.html#pnat
* http://oeis.org/A000027"
`;

exports[`render hlm library: 1.7.1.17.6 Essentials/Numbers/Natural/Subsets/Exclusive%20initial%20segment%20is%20subset%20of%20inclusive%20segment 1`] = `
"Proposition 1.7.1.17.6.  Let n ∈ ℕ. Then:

  ℕ_(<n) ⊆ ℕ_(≤n)

No proof."
`;

exports[`render hlm library: 1.7.1.17.7 Essentials/Numbers/Natural/Subsets/Initial%20segments%20are%20finite 1`] = `
"Proposition 1.7.1.17.7.  Let n ∈ ℕ. Then:

  ℕ_(<n) is finite

No proof."
`;

exports[`render hlm library: 1.7.1.17.8 Essentials/Numbers/Natural/Subsets/Binary%20digits 1`] = `
"Definition 1.7.1.17.8.  We define:

  Bit := ℕ_(≤1)
   = {0, 1}

Equality.  No proof.

Remarks.

There are, of course, many equivalent definitions of binary digits. The simplest definition would be a construction with two constructors. However, we also want the sets to be embedded in the natural numbers, and (currently) this requires everything to be mapped to a single constructor of the target set. So we simply define binary digits as a subset of the natural numbers.

In some cases, the set \`$../../../Sets/\\"Truth values\\"\` of truth values may be more convenient to use.

References.

* https://en.wikipedia.org/wiki/Bit
* https://mathworld.wolfram.com/Bit.html"
`;

exports[`render hlm library: 1.7.1.18 Essentials/Numbers/Natural/Finiteness%20criterion%20lemma 1`] = `
"Lemma 1.7.1.18.  Let M ⊆ ℕ, k ∈ ℕ, f : ℕ_(≤k) ↔ M be a bijection. Then:

  ∃ m ∈ M : ∀ n ∈ M : n ≤ m

Proof.  By induction on k.

* Assume k = 0. Then ∃ m ∈ M : ∀ n ∈ M : n ≤ m:
  Choose m := f(0).
* Let x ∈ ℕ such that k = x + 1. Then ∃ m ∈ M : ∀ n ∈ M : n ≤ m:
  Let S := ℕ_(≤x).
   ⇒^1.7.1.18 ∃ i ∈ f(S) : ∀ j ∈ f(S) : j ≤ i
  Choose m := {f(k) if f(k) > i, i if f(k) ≤ i.

Remarks.

This lemma is necessary to prove the following theorem. \`k\` and \`f\` do not appear in the result, but they enable a proof via induction on \`k\`."
`;

exports[`render hlm library: 1.7.1.19 Essentials/Numbers/Natural/Finiteness%20criterion 1`] = `
"Proposition 1.7.1.19.  Let M ⊆ ℕ. Then the following are equivalent:

  1. M is finite
  2. M is empty or ∃ m ∈ M : m is a ≤-greatest element of M
  3. M is empty or ∃! m ∈ M : m is a ≤-greatest element of M
  4. ∃ a ∈ ℕ : M ⊆ ℕ_(≤a)
  5. ∃ b ∈ ℕ : M ⊆ ℕ_(<b)

Proof.

1⇒2. Assume M is finite. Then M is empty or ∃ m ∈ M : m is a ≤-greatest element of M:
     def ⇒ ∃ l ∈ ℕ, f : ℕ_(<l) ↔ M
     We have {M is empty if l = 0, ∃ i ∈ M : ∀ j ∈ M : j ≤ i if l = k + 1 (k ∈ ℕ):
       * Assume l = 0. Then M is empty:
         We show that ∄ c ∈ M:
         Let c ∈ M.
         f ∈ (ℕ_(<l) ↔ M) ⇒^def f is bijective
          ⇒^def f is surjective
          ⇒^def ∀ t ∈ M : ∃ s ∈ ℕ_(<0) : f(s) = t
          ⇒ ∃ s ∈ ℕ_(<0) : f(s) = c
         s ∈ ℕ_(<0) ⇒^def s < 0
         1.7.1.14 ⇒ s ≥ 0 ⭍
       * Let k ∈ ℕ such that l = k + 1. Then ∃ i ∈ M : ∀ j ∈ M : j ≤ i:
         1.7.1.18 ⇒ ∃ y ∈ M : ∀ z ∈ M : z ≤ y
2⇒4. Assume M is empty or ∃ m ∈ M : m is a ≤-greatest element of M. Then ∃ a ∈ ℕ : M ⊆ ℕ_(≤a):
     * Assume M is empty.
        ⇒^def M = ∅
       Choose a := 0. We show that M ⊆ ℕ_(≤0):
         1.1.2 ⇒ ∅ ⊆ ℕ_(≤0)
          ⇒^[M = ∅] M ⊆ ℕ_(≤0)
4⇒5. Let a ∈ ℕ such that M ⊆ ℕ_(≤a). Then ∃ b ∈ ℕ : M ⊆ ℕ_(<b):
     M ⊆ ℕ_(≤a) ⇒^def M ⊆ ℕ_(<(a+1))
     Choose b := a + 1.
5⇒1. Let b ∈ ℕ such that M ⊆ ℕ_(<b). Then M is finite:
     1.7.1.17.7 ⇒ ℕ_(<b) is finite
     1.1.5 ⇒ M is finite"
`;

exports[`render hlm library: 1.7.1.20 Essentials/Numbers/Natural/Addition%20of%20a%20fixed%20number%20is%20injective 1`] = `
"Proposition 1.7.1.20.  Let a, b, c ∈ ℕ such that a + c = b + c. Then:

  a = b

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.add_right_cancel"
`;

exports[`render hlm library: 1.7.1.21 Essentials/Numbers/Natural/difference 1`] = `
"Definition 1.7.1.21.  Let n ∈ ℕ, m ∈ ℕ_(≤n). For x ∈ ℕ, we define:

  n − m = x  :⇔  n = x + m

Well-definedness.  No proof.

References.

* https://proofwiki.org/wiki/Definition:Subtraction/Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#sub (truncated subtraction, thus incompatible with integer subtraction)
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.sub (ditto)
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.sub (ditto)
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.sub_le"
`;

exports[`render hlm library: 1.7.1.22 Essentials/Numbers/Natural/product 1`] = `
"Definition 1.7.1.22.  Let m, n ∈ ℕ. We define

  m ⋅ n

by:

  m ⋅ 0 := 0
  m ⋅ (x + 1) := m ⋅ x + m  (x ∈ ℕ)

References.

* https://en.wikipedia.org/wiki/Natural_number#Multiplication
* https://proofwiki.org/wiki/Definition:Multiplication/Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#mul
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.mul
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.mul"
`;

exports[`render hlm library: 1.7.1.23 Essentials/Numbers/Natural/Multiplication%20by%20one%20is%20neutral 1`] = `
"Proposition 1.7.1.23.  Let n ∈ ℕ. Then:

  n ⋅ 1 = n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.mul_one"
`;

exports[`render hlm library: 1.7.1.24 Essentials/Numbers/Natural/Product%20is%20associative 1`] = `
"Proposition 1.7.1.24.

  ⋅ is associative

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.mul_assoc"
`;

exports[`render hlm library: 1.7.1.25 Essentials/Numbers/Natural/Product%20is%20commutative 1`] = `
"Proposition 1.7.1.25.

  ⋅ is commutative

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.mul_comm"
`;

exports[`render hlm library: 1.7.1.26 Essentials/Numbers/Natural/Product%20is%20distributive%20over%20sum 1`] = `
"Proposition 1.7.1.26.

  ⋅ is distributive over +

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.distrib"
`;

exports[`render hlm library: 1.7.1.27 Essentials/Numbers/Natural/Multiplication%20by%20a%20positive%20number%20is%20injective 1`] = `
"Proposition 1.7.1.27.  Let a, b ∈ ℕ, c ∈ ℕ_+ such that a ⋅ c = b ⋅ c. Then:

  a = b

No proof."
`;

exports[`render hlm library: 1.7.1.28 Essentials/Numbers/Natural/divisible 1`] = `
"Definition 1.7.1.28.  Let m ∈ ℕ_+, n ∈ ℕ. We define:

  m ∣ n  :⇔  ∃ x ∈ ℕ : m ⋅ x = n
    ⇔  ∃! x ∈ ℕ : m ⋅ x = n

Equivalence.  No proof.

Remarks.

The constraint that \`m\` is nonzero is not really necessary but added for consistency with the definition of the set of divisors \`$Divisors\`.

References.

* https://en.wikipedia.org/wiki/Divisor
* https://mathworld.wolfram.com/Divisor.html
* https://proofwiki.org/wiki/Definition:Divisor_(Algebra)/Natural_Numbers
* (https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.comm_semiring)"
`;

exports[`render hlm library: 1.7.1.29 Essentials/Numbers/Natural/Divisors 1`] = `
"Definition 1.7.1.29.  Let n ∈ ℕ. We define:

  Div_ℕ(n) := {m ∈ ℕ_+ : m ∣ n}

Remarks.

We specifically exclude 0 from the set of divisors in order to simplify the definition of \`$quotient\`.

References.

* http://oeis.org/A027750"
`;

exports[`render hlm library: 1.7.1.30 Essentials/Numbers/Natural/Divisors%20are%20less%20or%20equal 1`] = `
"Proposition 1.7.1.30.  Let m, n ∈ ℕ_+ such that m ∣ n. Then:

  m ≤ n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.le_of_dvd"
`;

exports[`render hlm library: 1.7.1.31 Essentials/Numbers/Natural/Divisibility%20criterion 1`] = `
"Proposition 1.7.1.31.  Let a ∈ ℕ_+, b ∈ ℕ such that a ∣ b, c ∈ ℕ. Then the following are equivalent:

  1. a ∣ c
  2. a ∣ (b + c)

No proof."
`;

exports[`render hlm library: 1.7.1.32 Essentials/Numbers/Natural/even 1`] = `
"Definition 1.7.1.32.  Let n ∈ ℕ. We define:

  n is even  :⇔  {true if n = 0, x is odd if n = x + 1 (x ∈ ℕ)
    ⇔  2 ∣ n

  n is odd  :⇔  n is not even

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Parity_(mathematics)
* https://mathworld.wolfram.com/EvenNumber.html
* https://coq.inria.fr/library/Coq.Init.Nat.html#even
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.even
* https://leanprover-community.github.io/mathlib_docs/data/nat/parity.html#nat.even
* http://oeis.org/A005843"
`;

exports[`render hlm library: 1.7.1.33 Essentials/Numbers/Natural/quotient 1`] = `
"Definition 1.7.1.33.  Let n ∈ ℕ, m ∈ Div_ℕ(n). For x ∈ ℕ, we define:

  n∕m = x  :⇔  n = x ⋅ m

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Quotient
* https://coq.inria.fr/library/Coq.Init.Nat.html#div (truncated division, thus incompatible with division of rational numbers)
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.div (ditto)
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/div.html#nat.div (ditto)"
`;

exports[`render hlm library: 1.7.1.34 Essentials/Numbers/Natural/power 1`] = `
"Definition 1.7.1.34.  Let m, n ∈ ℕ. We define

  m^n

by:

  m^0 := 1
  m^(x+1) := m^x ⋅ m  (x ∈ ℕ)

References.

* https://en.wikipedia.org/wiki/Exponentiation#Integer_exponents
* https://proofwiki.org/wiki/Definition:Power_(Algebra)#Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#pow
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.pow
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/basic.html#nat.pow"
`;

exports[`render hlm library: 1.7.1.35 Essentials/Numbers/Natural/inductive 1`] = `
"Definition 1.7.1.35.  Let M ⊆ ℕ. We define:

  M is inductive  :⇔  0 ∈ M and ∀ m ∈ M : m + 1 ∈ M

Remarks.

This definition should be considered part of \`$\\"Induction principle\\"\`.

References.

* https://en.wikipedia.org/wiki/Inductive_set (but uses a 1-based definition)
* https://mathworld.wolfram.com/InductiveSet.html
* https://proofwiki.org/wiki/Definition:Inductive_Set (also uses a 1-based definition)"
`;

exports[`render hlm library: 1.7.1.36 Essentials/Numbers/Natural/Induction%20lemma 1`] = `
"Lemma 1.7.1.36.  Let M ⊆ ℕ such that M is inductive, n ∈ ℕ. Then:

  n ∈ M

Proof.  By induction on n.

* We show that 0 ∈ M:
  M is inductive ⇒^def 0 ∈ M
* Let x ∈ ℕ. Then x + 1 ∈ M:
  1.7.1.36 ⇒ x ∈ M
  M is inductive ⇒^def ∀ m ∈ M : m + 1 ∈ M
   ⇒ x + 1 ∈ M"
`;

exports[`render hlm library: 1.7.1.37 Essentials/Numbers/Natural/Induction%20principle 1`] = `
"Theorem 1.7.1.37 (Induction principle).  Let M ⊆ ℕ. Then the following are equivalent:

  1. M is inductive
  2. M = ℕ

Proof.

1⇒2. Assume M is inductive. Then M = ℕ:
     ⊇. Let n ∈ ℕ.
        1.7.1.36 ⇒ n ∈ M

Remarks.

Structural induction on the natural numbers is a direct consequence of their definition as a construction. This set-theoretic form of the induction principle is provable from it.

References.

* https://proofwiki.org/wiki/Principle_of_Mathematical_Induction/Well-Ordered_Set"
`;

exports[`render hlm library: 1.7.1.38 Essentials/Numbers/Natural/Induction%20principle%20of%20property 1`] = `
"Corollary 1.7.1.38 (Induction principle (property-based)).  Let p be a property on ℕ such that 0 is p and [∀ m ∈ ℕ s.t. m is p : m + 1 is p]. Then:

  ∀ n ∈ ℕ : n is p

No proof.

Remarks.

This is just a slight reformulation based on the definition of a property (see \`$../../Properties/Properties\`).

References.

* https://en.wikipedia.org/wiki/Mathematical_induction
* https://mathworld.wolfram.com/PrincipleofMathematicalInduction.html
* https://proofwiki.org/wiki/Principle_of_Mathematical_Induction/Zero-Based"
`;

exports[`render hlm library: 1.7.1.39 Essentials/Numbers/Natural/Well-ordering%20principle 1`] = `
"Theorem 1.7.1.39 (Well-ordering principle).

  ≤ is a well-order

No proof.

References.

* https://en.wikipedia.org/wiki/Well-ordering_principle
* https://mathworld.wolfram.com/WellOrderingPrinciple.html
* https://proofwiki.org/wiki/Well-Ordering_Principle"
`;

exports[`render hlm library: 1.7.1.40 Essentials/Numbers/Natural/minimum 1`] = `
"Definition 1.7.1.40.  Let M ⊆ ℕ such that M is nonempty. For m ∈ M, we define:

  min(M) = m  :⇔  ∀ n ∈ M : m ≤ n
    ⇔  ∀ l ∈ M s.t. l ≤ m : l = m
    ⇔  ∄ k ∈ M : k < m

Equivalence.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Maxima_and_minima#In_relation_to_sets
* https://mathworld.wolfram.com/Minimum.html
* https://proofwiki.org/wiki/Definition:Minimal/Ordered_Set"
`;

exports[`render hlm library: 1.7.1.41 Essentials/Numbers/Natural/minimum%20of%20two%20numbers 1`] = `
"Definition 1.7.1.41.  Let m, n ∈ ℕ. We define:

  min(m, n) := min({m, n})
   = {m if m ≤ n, n if m > n
   = {0 if n = 0, ({0 if m = 0, min(x, y) + 1 if m = x + 1 (x ∈ ℕ)) if n = y + 1 (y ∈ ℕ)

Equality.  No proof.

References.

* https://proofwiki.org/wiki/Definition:Min_Operation
* https://coq.inria.fr/library/Coq.Init.Nat.html#min
* https://leanprover-community.github.io/mathlib_docs/core/init/algebra/functions.html#min"
`;

exports[`render hlm library: 1.7.1.42 Essentials/Numbers/Natural/maximum 1`] = `
"Definition 1.7.1.42.  Let M ⊆ ℕ such that M is finite and M is nonempty. For m ∈ M, we define:

  max(M) = m  :⇔  ∀ n ∈ M : m ≥ n
    ⇔  ∀ l ∈ M s.t. l ≥ m : l = m
    ⇔  ∄ k ∈ M : k > m

Equivalence.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Maxima_and_minima#In_relation_to_sets
* https://mathworld.wolfram.com/Maximum.html
* https://proofwiki.org/wiki/Definition:Maximal/Ordered_Set"
`;

exports[`render hlm library: 1.7.1.43 Essentials/Numbers/Natural/maximum%20of%20two%20numbers 1`] = `
"Definition 1.7.1.43.  Let m, n ∈ ℕ. We define:

  max(m, n) := max({m, n})
   = {m if m ≥ n, n if m < n
   = {m if n = 0, ({n if m = 0, max(x, y) + 1 if m = x + 1 (x ∈ ℕ)) if n = y + 1 (y ∈ ℕ)

Equality.  No proof.

References.

* https://proofwiki.org/wiki/Definition:Max_Operation
* https://coq.inria.fr/library/Coq.Init.Nat.html#max
* https://leanprover-community.github.io/mathlib_docs/core/init/algebra/functions.html#max"
`;

exports[`render hlm library: 1.7.1.44.1 Essentials/Numbers/Natural/Sequences/indexed%20element 1`] = `
"Definition 1.7.1.44.1.  Let M ⊆ ℕ, n ∈ ℕ such that n < |M|, m := min(M). We define

  M[n]

by:

  M[0] := m
  M[x + 1] := (M ∖ {m})[x]  (x ∈ ℕ)

Remarks.

This definition is used to prove the equivalence of alternative definitions of finiteness (see \`$../../../Sets/finite\`), and to provide a way of obtaining a sequence from a finite set of natural numbers (see \`$\\"sequence from subset\\"\`)."
`;

exports[`render hlm library: 1.7.1.44.2 Essentials/Numbers/Natural/Sequences/bounded%20cardinality 1`] = `
"Definition 1.7.1.44.2.  Let M ⊆ ℕ, n ∈ ℕ. We define

  |M|_≤n

by:

  |M|_≤0 := 0
  |M|_≤x+1 := {|M ∖ {min(M)}|_≤x + 1 if M is nonempty, 0 if M is empty  (x ∈ ℕ)

Remarks.

This definition is used to prove the equivalence of alternative definitions of finiteness (see \`$../../../Sets/finite\`). It yields a natural number that is a lower bound for the cardinality of a subset of natural numbers."
`;

exports[`render hlm library: 1.7.1.44.3 Essentials/Numbers/Natural/Sequences/tuple%20of%20numbers 1`] = `
"Definition 1.7.1.44.3 (Tuple).

This macro provides a shortcut for tuples of natural numbers."
`;

exports[`render hlm library: 1.7.1.44.4 Essentials/Numbers/Natural/Sequences/sequence%20from%20subset 1`] = `
"Definition 1.7.1.44.4.  Let M ⊆ ℕ, α := [M]_ω. We define:

  seq(M) := seq_(≤∣_M)(M)
   = ((M[n])_(n < α))_(M^α)

Equality.  No proof.

Remarks.

This definition produces a sorted finite sequence from a finite subset of natural numbers."
`;

exports[`render hlm library: 1.7.1.44.5 Essentials/Numbers/Natural/Sequences/infinite%20sequence%20from%20subset 1`] = `
"Definition 1.7.1.44.5.  Let M ⊆ ℕ such that M is infinite. We define:

  seq_ω(M) := (M[n])_(n ∈ ℕ)

Remarks.

This definition produces a sorted infinite sequence from an infinite subset of natural numbers."
`;

exports[`render hlm library: 1.7.1.45 Essentials/Numbers/Natural/factorial 1`] = `
"Definition 1.7.1.45.  Let n ∈ ℕ. We define:

  n! := {1 if n = 0, x! ⋅ n if n = x + 1 (x ∈ ℕ)

References.

* https://en.wikipedia.org/wiki/Factorial
* https://mathworld.wolfram.com/Factorial.html
* https://proofwiki.org/wiki/Definition:Factorial
* https://coq.inria.fr/library/Coq.Arith.Factorial.html#fact
* https://leanprover-community.github.io/mathlib_docs/data/nat/basic.html#nat.fact
* http://oeis.org/A000142"
`;

exports[`render hlm library: 1.7.1.46 Essentials/Numbers/Natural/Small%20factorials 1`] = `
"Proposition 1.7.1.46.

  (n!)_(n ∈ ℕ) starts with (1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000, 121645100408832000, 2432902008176640000, 51090942171709440000, 1124000727777607680000)

No proof.

References.

* http://oeis.org/A000142"
`;

exports[`render hlm library: 1.7.1.47 Essentials/Numbers/Natural/binomial%20coefficient 1`] = `
"Definition 1.7.1.47.  Let n, k ∈ ℕ. We define

  (n, k)

by:

  (n, 0) := 1
  (0, x + 1) := 0  (x ∈ ℕ)
  (m + 1, x + 1) := (m, x) + (m, x + 1)  (m ∈ ℕ, x ∈ ℕ)

Remarks.

We use this definition of the binomial coefficient because it does not need any well-definedness proof. It can then easily be proved to be equal to the standard definition (see \`$\\"Binomial coefficient equality\\"\`).

References.

* https://en.wikipedia.org/wiki/Pascal%27s_rule
* https://leanprover-community.github.io/mathlib_docs/data/nat/basic.html#nat.choose"
`;

exports[`render hlm library: 1.7.1.48 Essentials/Numbers/Natural/Binomial%20coefficient%20equality 1`] = `
"Proposition 1.7.1.48.  Let n ∈ ℕ, k ∈ ℕ_(≤n). Then:

  (n, k) = n!∕(k! ⋅ (n − k)!)

No proof.

References.

* https://en.wikipedia.org/wiki/Binomial_coefficient
* https://mathworld.wolfram.com/BinomialCoefficient.html
* https://proofwiki.org/wiki/Definition:Binomial_Coefficient
* https://coq.inria.fr/library/Coq.Reals.Binomial.html#C
* https://leanprover-community.github.io/mathlib_docs/data/nat/basic.html#nat.choose_eq_fact_div_fact"
`;

exports[`render hlm library: 1.7.1.49.1 Essentials/Numbers/Natural/Iterated%20operators/iterated%20sum 1`] = `
"Definition 1.7.1.49.1.  We define:

  ∑ := [0 + ⋅⋅⋅] is an iterated operation on ℕ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Natural numbers\\", ⨂ = $\\"iterated sum\\", n = n, _1 = {#(i: %Element($../Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.7.1.49.2 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20sum%20grows 1`] = `
"Proposition 1.7.1.49.2.  Let I be a finite set, let a_i ∈ ℕ for each i ∈ I, let J ⊆ I. Then:

  ∑_(i ∈ J) a_i ≤ ∑_(i ∈ I) a_i

No proof."
`;

exports[`render hlm library: 1.7.1.49.3 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20sum%20is%20greater%20or%20equal%20to%20each%20element 1`] = `
"Proposition 1.7.1.49.3.  Let I be a finite set, let a_i ∈ ℕ for each i ∈ I, let j ∈ I. Then:

  a_j ≤ ∑_(i ∈ I) a_i

No proof."
`;

exports[`render hlm library: 1.7.1.49.4 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20sum%20over%20constant 1`] = `
"Proposition 1.7.1.49.4.  Let n, a ∈ ℕ. Then:

  ∑_(i < n) a = n ⋅ a

No proof."
`;

exports[`render hlm library: 1.7.1.49.5 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20sum%20over%20variable 1`] = `
"Proposition 1.7.1.49.5.  Let n ∈ ℕ. Then:

  ∑_(i < n) i = (n, 2) = {(n ⋅ (n − 1))∕2 if n ≠ 0, 0 if n = 0

No proof."
`;

exports[`render hlm library: 1.7.1.49.6 Essentials/Numbers/Natural/Iterated%20operators/iterated%20product 1`] = `
"Definition 1.7.1.49.6.  We define:

  ∏ := [1 ⋅ ⋅⋅⋅] is an iterated operation on ℕ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Natural numbers\\", ⨂ = $\\"iterated product\\", n = n, _1 = {#(i: %Element($../Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 1.7.1.49.7 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20product%20multiplies 1`] = `
"Proposition 1.7.1.49.7.  Let I be a finite set, let a_i ∈ ℕ for each i ∈ I, let J ⊆ I. Then:

  (∏_(i ∈ J) a_i) ∣ (∏_(i ∈ I) a_i)

No proof."
`;

exports[`render hlm library: 1.7.1.49.8 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20product%20of%20positive%20numbers%20grows 1`] = `
"Proposition 1.7.1.49.8.  Let I be a finite set, let a_i ∈ ℕ_+ for each i ∈ I, let J ⊆ I. Then:

  ∏_(i ∈ J) a_i ≤ ∏_(i ∈ I) a_i

No proof."
`;

exports[`render hlm library: 1.7.1.49.9 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20product%20is%20a%20multiple%20of%20each%20element 1`] = `
"Proposition 1.7.1.49.9.  Let I be a finite set, let a_i ∈ ℕ for each i ∈ I, let j ∈ I. Then:

  a_j ∣ (∏_(i ∈ I) a_i)

No proof."
`;

exports[`render hlm library: 1.7.1.49.10 Essentials/Numbers/Natural/Iterated%20operators/Iterated%20product%20of%20positive%20numbers%20is%20greater%20or%20equal%20to%20each%20element 1`] = `
"Proposition 1.7.1.49.10.  Let I be a finite set, let a_i ∈ ℕ_+ for each i ∈ I, let j ∈ I. Then:

  a_j ≤ ∏_(i ∈ I) a_i

No proof."
`;

exports[`render hlm library: 1.7.1.50.1 Essentials/Numbers/Natural/Prime/prime 1`] = `
"Definition 1.7.1.50.1.  Let n ∈ ℕ_(>1). We define:

  n is prime  :⇔  ∀ m ∈ ℕ_+ s.t. m ∣ n : [m = 1 or m = n]
    ⇔  ∀ l ∈ ℕ_(>1) s.t. l ∣ n : l = n
    ⇔  Div_ℕ(n) ⊆ {1, n}
    ⇔  Div_ℕ(n) = {1, n}
    ⇔  |Div_ℕ(n)| = 2
    ⇔  ∀ a, b ∈ ℕ s.t. n = a ⋅ b : [[a = 1 and b = n] or [a = n and b = 1]]
    ⇔  ∄ c, d ∈ ℕ_(<n) : n = c ⋅ d
    ⇔  ∀ e, f ∈ ℕ s.t. n ∣ e ⋅ f : [n ∣ e or n ∣ f]

  n is composite  :⇔  n is not prime

Equivalence.  No proof.

Remarks.

Note that this definition presupposes that \`$../less(n = n, m = $../number(value = 1))\`. Otherwise, not all equivalences would hold.

In particular, this makes it impossible to ask whether 1 is prime. However, it is rarely necessary to ask whether a given number is prime without knowing that it is greater than 1. For definitions and theorems involving the set \`$\\"Prime numbers\\"\` of prime numbers, no such explicit exclusion of 1 is necessary.

References.

* https://en.wikipedia.org/wiki/Prime_number
* https://en.wikipedia.org/wiki/Euclid%27s_lemma
* https://mathworld.wolfram.com/PrimeNumber.html
* https://proofwiki.org/wiki/Definition:Prime_Number
* https://ncatlab.org/nlab/show/prime+number
* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#prime
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.prime
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.dvd_prime"
`;

exports[`render hlm library: 1.7.1.50.2 Essentials/Numbers/Natural/Prime/Two%20is%20prime 1`] = `
"Example 1.7.1.50.2.

  2 is prime

No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#prime_2
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.prime_two"
`;

exports[`render hlm library: 1.7.1.50.3 Essentials/Numbers/Natural/Prime/Prime%20numbers 1`] = `
"Definition 1.7.1.50.3.  We define:

  ℙ := {n ∈ ℕ_(>1) : n is prime}

We write “let p be a prime” for “let p ∈ ℙ.”

References.

* https://en.wikipedia.org/wiki/Prime_number
* https://mathworld.wolfram.com/PrimeNumber.html
* https://proofwiki.org/wiki/Definition:Prime_Number#Notation
* http://oeis.org/A000040"
`;

exports[`render hlm library: 1.7.1.50.4 Essentials/Numbers/Natural/Prime/Small%20primes 1`] = `
"Proposition 1.7.1.50.4.

  seq_ω(ℙ) starts with (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271)

No proof.

References.

* https://en.wikipedia.org/wiki/List_of_prime_numbers
* http://oeis.org/A000040"
`;

exports[`render hlm library: 1.7.1.50.5 Essentials/Numbers/Natural/Prime/Every%20number%20greater%20than%20one%20has%20a%20prime%20factor 1`] = `
"Proposition 1.7.1.50.5.  Let n ∈ ℕ_(>1). Then:

  ∃ prime p : p ∣ n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.exists_prime_and_dvd"
`;

exports[`render hlm library: 1.7.1.50.6 Essentials/Numbers/Natural/Prime/Euclids%20theorem 1`] = `
"Theorem 1.7.1.50.6 (Euclid's theorem).

  ℙ is infinite

Proof.  Assume ℙ is finite.

Let a := ∏_(p ∈ ℙ) p.

 ⇒ a ≥ 1:

  1.7.1.49.8 ⇒ ∏_(x ∈ ∅) x ≤ ∏_(p ∈ ℙ) p
   ⇒^1.5.18.8 1 ≤ ∏_(p ∈ ℙ) p

 ⇒^1.7.1.13 a + 1 > 1
 ⇒^1.7.1.50.5 ∃ prime p : p ∣ (a + 1)
 ⇒^1.7.1.31 p ∣ 1
 ⇒^1.7.1.30 p ≤ 1

p ∈ ℙ ⇒^def p > 1 ⭍

References.

* https://en.wikipedia.org/wiki/Euclid%27s_theorem
* https://mathworld.wolfram.com/EuclidsTheorems.html
* https://proofwiki.org/wiki/Euclid%27s_Theorem
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.exists_infinite_primes"
`;

exports[`render hlm library: 1.7.1.50.7 Essentials/Numbers/Natural/Prime/Prime%20and%20power%20divisibility%20criterion 1`] = `
"Proposition 1.7.1.50.7.  Let p be a prime, m ∈ ℕ, n ∈ ℕ_+. Then the following are equivalent:

  1. p ∣ m
  2. p ∣ m^n
  3. p^n ∣ m^n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.prime.dvd_of_dvd_pow
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.dvd_prime_pow"
`;

exports[`render hlm library: 1.7.1.50.8 Essentials/Numbers/Natural/Prime/multiplicity 1`] = `
"Definition 1.7.1.50.8.  Let n ∈ ℕ_+, p be a prime. For x ∈ ℕ, we define:

  mult(p, n) = x  :⇔  ∃ m ∈ ℕ_+ : [p^x ⋅ m = n and p ∤ m]
    ⇔  p^x ∣ n and p ∤ n∕p^x
    ⇔  p^x ∣ n and p^(x+1) ∤ n
    ⇔  p^x ∣ n and ∄ y ∈ ℕ_(>x) : p^y ∣ n

Equivalence.  No proof.

Well-definedness.  No proof.

Remarks.

This definition would make sense even if \`p\` was not required to be prime. However, the term \\"multiplicity\\" is reserved for prime numbers due to its use in the unique prime factorization.

References.

* https://en.wikipedia.org/wiki/Multiplicity_(mathematics)#Multiplicity_of_a_prime_factor
* https://proofwiki.org/wiki/Definition:Prime_Decomposition/Multiplicity
* https://leanprover-community.github.io/mathlib_docs/ring_theory/multiplicity.html#multiplicity"
`;

exports[`render hlm library: 1.7.1.50.9 Essentials/Numbers/Natural/Prime/prime%20factors 1`] = `
"Definition 1.7.1.50.9.  Let n ∈ ℕ. We define:

  PrimeFactors(n) := {p^(mult(p,n))} is a/an ℙ-multiset"
`;

exports[`render hlm library: 1.7.1.50.10 Essentials/Numbers/Natural/Prime/Prime%20factorization 1`] = `
"Theorem 1.7.1.50.10 (Prime factorization).  Let n ∈ ℕ_+. Then:

  n = ∏_(p ∈ ℙ) p^(mult(p,n)) = ∏_(p ∈ PrimeFactors(n)) p

No proof.

Remarks.

This weaker but perhaps more useful version of the fundamental theorem of arithmetic simply states that each number can be written as the product of its prime divisors raised to their multiplicity (which is 0 for all primes that are not prime factors).

Therefore, it yields the prime factorization of \`n\`. However, it does not state that no other prime factorization exists. This strengthened version is stated in the following theorem.

References.

* https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic
* https://mathworld.wolfram.com/FundamentalTheoremofArithmetic.html
* https://proofwiki.org/wiki/Fundamental_Theorem_of_Arithmetic
* https://ncatlab.org/nlab/show/fundamental+theorem+of+arithmetic
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.factors"
`;

exports[`render hlm library: 1.7.1.50.11 Essentials/Numbers/Natural/Prime/Fundamental%20theorem%20of%20arithmetic 1`] = `
"Theorem 1.7.1.50.11 (Fundamental theorem of arithmetic).  Let n ∈ ℕ_+. Then:

  ∃! 𝑷 ∈ 𝓜𝓾𝓵𝓽𝓲𝓢𝓮𝓽(ℙ) s.t. 𝑷 is finite : n = ∏_(p ∈ 𝑷) p

No proof.

Remarks.

This \\"official\\" statement of the fundamental theorem of arithmetic is actually a simple corollary of the previous version.

Note that the product over all elements of \`𝑷\` takes into account the multiplicity in the multiset.

References.

* https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic
* https://mathworld.wolfram.com/FundamentalTheoremofArithmetic.html
* https://proofwiki.org/wiki/Fundamental_Theorem_of_Arithmetic
* https://ncatlab.org/nlab/show/fundamental+theorem+of+arithmetic
* https://leanprover-community.github.io/mathlib_docs/data/nat/prime.html#nat.factors"
`;

exports[`render hlm library: 1.7.1.51 Essentials/Numbers/Natural/coprime 1`] = `
"Definition 1.7.1.51.  Let m, n ∈ ℕ. We define:

  m and n are coprime  :⇔  ∀ a ∈ ℕ_+ s.t. a ∣ m and a ∣ n : a = 1
    ⇔  ∄ b ∈ ℕ_(>1) : [b ∣ m and b ∣ n]
    ⇔  Div_ℕ(m) ∩ Div_ℕ(n) ⊆ {1}
    ⇔  Div_ℕ(m) ∩ Div_ℕ(n) = {1}
    ⇔  ∄ prime p : [p ∣ m and p ∣ n]

Equivalence.  No proof.

Remarks.

Note that in addition to this definition for natural numbers, there is a compatible definition for integers: \`$../Integer/coprime\`.

References.

* https://en.wikipedia.org/wiki/Coprime_integers
* https://mathworld.wolfram.com/RelativelyPrime.html
* https://proofwiki.org/wiki/Definition:Coprime/Integers
* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#rel_prime (for integers)
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/gcd.html#nat.coprime"
`;

exports[`render hlm library: 1.7.1.52 Essentials/Numbers/Natural/Coprime%20test 1`] = `
"Proposition 1.7.1.52.  Let m, n ∈ ℕ_(>1). Then:

  m and m ⋅ n are not coprime

No proof."
`;

exports[`render hlm library: 1.7.2.1 Essentials/Numbers/Cardinal/Natural%20cardinality%20lemma 1`] = `
"Lemma 1.7.2.1.  Let m, n ∈ ℕ, f : ℕ_(<m) ↔ ℕ_(<n) be a bijection. Then:

  m = n

No proof.

Remarks.

This lemma is part of the well-definedness proof of the embedding of the natural numbers into the cardinal numbers."
`;

exports[`render hlm library: 1.7.2.2 Essentials/Numbers/Cardinal/Cardinal%20numbers 1`] = `
"Definition 1.7.2.2.  We define:

  𝓒𝓻𝓭 :=: {|S| | S is a set}

  |S| = |T|  :⇔  ∃ f : S ↔ T  (S is a set, T is a set)

ℕ ⊆: 𝓒𝓻𝓭 via
n = |ℕ_(<n)|

  Well-definedness.  Let m, n ∈ ℕ such that |ℕ_(<m)| = |ℕ_(<n)|. Then m = n:

  |ℕ_(<m)| = |ℕ_(<n)| ⇒^def ∃ f : ℕ_(<m) ↔ ℕ_(<n)

  1.7.2.1 ⇒ m = n

We write “let κ be a cardinal number” for “let κ ∈ 𝓒𝓻𝓭.”

Remarks.

In HLM, cardinal numbers have a very simple definition as a construction with one constructor, which can be conveniently equipped with a notation that matches mathematical practice.

Given that two arbitrary sets cannot be compared element-wise due to the type system, the equality definition for cardinal numbers is the most general definition possible: No other valid equality definition can possibly distinguish two equipollent sets. This implies that definitions involving the \\"deconstruction\\" of cardinal numbers into sets are automatically well-defined.

HLM does not distinguish between sets and proper classes; instead there are rules preventing certain circularities. Thus, the set of cardinals can be treated like any other set in most situations.

When defining a construction, an embedding from another set into the newly defined set can be specified, subject to a suitable well-definedness condition. Embedding the natural numbers in the cardinal numbers simplifies a lot of definitions and theorems (see \`$finite\`, \`$\\"Cardinality of power set\\"\`).

In a way, the definition of cardinal numbers in HLM is very similar to the definition of algebraic structures (see e.g. \`$../../../Algebra/\\"Pointed sets\\"/\\"Pointed sets\\"\`, \`$../../../Algebra/Magmas/Magmas\`, \`$../../../Algebra/Groups/Groups\`). This is especially visible in the use of this definition in the category of sets \`$../../../\\"Category theory\\"/\\"Concrete categories\\"/cardinals\`.

References.

* https://en.wikipedia.org/wiki/Cardinal_number
* https://mathworld.wolfram.com/CardinalNumber.html
* https://proofwiki.org/wiki/Definition:Cardinal
* https://ncatlab.org/nlab/show/cardinal+number
* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal"
`;

exports[`render hlm library: 1.7.2.3 Essentials/Numbers/Cardinal/Carrier 1`] = `
"Definition 1.7.2.3.  Let κ be a cardinal number. We define

  (κ)

by:

  (|K|) := K  (K is a set)

We write “let a ∈ κ” for “let a ∈ (κ).”

Remarks.

This definition retrieves a representative set from a cardinal number."
`;

exports[`render hlm library: 1.7.2.4.1 Essentials/Numbers/Cardinal/Homomorphisms/Homomorphisms 1`] = `
"Definition 1.7.2.4.1.  Let κ, μ be cardinal numbers. We define:

  Hom(κ, μ) := ((κ) → (μ))

We write “let φ : κ → μ be a homomorphism” for “let φ ∈ Hom(κ, μ).”

Remarks.

The definition of cardinal numbers in HLM is very similar to the definition of algebraic structures such as magmas. Thus it makes sense to define a homomorphism between cardinal numbers as a function between representative sets.

Although these sets are not unique, the type system prevents the ambiguities that could arise, as long as the equality definition of the structure does not define any non-isomorphic elements as equal.

References.

* https://en.wikipedia.org/wiki/Homomorphism
* https://mathworld.wolfram.com/Homomorphism.html
* https://proofwiki.org/wiki/Definition:Homomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/homomorphism"
`;

exports[`render hlm library: 1.7.2.4.2 Essentials/Numbers/Cardinal/Homomorphisms/Isomorphisms 1`] = `
"Definition 1.7.2.4.2.  Let κ, μ be cardinal numbers. We define:

  Iso(κ, μ) := {φ : κ → μ : φ is bijective}
   = ((κ) ↔ (μ))

We write “let φ : κ ↔ μ be an isomorphism” for “let φ ∈ Iso(κ, μ).”

Equality.  No proof.

Remarks.

An isomorphism between cardinal numbers is simply a bijection between their representative sets. Thus, the existence of an isomorphism implies that the two cardinal numbers are in fact equal, as is shown below in \`$../\\"Equality criterion\\"\`).

References.

* https://en.wikipedia.org/wiki/Isomorphism
* https://mathworld.wolfram.com/Isomorphism.html
* https://proofwiki.org/wiki/Definition:Isomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 1.7.2.4.3 Essentials/Numbers/Cardinal/Homomorphisms/Automorphisms 1`] = `
"Definition 1.7.2.4.3.  Let κ be a cardinal number. We define:

  Aut(κ) := Iso(κ, κ)

We write “let φ : κ ↔ κ be an automorphism” for “let φ ∈ Aut(κ).”

Remarks.

Automorphisms of cardinal numbers, i.e. self-bijections of a set, might not be a particular useful concept. They are included for completeness.

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism"
`;

exports[`render hlm library: 1.7.2.4.4 Essentials/Numbers/Cardinal/Homomorphisms/automorphism%20group 1`] = `
"Definition 1.7.2.4.4.  Let κ be a cardinal number. We define:

  Aut(κ) := [Aut(κ)]_(𝑆_(κ))

Remarks.

The automorphism group, as a subgroup of the symmetric group of the carrier.

This definition makes a forward reference to concepts related to groups.

Alternatively, automorphism groups could be defined more generally via category theory, but using them would require specifying the specific category to use.

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group"
`;

exports[`render hlm library: 1.7.2.4.5 Essentials/Numbers/Cardinal/Homomorphisms/identity 1`] = `
"Definition 1.7.2.4.5.  Let κ be a cardinal number. We define:

  id_κ := id_(κ)"
`;

exports[`render hlm library: 1.7.2.5 Essentials/Numbers/Cardinal/less%20or%20equal 1`] = `
"Definition 1.7.2.5.  Let κ, μ be cardinal numbers. We define:

  κ ≤ μ  :⇔  ∃ φ : κ → μ : φ is injective
    ⇔  ∃ S ⊆ (μ) : |S| = κ

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Cardinal_number
* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal.has_le"
`;

exports[`render hlm library: 1.7.2.6 Essentials/Numbers/Cardinal/less 1`] = `
"Definition 1.7.2.6.  Let κ, μ be cardinal numbers. We define:

  κ < μ  :⇔  κ ≤ μ and κ ≠ μ

Remarks.

Note that without the axiom of choice, this is not equivalent to the negation of \\"greater or equal\\"."
`;

exports[`render hlm library: 1.7.2.7.1 Essentials/Numbers/Cardinal/Subsets/Segment%20(less) 1`] = `
"Definition 1.7.2.7.1.  Let κ be a cardinal number. We define:

  𝓒𝓻𝓭_(<κ) := {μ ∈ 𝓒𝓻𝓭 : μ < κ}"
`;

exports[`render hlm library: 1.7.2.7.2 Essentials/Numbers/Cardinal/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.7.2.7.2.  Let κ be a cardinal number. We define:

  𝓒𝓻𝓭_(≤κ) := {μ ∈ 𝓒𝓻𝓭 : μ ≤ κ}"
`;

exports[`render hlm library: 1.7.2.7.3 Essentials/Numbers/Cardinal/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.7.2.7.3.  Let κ be a cardinal number. We define:

  𝓒𝓻𝓭_(≥κ) := {μ ∈ 𝓒𝓻𝓭 : μ ≥ κ}"
`;

exports[`render hlm library: 1.7.2.7.4 Essentials/Numbers/Cardinal/Subsets/Segment%20(greater) 1`] = `
"Definition 1.7.2.7.4.  Let κ be a cardinal number. We define:

  𝓒𝓻𝓭_(>κ) := {μ ∈ 𝓒𝓻𝓭 : μ > κ}"
`;

exports[`render hlm library: 1.7.2.8 Essentials/Numbers/Cardinal/Equality%20criterion 1`] = `
"Theorem 1.7.2.8 (Schröder-Bernstein).  Let κ, μ be cardinal numbers. Then the following are equivalent:

  1. κ ≤ μ and μ ≤ κ
  2. Iso(κ, μ) is nonempty
  3. κ = μ

No proof.

Remarks.

This is essentially the Schröder-Bernstein theorem together with the HLM-specific equality criterion on structures.

References.

* [https://en.wikipedia.org/wiki/Schröder-Bernstein_theorem](https://en.wikipedia.org/wiki/Schr%C3%B6der-Bernstein_theorem)
* https://mathworld.wolfram.com/Schroeder-BernsteinTheorem.html
* [https://proofwiki.org/wiki/Cantor-Bernstein-Schröder_Theorem](https://proofwiki.org/wiki/Cantor-Bernstein-Schr%C3%B6der_Theorem)
* https://leanprover-community.github.io/mathlib_docs/set_theory/schroeder_bernstein.html#function.embedding.antisymm"
`;

exports[`render hlm library: 1.7.2.9 Essentials/Numbers/Cardinal/Less%20or%20equal%20is%20a%20partial%20order 1`] = `
"Proposition 1.7.2.9.

  ≤ is a partial order

No proof."
`;

exports[`render hlm library: 1.7.2.10 Essentials/Numbers/Cardinal/AC%20is%20equivalent%20to%20total%20order 1`] = `
"Proposition 1.7.2.10.  The following are equivalent:

  1. AC
  2. ≤ is a total order

No proof.

Remarks.

The non-circularity requirements of HLM have a subtle effect on this proposition: Even though the axiom of choice, by itself, does not exclude the set of cardinal numbers, this proposition cannot be used to conclude that the cardinal numbers have a choice function if the order on cardinal numbers is total.

References.

* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal.linear_order"
`;

exports[`render hlm library: 1.7.2.11 Essentials/Numbers/Cardinal/sum 1`] = `
"Definition 1.7.2.11.  Let κ, μ be cardinal numbers. We define

  κ + μ

by:

  |K| + |J| := |K ⊎ J|  (K is a set, J is a set)

References.

* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_addition
* https://mathworld.wolfram.com/CardinalAddition.html
* https://proofwiki.org/wiki/Definition:Sum_of_Cardinals
* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal.add_def"
`;

exports[`render hlm library: 1.7.2.12 Essentials/Numbers/Cardinal/product 1`] = `
"Definition 1.7.2.12.  Let κ, μ be cardinal numbers. We define

  κ ⋅ μ

by:

  |K| ⋅ |J| := |K × J|  (K is a set, J is a set)

References.

* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_multiplication
* https://mathworld.wolfram.com/CardinalMultiplication.html
* https://proofwiki.org/wiki/Definition:Product_of_Cardinals
* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal.mul_def"
`;

exports[`render hlm library: 1.7.2.13 Essentials/Numbers/Cardinal/power 1`] = `
"Definition 1.7.2.13.  Let κ, μ be cardinal numbers. We define

  κ^μ

by:

  |K|^|J| := |J → K|  (K is a set, J is a set)

References.

* https://mathworld.wolfram.com/CardinalExponentiation.html
* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_exponentiation
* https://proofwiki.org/wiki/Definition:Exponentiation_of_Cardinals
* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal.power_def"
`;

exports[`render hlm library: 1.7.2.14 Essentials/Numbers/Cardinal/Cardinality%20of%20power%20set 1`] = `
"Proposition 1.7.2.14.  Let S be a set. Then:

  |𝒫(S)| = 2^|S|

No proof.

References.

* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_exponentiation
* https://mathworld.wolfram.com/CardinalExponentiation.html"
`;

exports[`render hlm library: 1.7.2.15.1 Essentials/Numbers/Cardinal/Examples/aleph 1`] = `
"Definition 1.7.2.15.1.  Let α ∈ {0}. We define:

  ℵ_α := |ℕ|
   = |ℤ|
   = |ℚ|

Equality.  No proof.

Remarks.

This definition is currently a stub that should be extended to arbitrary aleph numbers.

References.

* https://en.wikipedia.org/wiki/Aleph_number
* https://mathworld.wolfram.com/Aleph-0.html
* https://ncatlab.org/nlab/show/aleph
* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#cardinal.aleph_zero"
`;

exports[`render hlm library: 1.7.2.15.2 Essentials/Numbers/Cardinal/Examples/continuum 1`] = `
"Definition 1.7.2.15.2.  We define:

  𝔠 := |ℝ|
   = |ℂ|
   = |𝒫(ℕ)|
   = 2^(ℵ_0)

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Cardinality_of_the_continuum
* https://mathworld.wolfram.com/Continuum.html
* https://ncatlab.org/nlab/show/continuum
* https://leanprover-community.github.io/mathlib_docs/data/real/cardinality.html#cardinal.mk_real"
`;

exports[`render hlm library: 1.7.2.16 Essentials/Numbers/Cardinal/finite 1`] = `
"Definition 1.7.2.16.  Let κ be a cardinal number. We define:

  κ is finite  :⇔  κ ∈ ℕ
    ⇔  ∃ x ∈ ℕ : κ = x
    ⇔  ∃ y ∈ ℕ : κ ≤ y
    ⇔  ∃ z ∈ ℕ : κ < z

  κ is infinite  :⇔  κ is not finite

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.2.17 Essentials/Numbers/Cardinal/countable 1`] = `
"Definition 1.7.2.17.  Let κ be a cardinal number. We define:

  κ is countable  :⇔  κ ≤ ℵ_0
    ⇔  ∃ M ⊆ ℕ : κ = |M|

  κ is uncountable  :⇔  κ is not countable

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.2.18 Essentials/Numbers/Cardinal/countably%20infinite 1`] = `
"Definition 1.7.2.18.  Let κ be a cardinal number. We define:

  κ is countably infinite  :⇔  κ is countable and κ is infinite
    ⇔  κ = ℵ_0

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.2.19 Essentials/Numbers/Cardinal/Cantors%20theorem 1`] = `
"Theorem 1.7.2.19 (Cantor's theorem).  Let S be a set. Then:

  |𝒫(S)| > |S|

No proof.

References.

* https://en.wikipedia.org/wiki/Cantor%27s_theorem
* https://mathworld.wolfram.com/CantorsTheorem.html
* https://proofwiki.org/wiki/Cantor%27s_Theorem
* https://ncatlab.org/nlab/show/Cantor%27s+theorem
* https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal.html#cardinal.cantor"
`;

exports[`render hlm library: 1.7.2.20 Essentials/Numbers/Cardinal/Cantors%20theorem%20generalized 1`] = `
"Corollary 1.7.2.20.  Let κ ∈ 𝓒𝓻𝓭_(>1), μ be a cardinal number. Then:

  κ^μ > μ

No proof."
`;

exports[`render hlm library: 1.7.2.21 Essentials/Numbers/Cardinal/Continuum%20is%20uncountable 1`] = `
"Corollary 1.7.2.21.

  𝔠 is uncountable

No proof.

References.

* https://en.wikipedia.org/wiki/Cardinality_of_the_continuum
* https://proofwiki.org/wiki/Real_Numbers_are_Uncountable
* https://leanprover-community.github.io/mathlib_docs/data/real/cardinality.html#cardinal.not_countable_real"
`;

exports[`render hlm library: 1.7.2.22.1 Essentials/Numbers/Cardinal/Iterated%20operators/iterated%20sum 1`] = `
"Definition 1.7.2.22.1.  We define:

  ∑ := [0 + ⋅⋅⋅] is an iterated operation on 𝓒𝓻𝓭

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Cardinal numbers\\", ⨂ = $\\"iterated sum\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.7.2.22.2 Essentials/Numbers/Cardinal/Iterated%20operators/generalized%20sum 1`] = `
"Definition 1.7.2.22.2.  Let I be a set, let κ_i be a cardinal number for each i ∈ I, let ≃ be a dependent equality on (κ_i) (i ∈ I). We define:

  ∑_(i ∈ I)^≃ κ_i := |⨄_(j ∈ I)^≃ (κ_j)|

Remarks.

In contrast to the previous definition, this definition works for arbitrary index sets \`I\`, using the generalized disjoint union to add cardinal numbers. However, due to the definition of disjoint union, it requires a \\"dependent equality\\" on the carrier sets of cardinalities."
`;

exports[`render hlm library: 1.7.2.22.3 Essentials/Numbers/Cardinal/Iterated%20operators/iterated%20product 1`] = `
"Definition 1.7.2.22.3.  We define:

  ∏ := [1 ⋅ ⋅⋅⋅] is an iterated operation on 𝓒𝓻𝓭

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Cardinal numbers\\", ⨂ = $\\"iterated product\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 1.7.2.22.4 Essentials/Numbers/Cardinal/Iterated%20operators/generalized%20product 1`] = `
"Definition 1.7.2.22.4.  Let I be a set, let κ_i be a cardinal number for each i ∈ I. We define:

  ∏_(i ∈ I) κ_i := |∏_(j ∈ I) (κ_j)|

Remarks.

In contrast to the previous definition, this definition works for arbitrary index sets \`I\`, using the generalized Cartesian product to multiply cardinal numbers."
`;

exports[`render hlm library: 1.7.3.1 Essentials/Numbers/Ordinal/Ordinal%20numbers 1`] = `
"Definition 1.7.3.1.  We define:

  𝓞𝓻𝓭 :=: {[S, ⪯] | S is a set, ⪯ is a well-order on S}

  [S, ⪯] = [T, ⊑]  :⇔  ∃ φ : S ↔ T : ⪯ ≃^φ ⊑  (S is a set, ⪯ is a relation on S, T is a set, ⊑ is a relation on T with suitable conditions)

ℕ ⊆: 𝓞𝓻𝓭 via
n = [ℕ_(<n), ≤∣_(ℕ_(<n))]

  Well-definedness.  No proof.

We write “let α be an ordinal number” for “let α ∈ 𝓞𝓻𝓭.”

References.

* https://en.wikipedia.org/wiki/Ordinal_number
* https://mathworld.wolfram.com/OrdinalNumber.html
* https://proofwiki.org/wiki/Definition:Ordinal
* https://ncatlab.org/nlab/show/ordinal+number
* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal"
`;

exports[`render hlm library: 1.7.3.2 Essentials/Numbers/Ordinal/Carrier 1`] = `
"Definition 1.7.3.2.  Let α be an ordinal number. We define

  (α)

by:

  ([A, ⪯]) := A  (A is a set, ⪯ is a well-order on A)

We write “let a ∈ α” for “let a ∈ (α).”

Remarks.

This definition retrieves a representative set from an ordinal number."
`;

exports[`render hlm library: 1.7.3.3 Essentials/Numbers/Ordinal/before 1`] = `
"Definition 1.7.3.3.  Let α be an ordinal number, a, b ∈ α. We define:

  a ≤ b  :⇔  a ⪯ b if α = [A, ⪯] (A is a set, ⪯ is a well-order on A)

Remarks.

This definition can be used to access underlying well-ordering of a given ordinal number. It must not be confused with comparison of two ordinal numbers, which is defined a little further below."
`;

exports[`render hlm library: 1.7.3.4.1 Essentials/Numbers/Ordinal/Homomorphisms/Homomorphisms 1`] = `
"Definition 1.7.3.4.1.  Let α, β be ordinal numbers. We define:

  Hom(α, β) := {f : (α) → (β) : ∀ a, b ∈ α : [a ≤ b  ⇔  f(a) ≤ f(b)]}

We write “let φ : α → β be a homomorphism” for “let φ ∈ Hom(α, β).”

References.

* https://en.wikipedia.org/wiki/Order_embedding
* https://proofwiki.org/wiki/Definition:Order_Embedding
* https://leanprover-community.github.io/mathlib_docs/order/rel_iso.html#order_embedding"
`;

exports[`render hlm library: 1.7.3.4.2 Essentials/Numbers/Ordinal/Homomorphisms/Isomorphisms 1`] = `
"Definition 1.7.3.4.2.  Let α, β be ordinal numbers. We define:

  Iso(α, β) := {homomorphisms φ : α → β : φ is bijective}
   = {f : (α) ↔ (β) : ∀ a, b ∈ α : [a ≤ b  ⇔  f(a) ≤ f(b)]}

We write “let φ : α ↔ β be an isomorphism” for “let φ ∈ Iso(α, β).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Order_isomorphism
* https://proofwiki.org/wiki/Definition:Order_Isomorphism
* https://leanprover-community.github.io/mathlib_docs/order/rel_iso.html#order_iso"
`;

exports[`render hlm library: 1.7.3.4.3 Essentials/Numbers/Ordinal/Homomorphisms/Automorphisms 1`] = `
"Definition 1.7.3.4.3.  Let α be an ordinal number. We define:

  Aut(α) := Iso(α, α)

We write “let φ : α ↔ α be an automorphism” for “let φ ∈ Aut(α).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism"
`;

exports[`render hlm library: 1.7.3.4.4 Essentials/Numbers/Ordinal/Homomorphisms/automorphism%20group 1`] = `
"Definition 1.7.3.4.4.  Let α be an ordinal number. We define:

  Aut(α) := [Aut(α)]_(𝑆_(α))

Remarks.

The automorphism group, as a subgroup of the symmetric group of the carrier.

This definition makes a forward reference to concepts related to groups.

Alternatively, automorphism groups could be defined more generally via category theory, but using them would require specifying the specific category to use.

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group"
`;

exports[`render hlm library: 1.7.3.4.5 Essentials/Numbers/Ordinal/Homomorphisms/identity 1`] = `
"Definition 1.7.3.4.5.  Let α be an ordinal number. We define:

  id_α := id_(α)"
`;

exports[`render hlm library: 1.7.3.5.1 Essentials/Numbers/Ordinal/Ordered%20subsets/subset%20ordinal 1`] = `
"Definition 1.7.3.5.1.  Let α be an ordinal number, S ⊆ (α). We define

  [S]_α

by:

  [S]_[A,⪯] := [S, ⪯∣_S]  (A is a set, ⪯ is a well-order on A)"
`;

exports[`render hlm library: 1.7.3.6 Essentials/Numbers/Ordinal/less%20or%20equal 1`] = `
"Definition 1.7.3.6.  Let α, β be ordinal numbers. We define:

  α ≤ β  :⇔  ∃ homomorphism φ : α → β : φ is injective
    ⇔  ∃ S ⊆ (β) : α = [S]_β

Equivalence.  No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal.le"
`;

exports[`render hlm library: 1.7.3.7 Essentials/Numbers/Ordinal/less 1`] = `
"Definition 1.7.3.7.  Let α, β be ordinal numbers. We define:

  α < β  :⇔  α ≤ β and α ≠ β

References.

* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal.lt"
`;

exports[`render hlm library: 1.7.3.8.1 Essentials/Numbers/Ordinal/Subsets/Segment%20(less) 1`] = `
"Definition 1.7.3.8.1.  Let α be an ordinal number. We define:

  𝓞𝓻𝓭_(<α) := {β ∈ 𝓞𝓻𝓭 : β < α}"
`;

exports[`render hlm library: 1.7.3.8.2 Essentials/Numbers/Ordinal/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.7.3.8.2.  Let α be an ordinal number. We define:

  𝓞𝓻𝓭_(≤α) := {β ∈ 𝓞𝓻𝓭 : β ≤ α}"
`;

exports[`render hlm library: 1.7.3.8.3 Essentials/Numbers/Ordinal/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.7.3.8.3.  Let α be an ordinal number. We define:

  𝓞𝓻𝓭_(≥α) := {β ∈ 𝓞𝓻𝓭 : β ≥ α}"
`;

exports[`render hlm library: 1.7.3.8.4 Essentials/Numbers/Ordinal/Subsets/Segment%20(greater) 1`] = `
"Definition 1.7.3.8.4.  Let α be an ordinal number. We define:

  𝓞𝓻𝓭_(>α) := {β ∈ 𝓞𝓻𝓭 : β > α}"
`;

exports[`render hlm library: 1.7.3.9 Essentials/Numbers/Ordinal/Equality%20criterion 1`] = `
"Proposition 1.7.3.9.  Let α, β be ordinal numbers. Then the following are equivalent:

  1. α ≤ β and β ≤ α
  2. Iso(α, β) is nonempty
  3. α = β

No proof.

Remarks.

This is the ordinal-number analogue of the Schröder-Bernstein theorem, together with the HLM-specific equality criterion on structures."
`;

exports[`render hlm library: 1.7.3.10 Essentials/Numbers/Ordinal/Less%20or%20equal%20is%20a%20well-order 1`] = `
"Proposition 1.7.3.10.

  ≤ is a well-order

No proof.

References.

* https://proofwiki.org/wiki/Ordinals_are_Well-Ordered
* https://ncatlab.org/nlab/show/well-order#examples
* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal.is_well_order"
`;

exports[`render hlm library: 1.7.3.11 Essentials/Numbers/Ordinal/sum 1`] = `
"Definition 1.7.3.11.  Let α, β be ordinal numbers. We define

  α + β

by:

  [A, ⪯] + [B, ⊑] := [A ⊎ B, ⪯ ≪ ⊑]  (A is a set, ⪯ is a relation on A, B is a set, ⊑ is a relation on B with suitable conditions)

References.

* https://en.wikipedia.org/wiki/Ordinal_arithmetic#Addition
* https://mathworld.wolfram.com/OrdinalAddition.html
* https://proofwiki.org/wiki/Definition:Ordinal_Addition
* https://ncatlab.org/nlab/show/ordinal+sum
* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal.has_add"
`;

exports[`render hlm library: 1.7.3.12 Essentials/Numbers/Ordinal/product 1`] = `
"Definition 1.7.3.12.  Let α, β be ordinal numbers. We define

  α ⋅ β

by:

  [A, ⪯] ⋅ [B, ⊑] := [A × B, ⪯ ∠ ⊑]  (A is a set, ⪯ is a relation on A, B is a set, ⊑ is a relation on B with suitable conditions)

References.

* https://en.wikipedia.org/wiki/Ordinal_arithmetic#Multiplication
* https://mathworld.wolfram.com/OrdinalMultiplication.html
* https://proofwiki.org/wiki/Definition:Ordinal_Multiplication
* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal.type_mul"
`;

exports[`render hlm library: 1.7.3.13.1 Essentials/Numbers/Ordinal/Examples/omega 1`] = `
"Definition 1.7.3.13.1.  We define:

  ω := [ℕ, ≤]

References.

* https://en.wikipedia.org/wiki/Ordinal_number#Ordinals_extend_the_natural_numbers
* https://mathworld.wolfram.com/OrdinalNumber.html
* https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal.html#ordinal.omega"
`;

exports[`render hlm library: 1.7.3.14 Essentials/Numbers/Ordinal/cardinality 1`] = `
"Definition 1.7.3.14.  Let α be an ordinal number. We define:

  |α| := |(α)|"
`;

exports[`render hlm library: 1.7.3.15 Essentials/Numbers/Ordinal/finite 1`] = `
"Definition 1.7.3.15.  Let α be an ordinal number. We define:

  α is finite  :⇔  |α| is finite
    ⇔  (α) is finite
    ⇔  α ∈ ℕ

  α is infinite  :⇔  α is not finite

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.3.16 Essentials/Numbers/Ordinal/countable 1`] = `
"Definition 1.7.3.16.  Let α be an ordinal number. We define:

  α is countable  :⇔  |α| is countable
    ⇔  (α) is countable

  α is uncountable  :⇔  α is not countable

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.3.17 Essentials/Numbers/Ordinal/countably%20infinite 1`] = `
"Definition 1.7.3.17.  Let α be an ordinal number. We define:

  α is countably infinite  :⇔  α is countable and α is infinite
    ⇔  |α| is countably infinite
    ⇔  (α) is countably infinite

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.4.1 Essentials/Numbers/Integer/Integers 1`] = `
"Definition 1.7.4.1.  We define:

  ℤ :=: {(n-m) | n, m ∈ ℕ}

  (n-m) = (n'-m')  :⇔  n + m' = n' + m  (n, m ∈ ℕ, n', m' ∈ ℕ)

    Reflexivity.  No proof.

    Symmetry.  No proof.

    Transitivity.  No proof.

ℕ ⊆: ℤ via
x = (x-0)

  Well-definedness.  Let x, y ∈ ℕ such that (x-0) = (y-0). Then x = y:

  (x-0) = (y-0) ⇒^def x + 0 = y + 0
   ⇒^def x = y

Remarks.

This is essentially the standard definition of integers as equivalence classes of pairs of natural numbers. We just use a notation that highlights the role of the two numbers in each pair. This notation is later justified by \`$\\"Actual difference equals formal difference\\"\`).

Since an equality definition for each constructor is always part of a construction, we do not need to build the equivalence classes explicitly, they are implicit in the choice of the equality definition.

When defining a construction, another set can be embedded in the newly defined set, so in this case, we embed the natural numbers. Note that they are also embedded in the cardinal numbers.

References.

* https://en.wikipedia.org/wiki/Integer
* https://mathworld.wolfram.com/Integer.html
* https://proofwiki.org/wiki/Definition:Integer
* https://ncatlab.org/nlab/show/integer
* https://coq.inria.fr/library/Coq.ZArith.BinInt.html (but uses a different encoding as an inductive data type with three constructors)
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int (but uses a different encoding as an inductive data type with two constructors)"
`;

exports[`render hlm library: 1.7.4.2 Essentials/Numbers/Integer/sum 1`] = `
"Definition 1.7.4.2.  Let a, b ∈ ℤ. We define

  a + b

by:

  (n_a-m_a) + (n_b-m_b) := ((n_a + n_b)-(m_a + m_b))  (n_a, m_a ∈ ℕ, n_b, m_b ∈ ℕ)

Well-definedness.  No proof.

Remarks.

Note that the sums on the right are sums of natural numbers.

References.

* https://en.wikipedia.org/wiki/Integer#Construction
* https://proofwiki.org/wiki/Definition:Addition/Integers
* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.add
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.add"
`;

exports[`render hlm library: 1.7.4.3 Essentials/Numbers/Integer/Sum%20is%20associative 1`] = `
"Proposition 1.7.4.3.

  + is associative

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.add_assoc"
`;

exports[`render hlm library: 1.7.4.4 Essentials/Numbers/Integer/Sum%20is%20commutative 1`] = `
"Proposition 1.7.4.4.

  + is commutative

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.add_comm"
`;

exports[`render hlm library: 1.7.4.5 Essentials/Numbers/Integer/inverse 1`] = `
"Definition 1.7.4.5.  Let a ∈ ℤ. We define

  −a

by:

  −(n_a-m_a) := (m_a-n_a)  (n_a, m_a ∈ ℕ)

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.opp
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.neg"
`;

exports[`render hlm library: 1.7.4.6 Essentials/Numbers/Integer/difference 1`] = `
"Definition 1.7.4.6.  Let a, b ∈ ℤ. We define

  a − b

by:

  (n_a-m_a) − (n_b-m_b) := ((n_a + m_b)-(m_a + n_b))  (n_a, m_a ∈ ℕ, n_b, m_b ∈ ℕ)
   = a + (−b)

Equality.  No proof.

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.sub
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.has_sub"
`;

exports[`render hlm library: 1.7.4.7 Essentials/Numbers/Integer/Actual%20difference%20equals%20formal%20difference 1`] = `
"Proposition 1.7.4.7.  Let n, m ∈ ℕ. Then:

  (n-m) = n − m

No proof.

Remarks.

This proposition justifies the notation used for the constructor. Note that the subtraction on the right is subtraction in \`$Integers\`, using the embedding of the natural numbers \`m\` and \`n\` into the integers."
`;

exports[`render hlm library: 1.7.4.8 Essentials/Numbers/Integer/less%20or%20equal 1`] = `
"Definition 1.7.4.8.  Let a, b ∈ ℤ. We define

  a ≤ b

by:

  (n_a-m_a) ≤ (n_b-m_b)  :⇔  n_a + m_b ≤ n_b + m_a  (n_a, m_a ∈ ℕ, n_b, m_b ∈ ℕ)
    ⇔  ∃ x ∈ ℕ : a + x = b

Equivalence.  No proof.

Well-definedness.  No proof.

Remarks.

Note that the comparison on the right is comparison on natural numbers.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.leb"
`;

exports[`render hlm library: 1.7.4.9 Essentials/Numbers/Integer/less 1`] = `
"Definition 1.7.4.9.  Let a, b ∈ ℤ. We define:

  a < b  :⇔  a ≱ b
    ⇔  a + 1 ≤ b
    ⇔  a ≤ b and a ≠ b

Equivalence.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.ltb"
`;

exports[`render hlm library: 1.7.4.10.1 Essentials/Numbers/Integer/Subsets/Segment%20(less) 1`] = `
"Definition 1.7.4.10.1.  Let a ∈ ℤ. We define:

  ℤ_(<a) := {b ∈ ℤ : b < a}"
`;

exports[`render hlm library: 1.7.4.10.2 Essentials/Numbers/Integer/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.7.4.10.2.  Let a ∈ ℤ. We define:

  ℤ_(≤a) := {b ∈ ℤ : b ≤ a}
   = ℤ_(<(a+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.3 Essentials/Numbers/Integer/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.7.4.10.3.  Let a ∈ ℤ. We define:

  ℤ_(≥a) := {b ∈ ℤ : b ≥ a}
   = ℤ ∖ ℤ_(<a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.4 Essentials/Numbers/Integer/Subsets/Segment%20(greater) 1`] = `
"Definition 1.7.4.10.4.  Let a ∈ ℤ. We define:

  ℤ_(>a) := {b ∈ ℤ : b > a}
   = ℤ ∖ ℤ_(≤a)
   = ℤ_(≥(a+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.5 Essentials/Numbers/Integer/Subsets/Hole 1`] = `
"Definition 1.7.4.10.5.  Let a ∈ ℤ. We define:

  ℤ_(≠a) := {b ∈ ℤ : b ≠ a}
   = ℤ_(<a) ∪ ℤ_(>a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.6 Essentials/Numbers/Integer/Subsets/Negative%20numbers 1`] = `
"Definition 1.7.4.10.6.  We define:

  ℤ_− := ℤ_(<0)
   = {a ∈ ℤ : a < 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.7 Essentials/Numbers/Integer/Subsets/Nonpositive%20numbers 1`] = `
"Definition 1.7.4.10.7.  We define:

  ℤ_0^− := ℤ_(≤0)
   = {a ∈ ℤ : a ≤ 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.8 Essentials/Numbers/Integer/Subsets/Nonnegative%20numbers 1`] = `
"Definition 1.7.4.10.8.  We define:

  ℤ_0^+ := ℤ_(≥0)
   = {a ∈ ℤ : a ≥ 0}
   = ℕ

Equality.  No proof.

Remarks.

Due to the embedding of \`$../../Natural/\\"Natural numbers\\"\` into \`$../Integers\`, this is just an alias for \`$../../Natural/\\"Natural numbers\\"\`."
`;

exports[`render hlm library: 1.7.4.10.9 Essentials/Numbers/Integer/Subsets/Positive%20numbers 1`] = `
"Definition 1.7.4.10.9.  We define:

  ℤ_+ := ℤ_(>0)
   = {a ∈ ℤ : a > 0}
   = ℕ_+

Equality.  No proof.

Remarks.

Due to the embedding of \`$../../Natural/\\"Natural numbers\\"\` into \`$../Integers\`, this is just an alias for \`$../../Natural/Subsets/\\"Positive numbers\\"\`."
`;

exports[`render hlm library: 1.7.4.10.10 Essentials/Numbers/Integer/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.7.4.10.10.  We define:

  ℤ_± := ℤ_(≠0)
   = {a ∈ ℤ : a ≠ 0}
   = ℤ_− ∪ ℤ_+

Equality.  No proof."
`;

exports[`render hlm library: 1.7.4.10.11 Essentials/Numbers/Integer/Subsets/Interval 1`] = `
"Definition 1.7.4.10.11.  Let a, b ∈ ℤ. We define:

  {a, ..., b} := {c ∈ ℤ : a ≤ c ≤ b}"
`;

exports[`render hlm library: 1.7.4.10.12 Essentials/Numbers/Integer/Subsets/Multiples 1`] = `
"Definition 1.7.4.10.12.  Let n ∈ ℕ. We define:

  nℤ := {n ⋅ z : z ∈ ℤ}"
`;

exports[`render hlm library: 1.7.4.11 Essentials/Numbers/Integer/absolute 1`] = `
"Definition 1.7.4.11.  Let a ∈ ℤ. We define:

  |a| := {a if a ≥ 0, −a if a < 0

References.

* https://en.wikipedia.org/wiki/Absolute_value
* https://mathworld.wolfram.com/AbsoluteValue.html
* https://proofwiki.org/wiki/Definition:Absolute_Value
* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.abs
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.nat_abs"
`;

exports[`render hlm library: 1.7.4.12 Essentials/Numbers/Integer/product 1`] = `
"Definition 1.7.4.12.  Let a, b ∈ ℤ. We define

  a ⋅ b

by:

  (n_a-m_a) ⋅ (n_b-m_b) := ((n_a ⋅ n_b + m_a ⋅ m_b)-(n_a ⋅ m_b + m_a ⋅ n_b))  (n_a, m_a ∈ ℕ, n_b, m_b ∈ ℕ)

Well-definedness.  No proof.

Remarks.

Note that the sums and products on the right are operations on natural numbers.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.mul
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.mul"
`;

exports[`render hlm library: 1.7.4.13 Essentials/Numbers/Integer/Product%20is%20associative 1`] = `
"Proposition 1.7.4.13.

  ⋅ is associative

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.mul_assoc"
`;

exports[`render hlm library: 1.7.4.14 Essentials/Numbers/Integer/Product%20is%20commutative 1`] = `
"Proposition 1.7.4.14.

  ⋅ is commutative

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.mul_comm"
`;

exports[`render hlm library: 1.7.4.15 Essentials/Numbers/Integer/divisible 1`] = `
"Definition 1.7.4.15.  Let a ∈ ℤ_±, b ∈ ℤ. We define:

  a ∣ b  :⇔  ∃ x ∈ ℤ : a ⋅ x = b
    ⇔  |a| ∣ |b|

Equivalence.  No proof."
`;

exports[`render hlm library: 1.7.4.16 Essentials/Numbers/Integer/Divisors 1`] = `
"Definition 1.7.4.16.  Let b ∈ ℤ. We define:

  Div_ℤ(b) := {a ∈ ℤ_± : a ∣ b}"
`;

exports[`render hlm library: 1.7.4.17 Essentials/Numbers/Integer/quotient 1`] = `
"Definition 1.7.4.17.  Let a ∈ ℤ, b ∈ Div_ℤ(a). For x ∈ ℤ, we define:

  a∕b = x  :⇔  a = x ⋅ b

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.div (truncated division, thus incompatible with division of rational numbers)
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.div (ditto)"
`;

exports[`render hlm library: 1.7.4.18 Essentials/Numbers/Integer/power 1`] = `
"Definition 1.7.4.18.  Let a ∈ ℤ, n ∈ ℕ. We define

  a^n

by:

  a^0 := 1
  a^(x+1) := a^x ⋅ a  (x ∈ ℕ)

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.pow
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.pow"
`;

exports[`render hlm library: 1.7.4.19 Essentials/Numbers/Integer/Addition%20of%20a%20fixed%20number%20is%20injective 1`] = `
"Proposition 1.7.4.19.  Let a, b, c ∈ ℤ such that a + c = b + c. Then:

  a = b

No proof."
`;

exports[`render hlm library: 1.7.4.20 Essentials/Numbers/Integer/Multiplication%20of%20a%20nonzero%20number%20is%20injective 1`] = `
"Proposition 1.7.4.20.  Let a, b ∈ ℤ, c ∈ ℤ_± such that a ⋅ c = b ⋅ c. Then:

  a = b

No proof."
`;

exports[`render hlm library: 1.7.4.21 Essentials/Numbers/Integer/Power%20base%20product%20law 1`] = `
"Proposition 1.7.4.21.  Let a, b ∈ ℤ, n ∈ ℕ. Then:

  (a ⋅ b)^n = a^n ⋅ b^n

No proof."
`;

exports[`render hlm library: 1.7.4.22.1 Essentials/Numbers/Integer/Iterated%20operators/iterated%20sum 1`] = `
"Definition 1.7.4.22.1.  We define:

  ∑ := [0 + ⋅⋅⋅] is an iterated operation on ℤ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../Integers, ⨂ = $\\"iterated sum\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.7.4.22.2 Essentials/Numbers/Integer/Iterated%20operators/iterated%20product 1`] = `
"Definition 1.7.4.22.2.  We define:

  ∏ := [1 ⋅ ⋅⋅⋅] is an iterated operation on ℤ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../Integers, ⨂ = $\\"iterated product\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 1.7.4.23.1 Essentials/Numbers/Integer/Prime/Prime%20and%20power%20divisibility%20criterion 1`] = `
"Proposition 1.7.4.23.1.  Let p be a prime, a ∈ ℤ, n ∈ ℕ_+. Then the following are equivalent:

  1. p ∣ a
  2. p ∣ a^n
  3. p^n ∣ a^n

No proof."
`;

exports[`render hlm library: 1.7.4.24 Essentials/Numbers/Integer/coprime 1`] = `
"Definition 1.7.4.24.  Let a, b ∈ ℤ. We define:

  a and b are coprime  :⇔  ∀ c ∈ ℤ_+ s.t. c ∣ a and c ∣ b : c = 1
    ⇔  ∄ d ∈ ℤ_(>1) : [d ∣ a and d ∣ b]
    ⇔  ∀ e ∈ ℤ_± s.t. e ∣ a and e ∣ b : |e| = 1
    ⇔  Div_ℤ(a) ∩ Div_ℤ(b) ⊆ {1, −1}
    ⇔  Div_ℤ(a) ∩ Div_ℤ(b) = {1, −1}
    ⇔  ∄ prime p : [p ∣ a and p ∣ b]
    ⇔  |a| and |b| are coprime

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Coprime_integers
* https://mathworld.wolfram.com/RelativelyPrime.html
* https://proofwiki.org/wiki/Definition:Coprime/Integers
* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#rel_prime"
`;

exports[`render hlm library: 1.7.5.1 Essentials/Numbers/Rational/Rational%20numbers 1`] = `
"Definition 1.7.5.1.  We define:

  ℚ :=: {(n/d) | n ∈ ℤ, d ∈ ℕ_+}

  (n/d) = (n'/d')  :⇔  n ⋅ d' = n' ⋅ d  (n ∈ ℤ, d ∈ ℕ_+, n' ∈ ℤ, d' ∈ ℕ_+)

    Reflexivity.  No proof.

    Symmetry.  No proof.

    Transitivity.  No proof.

ℤ ⊆: ℚ via
x = (x/1)

  Well-definedness.  No proof.

Remarks.

This definition is rather similar to \`$../Integer/Integers\`. The constructor notation is later justified by \`$\\"Actual quotient equals formal quotient\\"\`.

Note that in the constructor, we force the denominator to be positive. This is not required at this point, since the given equality definition would also work for negative numbers. However, if the denominator was allowed to be negative, the definition of \`$\\"less or equal\\"\` would probably need to be split into several cases.

References.

* https://en.wikipedia.org/wiki/Rational_number
* https://mathworld.wolfram.com/RationalNumber.html
* https://proofwiki.org/wiki/Definition:Rational_Number
* https://ncatlab.org/nlab/show/rational+number
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Q (together with https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qeq)
* https://leanprover-community.github.io/mathlib_docs/data/rat/basic.html#rat (but uses coprimality requirement instead of equivalence relation)"
`;

exports[`render hlm library: 1.7.5.2 Essentials/Numbers/Rational/sum 1`] = `
"Definition 1.7.5.2.  Let a, b ∈ ℚ. We define

  a + b

by:

  (n_a/d_a) + (n_b/d_b) := ((n_a ⋅ d_b + n_b ⋅ d_a)/(d_a ⋅ d_b))  (n_a ∈ ℤ, d_a ∈ ℕ_+, n_b ∈ ℤ, d_b ∈ ℕ_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Addition
* https://proofwiki.org/wiki/Definition:Addition/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qplus
* https://leanprover-community.github.io/mathlib_docs/data/rat/basic.html#rat.add"
`;

exports[`render hlm library: 1.7.5.3 Essentials/Numbers/Rational/inverse 1`] = `
"Definition 1.7.5.3.  Let a ∈ ℚ. We define

  −a

by:

  −(n_a/d_a) := ((−n_a)/d_a)  (n_a ∈ ℤ, d_a ∈ ℕ_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Inverse
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qopp
* https://leanprover-community.github.io/mathlib_docs/data/rat/basic.html#rat.neg"
`;

exports[`render hlm library: 1.7.5.4 Essentials/Numbers/Rational/difference 1`] = `
"Definition 1.7.5.4.  Let a, b ∈ ℚ. We define

  a − b

by:

  (n_a/d_a) − (n_b/d_b) := ((n_a ⋅ d_b − n_b ⋅ d_a)/(d_a ⋅ d_b))  (n_a ∈ ℤ, d_a ∈ ℕ_+, n_b ∈ ℤ, d_b ∈ ℕ_+)
   = a + (−b)

Equality.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Subtraction
* https://proofwiki.org/wiki/Definition:Subtraction/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qminus
* https://leanprover-community.github.io/mathlib_docs/data/rat/basic.html#rat.sub_def"
`;

exports[`render hlm library: 1.7.5.5 Essentials/Numbers/Rational/less%20or%20equal 1`] = `
"Definition 1.7.5.5.  Let a, b ∈ ℚ. We define

  a ≤ b

by:

  (n_a/d_a) ≤ (n_b/d_b)  :⇔  n_a ⋅ d_b ≤ n_b ⋅ d_a  (n_a ∈ ℤ, d_a ∈ ℕ_+, n_b ∈ ℤ, d_b ∈ ℕ_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Ordering
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qle
* https://leanprover-community.github.io/mathlib_docs/data/rat/order.html#rat.le"
`;

exports[`render hlm library: 1.7.5.6 Essentials/Numbers/Rational/less 1`] = `
"Definition 1.7.5.6.  Let a, b ∈ ℚ. We define:

  a < b  :⇔  a ≱ b
    ⇔  a ≤ b and a ≠ b

Equivalence.  No proof.

References.

* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qlt
* https://leanprover-community.github.io/mathlib_docs/data/rat/order.html#rat.lt_def"
`;

exports[`render hlm library: 1.7.5.7.1 Essentials/Numbers/Rational/Subsets/Segment%20(less) 1`] = `
"Definition 1.7.5.7.1.  Let a ∈ ℚ. We define:

  ℚ_(<a) := {b ∈ ℚ : b < a}"
`;

exports[`render hlm library: 1.7.5.7.2 Essentials/Numbers/Rational/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.7.5.7.2.  Let a ∈ ℚ. We define:

  ℚ_(≤a) := {b ∈ ℚ : b ≤ a}"
`;

exports[`render hlm library: 1.7.5.7.3 Essentials/Numbers/Rational/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.7.5.7.3.  Let a ∈ ℚ. We define:

  ℚ_(≥a) := {b ∈ ℚ : b ≥ a}
   = ℚ ∖ ℚ_(<a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.7.4 Essentials/Numbers/Rational/Subsets/Segment%20(greater) 1`] = `
"Definition 1.7.5.7.4.  Let a ∈ ℚ. We define:

  ℚ_(>a) := {b ∈ ℚ : b > a}
   = ℚ ∖ ℚ_(≤a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.7.5 Essentials/Numbers/Rational/Subsets/Hole 1`] = `
"Definition 1.7.5.7.5.  Let a ∈ ℚ. We define:

  ℚ_(≠a) := {b ∈ ℚ : b ≠ a}
   = ℚ_(<a) ∪ ℚ_(>a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.7.6 Essentials/Numbers/Rational/Subsets/Negative%20numbers 1`] = `
"Definition 1.7.5.7.6.  We define:

  ℚ_− := ℚ_(<0)
   = {a ∈ ℚ : a < 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.7.7 Essentials/Numbers/Rational/Subsets/Nonpositive%20numbers 1`] = `
"Definition 1.7.5.7.7.  We define:

  ℚ_0^− := ℚ_(≤0)
   = {a ∈ ℚ : a ≤ 0}

Equality.  No proof.

References.

* https://proofwiki.org/wiki/Definition:Negative/Rational_Number"
`;

exports[`render hlm library: 1.7.5.7.8 Essentials/Numbers/Rational/Subsets/Nonnegative%20numbers 1`] = `
"Definition 1.7.5.7.8.  We define:

  ℚ_0^+ := ℚ_(≥0)
   = {a ∈ ℚ : a ≥ 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.7.9 Essentials/Numbers/Rational/Subsets/Positive%20numbers 1`] = `
"Definition 1.7.5.7.9.  We define:

  ℚ_+ := ℚ_(>0)
   = {a ∈ ℚ : a > 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.7.10 Essentials/Numbers/Rational/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.7.5.7.10.  We define:

  ℚ_± := ℚ_(≠0)
   = {a ∈ ℚ : a ≠ 0}
   = ℚ_− ∪ ℚ_+

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.8 Essentials/Numbers/Rational/absolute 1`] = `
"Definition 1.7.5.8.  Let a ∈ ℚ. We define:

  |a| := {a if a ≥ 0, −a if a < 0

References.

* https://en.wikipedia.org/wiki/Absolute_value
* https://mathworld.wolfram.com/AbsoluteValue.html
* https://proofwiki.org/wiki/Definition:Absolute_Value
* https://coq.inria.fr/library/Coq.QArith.Qabs.html
* https://leanprover-community.github.io/mathlib_docs/data/rat/order.html#rat.abs_def"
`;

exports[`render hlm library: 1.7.5.9 Essentials/Numbers/Rational/product 1`] = `
"Definition 1.7.5.9.  Let a, b ∈ ℚ. We define

  a ⋅ b

by:

  (n_a/d_a) ⋅ (n_b/d_b) := ((n_a ⋅ n_b)/(d_a ⋅ d_b))  (n_a ∈ ℤ, d_a ∈ ℕ_+, n_b ∈ ℤ, d_b ∈ ℕ_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Multiplication
* https://proofwiki.org/wiki/Definition:Multiplication/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qmult
* https://leanprover-community.github.io/mathlib_docs/data/rat/basic.html#rat.mul"
`;

exports[`render hlm library: 1.7.5.10 Essentials/Numbers/Rational/quotient 1`] = `
"Definition 1.7.5.10.  Let a ∈ ℚ, b ∈ ℚ_±. For x ∈ ℚ, we define:

  a∕b = x  :⇔  a = x ⋅ b

Well-definedness.  No proof.

Remarks.

Although it is possible to specify an explicit definition for the division of rational numbers, that definition is not quite as straightforward as one would like because in our definition of rational numbers as pairs of a numerator and a denominator, we force the denominator to be positive.

References.

* https://en.wikipedia.org/wiki/Rational_number#Division
* https://proofwiki.org/wiki/Definition:Division/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qdiv"
`;

exports[`render hlm library: 1.7.5.11 Essentials/Numbers/Rational/Actual%20quotient%20equals%20formal%20quotient 1`] = `
"Proposition 1.7.5.11.  Let n ∈ ℤ, d ∈ ℕ_+. Then:

  (n/d) = n∕d

No proof.

Remarks.

This proposition justifies the notation used for the constructor. Note that the division on the right is division in \`$\\"Rational numbers\\"\`, using the embedding of the integers \`n\` and \`d\` into the rational numbers."
`;

exports[`render hlm library: 1.7.5.12 Essentials/Numbers/Rational/power 1`] = `
"Definition 1.7.5.12.  Let a ∈ ℚ, n ∈ ℕ. We define

  a^n

by:

  a^0 := 1
  a^(x+1) := a^x ⋅ a  (x ∈ ℕ)

References.

* https://en.wikipedia.org/wiki/Rational_number#Exponentiation_to_integer_power
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qpower_positive
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.pow"
`;

exports[`render hlm library: 1.7.5.13 Essentials/Numbers/Rational/power%20to%20integer 1`] = `
"Definition 1.7.5.13.  Let a ∈ ℚ, b ∈ ℤ such that a ≠ 0 or b ≥ 0. We define:

  a^b := {a^b if b ≥ 0, 1∕a^(−b) if b < 0

Remarks.

The exponentiation on the right uses the previous definition, which is possible because the exponents are nonnegative.

References.

* https://en.wikipedia.org/wiki/Rational_number#Exponentiation_to_integer_power
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qpower
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#gpow"
`;

exports[`render hlm library: 1.7.5.14.1 Essentials/Numbers/Rational/Iterated%20operators/iterated%20sum 1`] = `
"Definition 1.7.5.14.1.  We define:

  ∑ := [0 + ⋅⋅⋅] is an iterated operation on ℚ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Rational numbers\\", ⨂ = $\\"iterated sum\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.7.5.14.2 Essentials/Numbers/Rational/Iterated%20operators/iterated%20product 1`] = `
"Definition 1.7.5.14.2.  We define:

  ∏ := [1 ⋅ ⋅⋅⋅] is an iterated operation on ℚ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Rational numbers\\", ⨂ = $\\"iterated product\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 1.7.5.15.1 Essentials/Numbers/Rational/Sequences/converges 1`] = `
"Definition 1.7.5.15.1.  Let 𝐚 be a sequence on ℚ, l ∈ ℚ. We define

  𝐚 converges to l

by:

  (a_n)_(n ∈ ℕ) converges to l  :⇔  ∀ ε ∈ ℚ_+ : ∃ n ∈ ℕ : ∀ m ∈ ℕ_(≥n) : |a_m − l| < ε  (a_n ∈ ℚ for each n ∈ ℕ)

  𝐚 does not converge to l  :⇔  not [𝐚 converges to l]

References.

* https://en.wikipedia.org/wiki/Limit_of_a_sequence
* https://mathworld.wolfram.com/ConvergentSequence.html
* https://proofwiki.org/wiki/Definition:Convergent_Sequence/Normed_Division_Ring
* https://ncatlab.org/nlab/show/convergence"
`;

exports[`render hlm library: 1.7.5.15.2 Essentials/Numbers/Rational/Sequences/convergent 1`] = `
"Definition 1.7.5.15.2.  Let 𝐚 be a sequence on ℚ. We define:

  𝐚 is convergent  :⇔  ∃ l ∈ ℚ : 𝐚 converges to l

  𝐚 is divergent  :⇔  𝐚 is not convergent"
`;

exports[`render hlm library: 1.7.5.15.3 Essentials/Numbers/Rational/Sequences/limit 1`] = `
"Definition 1.7.5.15.3.  Let a_n ∈ ℚ for each n ∈ ℕ, let 𝐚 := (a_m)_(m ∈ ℕ), assume 𝐚 is convergent. For l ∈ ℚ, we define:

  lim_(n → ∞) a_n = l  :⇔  𝐚 converges to l

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Limit_of_a_sequence
* https://mathworld.wolfram.com/Limit.html
* https://proofwiki.org/wiki/Definition:Limit_of_Sequence/Normed_Division_Ring
* https://ncatlab.org/nlab/show/convergence"
`;

exports[`render hlm library: 1.7.5.15.4 Essentials/Numbers/Rational/Sequences/cauchy 1`] = `
"Definition 1.7.5.15.4.  Let 𝐚 be a sequence on ℚ. We define

  𝐚 is Cauchy

by:

  (a_n)_(n ∈ ℕ) is Cauchy  :⇔  ∀ ε ∈ ℚ_+ : ∃ n ∈ ℕ : ∀ l, m ∈ ℕ_(≥n) : |a_l − a_m| < ε  (a_n ∈ ℚ for each n ∈ ℕ)

References.

* https://en.wikipedia.org/wiki/Cauchy_sequence
* https://mathworld.wolfram.com/CauchySequence.html
* https://proofwiki.org/wiki/Definition:Cauchy_Sequence
* https://ncatlab.org/nlab/show/Cauchy+sequence
* https://leanprover-community.github.io/mathlib_docs/data/real/cau_seq.html#is_cau_seq"
`;

exports[`render hlm library: 1.7.5.15.5 Essentials/Numbers/Rational/Sequences/sequence%20sum 1`] = `
"Definition 1.7.5.15.5.  Let 𝐚, 𝐛 be sequences on ℚ. We define

  𝐚 + 𝐛

by:

  (a_n)_(n ∈ ℕ) + (b_n)_(n ∈ ℕ) := (a_n + b_n)_(n ∈ ℕ)  (a_n ∈ ℚ for each n ∈ ℕ, b_n ∈ ℚ for each n ∈ ℕ)"
`;

exports[`render hlm library: 1.7.5.15.6 Essentials/Numbers/Rational/Sequences/sequence%20inverse 1`] = `
"Definition 1.7.5.15.6.  Let 𝐚 be a sequence on ℚ. We define

  −𝐚

by:

  −(a_n)_(n ∈ ℕ) := (−a_n)_(n ∈ ℕ)  (a_n ∈ ℚ for each n ∈ ℕ)"
`;

exports[`render hlm library: 1.7.5.15.7 Essentials/Numbers/Rational/Sequences/sequence%20difference 1`] = `
"Definition 1.7.5.15.7.  Let 𝐚, 𝐛 be sequences on ℚ. We define

  𝐚 − 𝐛

by:

  (a_n)_(n ∈ ℕ) − (b_n)_(n ∈ ℕ) := (a_n − b_n)_(n ∈ ℕ)  (a_n ∈ ℚ for each n ∈ ℕ, b_n ∈ ℚ for each n ∈ ℕ)
   = 𝐚 + (−𝐛)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.5.15.8 Essentials/Numbers/Rational/Sequences/sequence%20product 1`] = `
"Definition 1.7.5.15.8.  Let 𝐚, 𝐛 be sequences on ℚ. We define

  𝐚 ⋅ 𝐛

by:

  (a_n)_(n ∈ ℕ) ⋅ (b_n)_(n ∈ ℕ) := (a_n ⋅ b_n)_(n ∈ ℕ)  (a_n ∈ ℚ for each n ∈ ℕ, b_n ∈ ℚ for each n ∈ ℕ)"
`;

exports[`render hlm library: 1.7.6.1 Essentials/Numbers/Real/Real%20numbers 1`] = `
"Definition 1.7.6.1.  We define:

  ℝ :=: {[r] | r is a Cauchy sequence on ℚ}

  [r] = [r']  :⇔  r − r' converges to 0  (r is a sequence on ℚ, r' is a sequence on ℚ with suitable conditions)

    Reflexivity.  No proof.

    Symmetry.  No proof.

    Transitivity.  No proof.

ℚ ⊆: ℝ via
x = [(x)_(k ∈ ℕ)]

  Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Real_number
* https://mathworld.wolfram.com/RealNumber.html
* https://proofwiki.org/wiki/Definition:Real_Number
* https://ncatlab.org/nlab/show/real+number
* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyReals.html#CReal
* https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real"
`;

exports[`render hlm library: 1.7.6.2 Essentials/Numbers/Real/sum 1`] = `
"Definition 1.7.6.2.  Let a, b ∈ ℝ. We define

  a + b

by:

  [r_a] + [r_b] := [r_a + r_b]  (r_a is a sequence on ℚ, r_b is a sequence on ℚ with suitable conditions)

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyReals.html#CReal_plus"
`;

exports[`render hlm library: 1.7.6.3 Essentials/Numbers/Real/inverse 1`] = `
"Definition 1.7.6.3.  Let a ∈ ℝ. We define

  −a

by:

  −[r_a] := [−r_a]  (r_a is a Cauchy sequence on ℚ)

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyReals.html#CReal_opp"
`;

exports[`render hlm library: 1.7.6.4 Essentials/Numbers/Real/difference 1`] = `
"Definition 1.7.6.4.  Let a, b ∈ ℝ. We define

  a − b

by:

  [r_a] − [r_b] := [r_a − r_b]  (r_a is a sequence on ℚ, r_b is a sequence on ℚ with suitable conditions)
   = a + (−b)

Equality.  No proof.

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyReals.html#CReal_minus"
`;

exports[`render hlm library: 1.7.6.5 Essentials/Numbers/Real/less%20or%20equal 1`] = `
"Definition 1.7.6.5.  Let a, b ∈ ℝ. We define

  a ≤ b

by:

  [(x_n)_(n ∈ ℕ)] ≤ [(y_n)_(n ∈ ℕ)]  :⇔  ∀ ε ∈ ℚ_+ : ∃ n ∈ ℕ : ∀ m ∈ ℕ_(≥n) : x_m ≤ y_m + ε  ((x_n)_(n ∈ ℕ) is a sequence on ℚ, (y_n)_(n ∈ ℕ) is a sequence on ℚ with suitable conditions)

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyReals.html#CRealLe
* https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real.le"
`;

exports[`render hlm library: 1.7.6.6 Essentials/Numbers/Real/less 1`] = `
"Definition 1.7.6.6.  Let a, b ∈ ℝ. We define:

  a < b  :⇔  a ≱ b
    ⇔  a ≤ b and a ≠ b

Equivalence.  No proof.

References.

* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyReals.html#CRealLt
* https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real.has_lt"
`;

exports[`render hlm library: 1.7.6.7.1 Essentials/Numbers/Real/Subsets/Segment%20(less) 1`] = `
"Definition 1.7.6.7.1.  Let a ∈ ℝ. We define:

  ℝ_(<a) := {b ∈ ℝ : b < a}"
`;

exports[`render hlm library: 1.7.6.7.2 Essentials/Numbers/Real/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.7.6.7.2.  Let a ∈ ℝ. We define:

  ℝ_(≤a) := {b ∈ ℝ : b ≤ a}"
`;

exports[`render hlm library: 1.7.6.7.3 Essentials/Numbers/Real/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.7.6.7.3.  Let a ∈ ℝ. We define:

  ℝ_(≥a) := {b ∈ ℝ : b ≥ a}
   = ℝ ∖ ℝ_(<a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.4 Essentials/Numbers/Real/Subsets/Segment%20(greater) 1`] = `
"Definition 1.7.6.7.4.  Let a ∈ ℝ. We define:

  ℝ_(>a) := {b ∈ ℝ : b > a}
   = ℝ ∖ ℝ_(≤a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.5 Essentials/Numbers/Real/Subsets/Hole 1`] = `
"Definition 1.7.6.7.5.  Let a ∈ ℝ. We define:

  ℝ_(≠a) := {b ∈ ℝ : b ≠ a}
   = ℝ_(<a) ∪ ℝ_(>a)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.6 Essentials/Numbers/Real/Subsets/Negative%20numbers 1`] = `
"Definition 1.7.6.7.6.  We define:

  ℝ_− := ℝ_(<0)
   = {a ∈ ℝ : a < 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.7 Essentials/Numbers/Real/Subsets/Nonpositive%20numbers 1`] = `
"Definition 1.7.6.7.7.  We define:

  ℝ_0^− := ℝ_(≤0)
   = {a ∈ ℝ : a ≤ 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.8 Essentials/Numbers/Real/Subsets/Nonnegative%20numbers 1`] = `
"Definition 1.7.6.7.8.  We define:

  ℝ_0^+ := ℝ_(≥0)
   = {a ∈ ℝ : a ≥ 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.9 Essentials/Numbers/Real/Subsets/Positive%20numbers 1`] = `
"Definition 1.7.6.7.9.  We define:

  ℝ_+ := ℝ_(>0)
   = {a ∈ ℝ : a > 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.7.10 Essentials/Numbers/Real/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.7.6.7.10.  We define:

  ℝ_± := ℝ_(≠0)
   = {a ∈ ℝ : a ≠ 0}
   = ℝ_− ∪ ℝ_+

Equality.  No proof."
`;

exports[`render hlm library: 1.7.6.8 Essentials/Numbers/Real/product 1`] = `
"Definition 1.7.6.8.  Let a, b ∈ ℝ. We define

  a ⋅ b

by:

  [r_a] ⋅ [r_b] := [r_a ⋅ r_b]  (r_a is a sequence on ℚ, r_b is a sequence on ℚ with suitable conditions)

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.Reals.Cauchy.ConstructiveCauchyRealsMult.html#CReal_mult"
`;

exports[`render hlm library: 1.7.6.9 Essentials/Numbers/Real/quotient 1`] = `
"Definition 1.7.6.9.  Let a ∈ ℝ, b ∈ ℝ_±. For x ∈ ℝ, we define:

  a∕b = x  :⇔  a = x ⋅ b

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.7.6.10 Essentials/Numbers/Real/power 1`] = `
"Definition 1.7.6.10.  Let a ∈ ℝ, n ∈ ℕ. We define

  a^n

by:

  a^0 := 1
  a^(x+1) := a^x ⋅ a  (x ∈ ℕ)"
`;

exports[`render hlm library: 1.7.6.11 Essentials/Numbers/Real/power%20to%20integer 1`] = `
"Definition 1.7.6.11.  Let a ∈ ℝ, b ∈ ℤ such that a ≠ 0 or b ≥ 0. We define:

  a^b := {a^b if b ≥ 0, 1∕a^(−b) if b < 0"
`;

exports[`render hlm library: 1.7.6.12 Essentials/Numbers/Real/Power%20base%20product%20law 1`] = `
"Proposition 1.7.6.12.  Let a, b ∈ ℝ, n ∈ ℕ. Then:

  (a ⋅ b)^n = a^n ⋅ b^n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#mul_pow"
`;

exports[`render hlm library: 1.7.6.13 Essentials/Numbers/Real/Power%20base%20quotient%20law 1`] = `
"Proposition 1.7.6.13.  Let b ∈ ℝ, a ∈ ℝ_±, n ∈ ℕ_+. Then:

  (b∕a)^n = b^n∕a^n

No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#div_pow"
`;

exports[`render hlm library: 1.7.6.14 Essentials/Numbers/Real/root 1`] = `
"Definition 1.7.6.14.  Let a ∈ ℝ_0^+, n ∈ ℕ. For r ∈ ℝ_0^+, we define:

  n√a = r  :⇔  a = r^n

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.7.6.15 Essentials/Numbers/Real/square%20root 1`] = `
"Definition 1.7.6.15.  Let a ∈ ℝ_0^+. We define:

  √a := 2√a

References.

* https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real.sqrt"
`;

exports[`render hlm library: 1.7.6.16 Essentials/Numbers/Real/rational 1`] = `
"Definition 1.7.6.16.  Let a ∈ ℝ. We define:

  a is rational  :⇔  a ∈ ℚ
    ⇔  ∃ b ∈ ℤ_±, c ∈ ℤ : a = c∕b
    ⇔  ∃! d ∈ ℤ_+, e ∈ ℤ s.t. d and e are coprime : a = e∕d

  a is irrational  :⇔  a is not rational

Equivalence.  No proof.

References.

* https://leanprover-community.github.io/mathlib_docs/data/real/irrational.html#irrational"
`;

exports[`render hlm library: 1.7.6.17.1 Essentials/Numbers/Real/Iterated%20operators/iterated%20sum 1`] = `
"Definition 1.7.6.17.1.  We define:

  ∑ := [0 + ⋅⋅⋅] is an iterated operation on ℝ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Real numbers\\", ⨂ = $\\"iterated sum\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.7.6.17.2 Essentials/Numbers/Real/Iterated%20operators/iterated%20product 1`] = `
"Definition 1.7.6.17.2.  We define:

  ∏ := [1 ⋅ ⋅⋅⋅] is an iterated operation on ℝ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Real numbers\\", ⨂ = $\\"iterated product\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 1.7.6.18 Essentials/Numbers/Real/Roots%20of%20primes%20are%20irrational 1`] = `
"Theorem 1.7.6.18.  Let p be a prime, n ∈ ℕ_(>1). Then:

  n√p is irrational

Proof.  Assume n√p is rational.

 ⇒^def ∃ a ∈ ℤ_+, b ∈ ℤ s.t. a and b are coprime : n√p = b∕a

 ⇒^def p = (b∕a)^n
 =^1.7.6.13 b^n∕a^n

 ⇒^def p ⋅ a^n = b^n
 ⇒ p ∣ b^n by definition
 ⇒^1.7.4.23.1 p ∣ b
 ⇒ p ∣ a^n:

  We show that ∃ y ∈ ℤ : p ⋅ y = a^n:

  p ∣ b ⇒^def ∃ z ∈ ℤ : p ⋅ z = b

  n ∈ ℕ_(>1) ⇒^def ∃ m ∈ ℕ : 2 + m = n

  Choose y := b^m ⋅ z ⋅ z. We show that p ⋅ (b^m ⋅ z ⋅ z) = a^n:

    p ⋅ a^n = b^n
     = b^(2+m)
     =^def b^m ⋅ b ⋅ b
     = b^m ⋅ p ⋅ z ⋅ p ⋅ z

     ⇒^1.7.4.20 a^n = b^m ⋅ z ⋅ p ⋅ z

 ⇒^1.7.4.23.1 p ∣ a

p ∣ a and p ∣ b ⇒ a and b are not coprime by definition ⭍

References.

* https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational (for \`n\` = 2)
* https://isabelle.in.tum.de/website-Isabelle2012/dist/library/HOL/ex/Sqrt.html (for \`n\` = 2)
* https://leanprover-community.github.io/mathlib_docs/data/real/irrational.html#irr_sqrt_of_prime (for \`n\` = 2)"
`;

exports[`render hlm library: 1.7.6.19 Essentials/Numbers/Real/Square%20root%20of%20two%20is%20irrational 1`] = `
"Corollary 1.7.6.19.

  √2 is irrational

Proof.

1.7.1.50.2 ⇒ 2 is prime

1.7.6.18 ⇒ 2√2 is irrational

References.

* https://leanprover-community.github.io/mathlib_docs/data/real/irrational.html#irr_sqrt_two"
`;

exports[`render hlm library: 1.7.7.1 Essentials/Numbers/Complex/Complex%20numbers 1`] = `
"Definition 1.7.7.1.  We define:

  ℂ :=: {(r+i𝒊) | r, i ∈ ℝ}

  (r+i𝒊) = (r'+i'𝒊)  :⇔  r = r' and i = i'  (r, i ∈ ℝ, r', i' ∈ ℝ)

ℝ ⊆: ℂ via
r = (r+0𝒊)

  Well-definedness.  No proof.

Remarks.

The constructor notation is later justified by \`$\\"Actual linear combination equals formal linear combination\\"\`.

References.

* https://en.wikipedia.org/wiki/Complex_numbers
* https://mathworld.wolfram.com/ComplexNumber.html
* https://proofwiki.org/wiki/Definition:Complex_Number
* https://ncatlab.org/nlab/show/complex+number
* https://leanprover-community.github.io/mathlib_docs/data/complex/basic.html#complex"
`;

exports[`render hlm library: 1.7.7.2 Essentials/Numbers/Complex/imaginary%20unit 1`] = `
"Definition 1.7.7.2.  We define:

  𝒊 := (0+1𝒊)

References.

* https://en.wikipedia.org/wiki/Imaginary_unit
* https://mathworld.wolfram.com/ImaginaryUnit.html
* https://proofwiki.org/wiki/Definition:Imaginary_Unit
* https://ncatlab.org/nlab/show/imaginary+unit
* https://leanprover-community.github.io/mathlib_docs/data/complex/basic.html#complex.I"
`;

exports[`render hlm library: 1.7.7.3 Essentials/Numbers/Complex/sum 1`] = `
"Definition 1.7.7.3.  Let a, b ∈ ℂ. We define

  a + b

by:

  (r_a+i_a𝒊) + (r_b+i_b𝒊) := ((r_a + r_b)+(i_a + i_b)𝒊)  (r_a, i_a ∈ ℝ, r_b, i_b ∈ ℝ)

References.

* https://leanprover-community.github.io/mathlib_docs/data/complex/basic.html#complex.has_add"
`;

exports[`render hlm library: 1.7.7.4 Essentials/Numbers/Complex/Sum%20is%20associative 1`] = `
"Proposition 1.7.7.4.

  + is associative

No proof."
`;

exports[`render hlm library: 1.7.7.5 Essentials/Numbers/Complex/Sum%20is%20commutative 1`] = `
"Proposition 1.7.7.5.

  + is commutative

No proof."
`;

exports[`render hlm library: 1.7.7.6 Essentials/Numbers/Complex/inverse 1`] = `
"Definition 1.7.7.6.  Let a ∈ ℂ. We define

  −a

by:

  −(r_a+i_a𝒊) := ((−r_a)+(−i_a)𝒊)  (r_a, i_a ∈ ℝ)"
`;

exports[`render hlm library: 1.7.7.7 Essentials/Numbers/Complex/difference 1`] = `
"Definition 1.7.7.7.  Let a, b ∈ ℂ. We define

  a − b

by:

  (r_a+i_a𝒊) − (r_b+i_b𝒊) := ((r_a − r_b)+(i_a − i_b)𝒊)  (r_a, i_a ∈ ℝ, r_b, i_b ∈ ℝ)
   = a + (−b)

Equality.  No proof."
`;

exports[`render hlm library: 1.7.7.8 Essentials/Numbers/Complex/product 1`] = `
"Definition 1.7.7.8.  Let a, b ∈ ℂ. We define

  a ⋅ b

by:

  (r_a+i_a𝒊) ⋅ (r_b+i_b𝒊) := ((r_a ⋅ r_b − i_a ⋅ i_b)+(r_a ⋅ i_b + i_a ⋅ r_b)𝒊)  (r_a, i_a ∈ ℝ, r_b, i_b ∈ ℝ)

References.

* https://leanprover-community.github.io/mathlib_docs/data/complex/basic.html#complex.has_mul"
`;

exports[`render hlm library: 1.7.7.9 Essentials/Numbers/Complex/Product%20is%20associative 1`] = `
"Proposition 1.7.7.9.

  ⋅ is associative

No proof."
`;

exports[`render hlm library: 1.7.7.10 Essentials/Numbers/Complex/Product%20is%20commutative 1`] = `
"Proposition 1.7.7.10.

  ⋅ is commutative

No proof."
`;

exports[`render hlm library: 1.7.7.11 Essentials/Numbers/Complex/Actual%20linear%20combination%20equals%20formal%20linear%20combination 1`] = `
"Proposition 1.7.7.11.  Let r, i ∈ ℝ. Then:

  (r+i𝒊) = r + i ⋅ 𝒊

No proof.

Remarks.

This proposition justifies the notation used for the constructor. Note that the operations on the right are operations on complex numbers, i.e. on the embedding of the real numbers \`r\` and \`i\` into the complex numbers."
`;

exports[`render hlm library: 1.7.7.12.1 Essentials/Numbers/Complex/Subsets/Hole 1`] = `
"Definition 1.7.7.12.1.  Let a ∈ ℂ. We define:

  ℂ_(≠a) := {b ∈ ℂ : b ≠ a}"
`;

exports[`render hlm library: 1.7.7.12.2 Essentials/Numbers/Complex/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.7.7.12.2.  We define:

  ℂ^× := ℂ_(≠0)
   = {a ∈ ℂ : a ≠ 0}

Equality.  No proof."
`;

exports[`render hlm library: 1.7.7.13 Essentials/Numbers/Complex/quotient 1`] = `
"Definition 1.7.7.13.  Let a ∈ ℂ, b ∈ ℂ^×. For x ∈ ℂ, we define:

  a∕b = x  :⇔  a = x ⋅ b

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.7.7.14.1 Essentials/Numbers/Complex/Iterated%20operators/iterated%20sum 1`] = `
"Definition 1.7.7.14.1.  We define:

  ∑ := [0 + ⋅⋅⋅] is an iterated operation on ℂ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Complex numbers\\", ⨂ = $\\"iterated sum\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.7.7.14.2 Essentials/Numbers/Complex/Iterated%20operators/iterated%20product 1`] = `
"Definition 1.7.7.14.2.  We define:

  ∏ := [1 ⋅ ⋅⋅⋅] is an iterated operation on ℂ

Example.

\`$../../../Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../\\"Complex numbers\\", ⨂ = $\\"iterated product\\", n = n, _1 = {#(i: %Element($../../Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 2.1.1.1 Algebra/Generic/Isomorphisms/element%20condition 1`] = `
"Definition 2.1.1.1.  Let X, Y be sets, φ : X ↔ Y be a bijection, x ∈ X, y ∈ Y. We define:

  x ≃^φ y  :⇔  φ(x) = y

Remarks.

The definitions in this section are somewhat technical. Their purpose is to implement a generic notion of \\"isomorphism\\" that can be checked purely syntactically. If it can be determined that the equality definition of a constructor does not identify any non-isomorphic objects, definitions based on the decomposition of that constructor are automatically well-defined."
`;

exports[`render hlm library: 2.1.1.2 Algebra/Generic/Isomorphisms/function%20condition 1`] = `
"Definition 2.1.1.2.  Let X, Y be sets, φ : X ↔ Y be a bijection, f : X → X, g : Y → Y be functions. We define

  f ≃^φ g

by:

  (X → X, x ↦ a_x) ≃^φ (Y → Y, y ↦ b_y)  :⇔  ∀ x ∈ X : φ(a_x) = b_(φ(x))  (a_x ∈ X for each x ∈ X, b_y ∈ Y for each y ∈ Y)
    ⇔  ∀ x ∈ X : φ(f(x)) = g(φ(x))
    ⇔  φ ∘ f = g ∘ φ

Equivalence.  No proof."
`;

exports[`render hlm library: 2.1.1.3 Algebra/Generic/Isomorphisms/inner%20operation%20condition 1`] = `
"Definition 2.1.1.3.  Let X, Y be sets, φ : X ↔ Y be a bijection, ∗ : X × X → X be an operation on X, ⋆ : Y × Y → Y be an operation on Y. We define

  ∗ ≃^φ ⋆

by:

  (X × X → X, (x_1, x_2) ↦ a_x_1,x_2) ≃^φ (Y × Y → Y, (y_1, y_2) ↦ b_y_1,y_2)  :⇔  ∀ x_1, x_2 ∈ X : φ(a_x_1,x_2) = b_φ(x_1),φ(x_2)  (a_x_1,x_2 ∈ X for each x_1 ∈ X and x_2 ∈ X, b_y_1,y_2 ∈ Y for each y_1 ∈ Y and y_2 ∈ Y)
    ⇔  ∀ x_1, x_2 ∈ X : φ(x_1 ∗ x_2) = φ(x_1) ⋆ φ(x_2)
    ⇔  φ ∘ ∗ = ⋆ ∘ (φ × φ)

Equivalence.  No proof."
`;

exports[`render hlm library: 2.1.1.4 Algebra/Generic/Isomorphisms/left%20operation%20condition 1`] = `
"Definition 2.1.1.4.  Let S, X, Y be sets, φ : X ↔ Y be a bijection, ∗ : S × X → X, ⋆ : S × Y → Y be operations. We define

  ∗ ≃^φ ⋆

by:

  (S × X → X, (s, x) ↦ a_s,x) ≃^φ (S × Y → Y, (s, y) ↦ b_s,y)  :⇔  ∀ s ∈ S, x ∈ X : φ(a_s,x) = b_s,φ(x)  (a_s,x ∈ X for each s ∈ S and x ∈ X, b_s,y ∈ Y for each s ∈ S and y ∈ Y)
    ⇔  ∀ s ∈ S, x ∈ X : φ(s ∗ x) = s ⋆ φ(x)
    ⇔  φ ∘ ∗ = ⋆ ∘ (id_S × φ)

Equivalence.  No proof."
`;

exports[`render hlm library: 2.1.1.5 Algebra/Generic/Isomorphisms/right%20operation%20condition 1`] = `
"Definition 2.1.1.5.  Let S, X, Y be sets, φ : X ↔ Y be a bijection, ∗ : X × S → X, ⋆ : Y × S → Y be operations. We define

  ∗ ≃^φ ⋆

by:

  (X × S → X, (x, s) ↦ a_x,s) ≃^φ (Y × S → Y, (y, s) ↦ b_y,s)  :⇔  ∀ x ∈ X, s ∈ S : φ(a_x,s) = b_φ(x),s  (a_x,s ∈ X for each x ∈ X and s ∈ S, b_y,s ∈ Y for each y ∈ Y and s ∈ S)
    ⇔  ∀ x ∈ X, s ∈ S : φ(x ∗ s) = φ(x) ⋆ s
    ⇔  φ ∘ ∗ = ⋆ ∘ (φ × id_S)

Equivalence.  No proof."
`;

exports[`render hlm library: 2.1.1.6 Algebra/Generic/Isomorphisms/relation%20condition 1`] = `
"Definition 2.1.1.6.  Let X, Y be sets, φ : X ↔ Y be a bijection, ≺ be a relation on X, ⊂ be a relation on Y. We define

  ≺ ≃^φ ⊂

by:

  [p_x_1,x_2]_(x_1,x_2 ∈ X) ≃^φ [q_y_1,y_2]_(y_1,y_2 ∈ Y)  :⇔  ∀ x_1, x_2 ∈ X : [p_x_1,x_2  ⇔  q_φ(x_1),φ(x_2)]  (q_y_1,y_2 is a proposition for each y_1, y_2 ∈ Y, p_x_1,x_2 is a proposition for each x_1, x_2 ∈ X)
    ⇔  ∀ x_1, x_2 ∈ X : [x_1 ≺ x_2  ⇔  φ(x_1) ⊂ φ(x_2)]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.1.1.7 Algebra/Generic/Isomorphisms/morphism%20condition 1`] = `
"Definition 2.1.1.7.  Let X_1, X_2, X_3, Y_1, Y_2, Y_3 be sets, φ_1 : X_1 ↔ Y_1, φ_2 : X_2 ↔ Y_2, φ_3 : X_3 ↔ Y_3 be bijections, ∗ : X_1 × X_2 → X_3, ⋆ : Y_1 × Y_2 → Y_3 be operations. We define

  ∗ ≃^φ_1,φ_2,φ_3 ⋆

by:

  (X_1 × X_2 → X_3, (x_1, x_2) ↦ a_x_1,x_2) ≃^φ_1,φ_2,φ_3 (Y_1 × Y_2 → Y_3, (y_1, y_2) ↦ b_y_1,y_2)  :⇔  ∀ x_1 ∈ X_1, x_2 ∈ X_2 : φ_3(a_x_1,x_2) = b_φ_1(x_1),φ_2(x_2)  (a_x_1,x_2 ∈ X_3 for each x_1 ∈ X_1 and x_2 ∈ X_2, b_y_1,y_2 ∈ Y_3 for each y_1 ∈ Y_1 and y_2 ∈ Y_2)
    ⇔  ∀ x_1 ∈ X_1, x_2 ∈ X_2 : φ_3(x_1 ∗ x_2) = φ_1(x_1) ⋆ φ_2(x_2)
    ⇔  φ_3 ∘ ∗ = ⋆ ∘ (φ_1 × φ_2)

Equivalence.  No proof."
`;

exports[`render hlm library: 2.2.1 Algebra/Pointed%20sets/Pointed%20sets 1`] = `
"Definition 2.2.1.  We define:

  𝓟𝓽𝓢𝓮𝓽 :=: {[S, s] | S is a set, s ∈ S}

  [S, s] = [T, t]  :⇔  ∃ φ : S ↔ T : s ≃^φ t  (S is a set, s ∈ S, T is a set, t ∈ T)

We write “let 𝐒 be a pointed set” for “let 𝐒 ∈ 𝓟𝓽𝓢𝓮𝓽.”

Remarks.

Strictly speaking, the elements of this set are not pointed sets but isomorphism classes of pointed sets, which are similar to cardinal numbers (see \`$../../Essentials/Numbers/Cardinal/\\"Cardinal numbers\\"\`). Due to the rules of HLM, it is not even possible to define pointed sets (or other structures) in a way that would distinguish two isomorphic structures. In particular, the requirement to specify an equality definition, together with the way two arbitrary sets are treated as separate types, make sure that in the most general case, equality is in fact the same as isomorphism. (It is possible to identify more structures, but not fewer.)

References.

* https://en.wikipedia.org/wiki/Pointed_set
* https://proofwiki.org/wiki/Definition:Pointed_Set
* https://ncatlab.org/nlab/show/pointed+set"
`;

exports[`render hlm library: 2.2.2 Algebra/Pointed%20sets/Carrier 1`] = `
"Definition 2.2.2.  Let 𝐒 be a pointed set. We define

  (𝐒)

by:

  ([S, s]) := S  (S is a set, s ∈ S)

We write “let x ∈ 𝐒” for “let x ∈ (𝐒).”

Remarks.

This definition retrieves a representative carrier set from a pointed set (which is actually an equivalence class of pointed sets), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.2.3 Algebra/Pointed%20sets/base%20point 1`] = `
"Definition 2.2.3.  Let 𝐒 be a pointed set. We define

  base(𝐒)

by:

  base([S, s]) := s  (S is a set, s ∈ S)"
`;

exports[`render hlm library: 2.2.4.1 Algebra/Pointed%20sets/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.2.4.1.  Let 𝐒, 𝐓 be pointed sets. We define:

  Hom(𝐒, 𝐓) := {f : (𝐒) → (𝐓) : f(base(𝐒)) = base(𝐓)}

We write “let φ : 𝐒 → 𝐓 be a homomorphism” for “let φ ∈ Hom(𝐒, 𝐓).”

References.

* https://en.wikipedia.org/wiki/Homomorphism
* https://proofwiki.org/wiki/Definition:Homomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/homomorphism"
`;

exports[`render hlm library: 2.2.4.2 Algebra/Pointed%20sets/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.2.4.2.  Let 𝐒, 𝐓 be pointed sets. We define:

  Iso(𝐒, 𝐓) := {homomorphisms φ : 𝐒 → 𝐓 : φ is bijective}
   = {f : (𝐒) ↔ (𝐓) : f(base(𝐒)) = base(𝐓)}

We write “let φ : 𝐒 ↔ 𝐓 be an isomorphism” for “let φ ∈ Iso(𝐒, 𝐓).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Isomorphism
* https://proofwiki.org/wiki/Definition:Isomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 2.2.4.3 Algebra/Pointed%20sets/Homomorphisms/Automorphisms 1`] = `
"Definition 2.2.4.3.  Let 𝐒 be a pointed set. We define:

  Aut(𝐒) := Iso(𝐒, 𝐒)

We write “let φ : 𝐒 ↔ 𝐒 be an automorphism” for “let φ ∈ Aut(𝐒).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut"
`;

exports[`render hlm library: 2.2.4.4 Algebra/Pointed%20sets/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.2.4.4.  Let 𝐒 be a pointed set. We define:

  Aut(𝐒) := [Aut(𝐒)]_(𝑆_(𝐒))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut.group"
`;

exports[`render hlm library: 2.2.4.5 Algebra/Pointed%20sets/Homomorphisms/identity 1`] = `
"Definition 2.2.4.5.  Let 𝐒 be a pointed set. We define:

  id_𝐒 := id_(𝐒)"
`;

exports[`render hlm library: 2.2.4.6 Algebra/Pointed%20sets/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.2.4.6.  Let 𝐒, 𝐓 be pointed sets. Then the following are equivalent:

  1. Iso(𝐒, 𝐓) is nonempty
  2. 𝐒 = 𝐓

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of pointed sets."
`;

exports[`render hlm library: 2.2.4.7 Algebra/Pointed%20sets/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.2.4.7.  Let 𝐒, 𝐓 be pointed sets, φ : 𝐒 ↔ 𝐓 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐓, 𝐒)

No proof."
`;

exports[`render hlm library: 2.2.5.1 Algebra/Pointed%20sets/Subsets/subset%20of%20pointed%20set 1`] = `
"Definition 2.2.5.1.  Let 𝐒 be a pointed set, S ⊆ (𝐒). We define:

  S is a pointed subset of 𝐒  :⇔  base(𝐒) ∈ S"
`;

exports[`render hlm library: 2.2.5.2 Algebra/Pointed%20sets/Subsets/subset%20as%20pointed%20set 1`] = `
"Definition 2.2.5.2.  Let 𝐒 be a pointed set, S ⊆ (𝐒) such that S is a pointed subset of 𝐒. We define:

  [S]_𝐒 := [S, base(𝐒)] is a pointed set"
`;

exports[`render hlm library: 2.2.5.3 Algebra/Pointed%20sets/Subsets/pointed%20subset 1`] = `
"Definition 2.2.5.3.  Let 𝐒, 𝐓 be pointed sets. We define:

  𝐒 ≤ 𝐓  :⇔  ∃ homomorphism φ : 𝐒 → 𝐓 : φ is injective
    ⇔  ∃ S ⊆ (𝐓) : [S is a pointed subset of 𝐓 and 𝐒 = [S]_𝐓]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.3.1 Algebra/Magmas/Magmas 1`] = `
"Definition 2.3.1.  We define:

  𝓜𝓪𝓰 :=: {[M, ∗] | M is a set, ∗ : M × M → M is an operation on M}

  [M, ∗] = [N, ⋆]  :⇔  ∃ φ : M ↔ N : ∗ ≃^φ ⋆  (M is a set, ∗ : M × M → M is an operation on M, N is a set, ⋆ : N × N → N is an operation on N)

We write “let 𝐌 be a magma” for “let 𝐌 ∈ 𝓜𝓪𝓰.”

Remarks.

Strictly speaking, the elements of this set are not magmas but isomorphism classes of magmas. Due to the rules of HLM, it is not even possible to define magmas (or other structures) in a way that would distinguish two isomorphic structures. In particular, the requirement to specify an equality definition, together with the way two arbitrary sets are treated as separate types, make sure that in the most general case, equality is in fact the same as isomorphism. (It is possible to identify more structures, but not fewer.)

References.

* https://en.wikipedia.org/wiki/Magma_(algebra)
* https://mathworld.wolfram.com/Magma.html
* https://proofwiki.org/wiki/Definition:Magma
* https://ncatlab.org/nlab/show/magma"
`;

exports[`render hlm library: 2.3.2 Algebra/Magmas/Carrier 1`] = `
"Definition 2.3.2.  Let 𝐌 be a magma. We define

  (𝐌)

by:

  ([M, ∗]) := M  (M is a set, ∗ : M × M → M is an operation on M)

We write “let a ∈ 𝐌” for “let a ∈ (𝐌).”

Remarks.

This definition retrieves a representative carrier set from a magma (which is actually an equivalence class of magmas), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.3.3 Algebra/Magmas/operation 1`] = `
"Definition 2.3.3.  Let 𝐌 be a magma, a, b ∈ 𝐌. We define:

  a • b := a ∗ b if 𝐌 = [M, ∗] (M is a set, ∗ : M × M → M is an operation on M)

Remarks.

This definition lets us multiply elements without decomposing the magma."
`;

exports[`render hlm library: 2.3.4 Algebra/Magmas/associative 1`] = `
"Definition 2.3.4.  Let 𝐌 be a magma. We define

  𝐌 is associative

by:

  [M, ∗] is associative  :⇔  ∗ is associative  (M is a set, ∗ : M × M → M is an operation on M)

References.

* https://ncatlab.org/nlab/show/associative+magma"
`;

exports[`render hlm library: 2.3.5 Algebra/Magmas/commutative 1`] = `
"Definition 2.3.5.  Let 𝐌 be a magma. We define

  𝐌 is commutative

by:

  [M, ∗] is commutative  :⇔  ∗ is commutative  (M is a set, ∗ : M × M → M is an operation on M)

References.

* https://ncatlab.org/nlab/show/commutative+magma"
`;

exports[`render hlm library: 2.3.6.1 Algebra/Magmas/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.3.6.1.  Let 𝐌, 𝐍 be magmas. We define:

  Hom(𝐌, 𝐍) := {f : (𝐌) → (𝐍) : ∀ a, b ∈ 𝐌 : f(a • b) = f(a) • f(b)}

We write “let φ : 𝐌 → 𝐍 be a homomorphism” for “let φ ∈ Hom(𝐌, 𝐍).”

References.

* https://en.wikipedia.org/wiki/Magma_(algebra)#Morphism_of_magmas
* https://proofwiki.org/wiki/Definition:Homomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/homomorphism"
`;

exports[`render hlm library: 2.3.6.2 Algebra/Magmas/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.3.6.2.  Let 𝐌, 𝐍 be magmas. We define:

  Iso(𝐌, 𝐍) := {homomorphisms φ : 𝐌 → 𝐍 : φ is bijective}
   = {f : (𝐌) ↔ (𝐍) : ∀ a, b ∈ 𝐌 : f(a • b) = f(a) • f(b)}

We write “let φ : 𝐌 ↔ 𝐍 be an isomorphism” for “let φ ∈ Iso(𝐌, 𝐍).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Isomorphism
* https://proofwiki.org/wiki/Definition:Isomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 2.3.6.3 Algebra/Magmas/Homomorphisms/Automorphisms 1`] = `
"Definition 2.3.6.3.  Let 𝐌 be a magma. We define:

  Aut(𝐌) := Iso(𝐌, 𝐌)

We write “let φ : 𝐌 ↔ 𝐌 be an automorphism” for “let φ ∈ Aut(𝐌).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut"
`;

exports[`render hlm library: 2.3.6.4 Algebra/Magmas/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.3.6.4.  Let 𝐌 be a magma. We define:

  Aut(𝐌) := [Aut(𝐌)]_(𝑆_(𝐌))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut.group"
`;

exports[`render hlm library: 2.3.6.5 Algebra/Magmas/Homomorphisms/identity 1`] = `
"Definition 2.3.6.5.  Let 𝐌 be a magma. We define:

  id_𝐌 := id_(𝐌)"
`;

exports[`render hlm library: 2.3.6.6 Algebra/Magmas/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.3.6.6.  Let 𝐌, 𝐍 be magmas. Then the following are equivalent:

  1. Iso(𝐌, 𝐍) is nonempty
  2. 𝐌 = 𝐍

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of magmas."
`;

exports[`render hlm library: 2.3.6.7 Algebra/Magmas/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.3.6.7.  Let 𝐌, 𝐍 be magmas, φ : 𝐌 ↔ 𝐍 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐍, 𝐌)

No proof."
`;

exports[`render hlm library: 2.3.7.1 Algebra/Magmas/Submagmas/submagma%20set 1`] = `
"Definition 2.3.7.1.  Let 𝐌 be a magma, S ⊆ (𝐌). We define:

  S is a submagma of 𝐌  :⇔  ∀ a, b ∈ S : a • b ∈ S

References.

* https://proofwiki.org/wiki/Definition:Submagma"
`;

exports[`render hlm library: 2.3.7.2 Algebra/Magmas/Submagmas/subset%20magma 1`] = `
"Definition 2.3.7.2.  Let 𝐌 be a magma, S ⊆ (𝐌) such that S is a submagma of 𝐌. We define

  [S]_𝐌

by:

  [S]_[M,∗] := [S, ∗∣_S] is a magma  (M is a set, ∗ : M × M → M is an operation on M)"
`;

exports[`render hlm library: 2.3.7.3 Algebra/Magmas/Submagmas/submagma 1`] = `
"Definition 2.3.7.3.  Let 𝐌, 𝐍 be magmas. We define:

  𝐌 ≤ 𝐍  :⇔  ∃ homomorphism φ : 𝐌 → 𝐍 : φ is injective
    ⇔  ∃ S ⊆ (𝐍) : [S is a submagma of 𝐍 and 𝐌 = [S]_𝐍]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.3.8.1 Algebra/Magmas/Free%20magma/Binary%20trees 1`] = `
"Definition 2.3.8.1.  Let S be a set. We define:

  𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S) :=: {(s) | s ∈ S, a^b | a, b ∈ 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S)}

  (s) = (s')  :⇔  s = s'  (s ∈ S, s' ∈ S)

  a^b = a'^b'  :⇔  a = a' and b = b'  (a, b ∈ 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S), a', b' ∈ 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S))

S ⊆: 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S) via
x = (x)

  Well-definedness.  No proof.

For S' ⊆ S, we canonically treat elements of 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S') as elements of 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S).

Remarks.

This is an inductive definition of binary trees with leaves labeled by elements of \`S\`. It does not really belong in this section but is required for the definition of a free magma (see \`$\\"free magma\\"\`).

References.

* https://en.wikipedia.org/wiki/Binary_tree
* https://mathworld.wolfram.com/BinaryTree.html
* https://proofwiki.org/wiki/Definition:Binary_Tree"
`;

exports[`render hlm library: 2.3.8.2 Algebra/Magmas/Free%20magma/free%20magma 1`] = `
"Definition 2.3.8.2.  Let S be a set, T := 𝓑𝓲𝓷𝓣𝓻𝓮𝓮(S). We define:

  free_𝓜𝓰𝓶(S) := [T, (T × T → T, (a, b) ↦ a^b)] is a magma

References.

* https://en.wikipedia.org/wiki/Magma_(algebra)#Free_magma"
`;

exports[`render hlm library: 2.3.8.3 Algebra/Magmas/Free%20magma/free%20on%20set 1`] = `
"Definition 2.3.8.3.  Let 𝐌 be a magma, S ⊆ (𝐌). We define:

  𝐌 is free on S  :⇔  𝐌 = free_𝓜𝓰𝓶(S)
    ⇔  ∀ magmas 𝐍, f : S → (𝐍) : ∃! homomorphism φ : 𝐌 → 𝐍 : φ∣_S = f

Equivalence.  No proof."
`;

exports[`render hlm library: 2.3.8.4 Algebra/Magmas/Free%20magma/free 1`] = `
"Definition 2.3.8.4.  Let 𝐌 be a magma. We define:

  𝐌 is free  :⇔  ∃ S ⊆ (𝐌) : 𝐌 is free on S"
`;

exports[`render hlm library: 2.3.9 Algebra/Magmas/identity%20element 1`] = `
"Definition 2.3.9.  Let 𝐌 be a magma, e ∈ 𝐌. We define

  e is an identity of 𝐌

by:

  e is an identity of [M, ∗]  :⇔  e is an identity for ∗  (M is a set, ∗ : M × M → M is an operation on M)

References.

* https://en.wikipedia.org/wiki/Identity_element
* https://mathworld.wolfram.com/IdentityElement.html
* https://proofwiki.org/wiki/Definition:Identity_Element
* https://ncatlab.org/nlab/show/identity+element"
`;

exports[`render hlm library: 2.3.10 Algebra/Magmas/identity 1`] = `
"Definition 2.3.10.  Let 𝐌 be a magma such that ∃ e ∈ 𝐌 : e is an identity of 𝐌. For m ∈ 𝐌, we define:

  1_𝐌 = m  :⇔  m is an identity of 𝐌

Well-definedness.  No proof.

References.

* https://proofwiki.org/wiki/Identity_is_Unique"
`;

exports[`render hlm library: 2.3.11 Algebra/Magmas/absorbing%20element 1`] = `
"Definition 2.3.11.  Let 𝐌 be a magma, z ∈ 𝐌. We define

  z is an absorbing element of 𝐌

by:

  z is an absorbing element of [M, ∗]  :⇔  z is an absorbing element for ∗  (M is a set, ∗ : M × M → M is an operation on M)

References.

* https://en.wikipedia.org/wiki/Absorbing_element
* https://proofwiki.org/wiki/Definition:Zero_Element#Zero"
`;

exports[`render hlm library: 2.3.12 Algebra/Magmas/zero 1`] = `
"Definition 2.3.12.  Let 𝐌 be a magma such that ∃ z ∈ 𝐌 : z is an absorbing element of 𝐌. For m ∈ 𝐌, we define:

  0_𝐌 = m  :⇔  m is an absorbing element of 𝐌

Well-definedness.  No proof.

References.

* https://proofwiki.org/wiki/Zero_Element_is_Unique"
`;

exports[`render hlm library: 2.4.1 Algebra/Semigroups/semigroup 1`] = `
"Definition 2.4.1.  Let M be a set, ∗ : M × M → M be an operation on M. We define:

  (M, ∗) forms a semigroup  :⇔  ∗ is associative

References.

* https://en.wikipedia.org/wiki/Semigroup
* https://mathworld.wolfram.com/Semigroup.html
* https://proofwiki.org/wiki/Definition:Semigroup
* https://ncatlab.org/nlab/show/semigroup
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#semigroup"
`;

exports[`render hlm library: 2.4.2 Algebra/Semigroups/Semigroups 1`] = `
"Definition 2.4.2.  We define:

  𝓢𝓮𝓶𝓲𝓖𝓻𝓹 := {magmas [M, ∗] : (M, ∗) forms a semigroup}
   = {magmas 𝐒 : 𝐒 is associative}

We write “let 𝐒 be a semigroup” for “let 𝐒 ∈ 𝓢𝓮𝓶𝓲𝓖𝓻𝓹.”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Semigroup
* https://mathworld.wolfram.com/Semigroup.html
* https://proofwiki.org/wiki/Definition:Semigroup
* https://ncatlab.org/nlab/show/semigroup
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#semigroup"
`;

exports[`render hlm library: 2.5.1 Algebra/Monoids/monoid 1`] = `
"Definition 2.5.1.  Let M be a set, ∗ : M × M → M be an operation on M, e ∈ M. We define:

  (M, ∗, e) forms a monoid  :⇔  (M, ∗) forms a semigroup and e is an identity of [M, ∗]
    ⇔  ∗ is associative and e is an identity for ∗

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Monoid
* https://mathworld.wolfram.com/Monoid.html
* https://proofwiki.org/wiki/Definition:Monoid
* https://ncatlab.org/nlab/show/monoid
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#monoid"
`;

exports[`render hlm library: 2.5.2 Algebra/Monoids/Monoids 1`] = `
"Definition 2.5.2.  We define:

  𝓜𝓸𝓷 :=: {[M, ∗, e] | M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid}

  [M, ∗, e] = [N, ⋆, f]  :⇔  ∃ φ : M ↔ N : [∗ ≃^φ ⋆ and e ≃^φ f]  (M is a set, ∗ : M × M → M is an operation on M, e ∈ M, N is a set, ⋆ : N × N → N is an operation on N, f ∈ N with suitable conditions)

We write “let 𝐌 be a monoid” for “let 𝐌 ∈ 𝓜𝓸𝓷.”

References.

* https://en.wikipedia.org/wiki/Monoid
* https://mathworld.wolfram.com/Monoid.html
* https://proofwiki.org/wiki/Definition:Monoid
* https://ncatlab.org/nlab/show/monoid
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#monoid"
`;

exports[`render hlm library: 2.5.3 Algebra/Monoids/semigroup%20with%20identity 1`] = `
"Definition 2.5.3.  Let 𝐒 be a semigroup such that ∃ e ∈ 𝐒 : e is an identity of 𝐒. We define:

  𝐒_𝓜𝓸𝓷 := [S, ∗, 1_𝐒] if 𝐒 = [S, ∗] (S is a set, ∗ : S × S → S is an operation on S)"
`;

exports[`render hlm library: 2.5.4 Algebra/Monoids/Carrier 1`] = `
"Definition 2.5.4.  Let 𝐌 be a monoid. We define

  (𝐌)

by:

  ([M, ∗, e]) := M  (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)

We write “let a ∈ 𝐌” for “let a ∈ (𝐌).”

Remarks.

This definition retrieves a representative carrier set from a monoid (which is actually an equivalence class of monoids), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.5.5 Algebra/Monoids/operation 1`] = `
"Definition 2.5.5.  Let 𝐌 be a monoid, a, b ∈ 𝐌. We define:

  a • b := a ∗ b if 𝐌 = [M, ∗, e] (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)

Remarks.

This definition lets us multiply elements without decomposing the monoid."
`;

exports[`render hlm library: 2.5.6 Algebra/Monoids/identity 1`] = `
"Definition 2.5.6.  Let 𝐌 be a monoid. We define

  e_𝐌

by:

  e_[M,∗,e] := e  (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)"
`;

exports[`render hlm library: 2.5.7 Algebra/Monoids/commutative 1`] = `
"Definition 2.5.7.  Let 𝐌 be a monoid. We define

  𝐌 is commutative

by:

  [M, ∗, e] is commutative  :⇔  ∗ is commutative  (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#comm_monoid"
`;

exports[`render hlm library: 2.5.8 Algebra/Monoids/commutative%20monoid 1`] = `
"Definition 2.5.8.  Let M be a set, ∗ : M × M → M be an operation on M, e ∈ M. We define:

  (M, ∗, e) forms a commutative monoid  :⇔  (M, ∗, e) forms a monoid and [M, ∗, e] is commutative
    ⇔  ∗ is associative and ∗ is commutative and e is an identity for ∗

Equivalence.  No proof."
`;

exports[`render hlm library: 2.5.9.1 Algebra/Monoids/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.5.9.1.  Let 𝐌, 𝐍 be monoids. We define:

  Hom(𝐌, 𝐍) := {f : (𝐌) → (𝐍) : [∀ a, b ∈ 𝐌 : f(a • b) = f(a) • f(b)] and f(e_𝐌) = e_𝐍}

We write “let φ : 𝐌 → 𝐍 be a homomorphism” for “let φ ∈ Hom(𝐌, 𝐍).”

References.

* https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms
* https://proofwiki.org/wiki/Definition:Monoid_Homomorphism
* https://ncatlab.org/nlab/show/homomorphism
* https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom"
`;

exports[`render hlm library: 2.5.9.2 Algebra/Monoids/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.5.9.2.  Let 𝐌, 𝐍 be monoids. We define:

  Iso(𝐌, 𝐍) := {homomorphisms φ : 𝐌 → 𝐍 : φ is bijective}
   = {f : (𝐌) ↔ (𝐍) : [∀ a, b ∈ 𝐌 : f(a • b) = f(a) • f(b)] and f(e_𝐌) = e_𝐍}

We write “let φ : 𝐌 ↔ 𝐍 be an isomorphism” for “let φ ∈ Iso(𝐌, 𝐍).”

Equality.  No proof."
`;

exports[`render hlm library: 2.5.9.3 Algebra/Monoids/Homomorphisms/Automorphisms 1`] = `
"Definition 2.5.9.3.  Let 𝐌 be a monoid. We define:

  Aut(𝐌) := Iso(𝐌, 𝐌)

We write “let φ : 𝐌 ↔ 𝐌 be an automorphism” for “let φ ∈ Aut(𝐌).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut"
`;

exports[`render hlm library: 2.5.9.4 Algebra/Monoids/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.5.9.4.  Let 𝐌 be a monoid. We define:

  Aut(𝐌) := [Aut(𝐌)]_(𝑆_(𝐌))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut.group"
`;

exports[`render hlm library: 2.5.9.5 Algebra/Monoids/Homomorphisms/identity 1`] = `
"Definition 2.5.9.5.  Let 𝐌 be a monoid. We define:

  id_𝐌 := id_(𝐌)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom.id"
`;

exports[`render hlm library: 2.5.9.6 Algebra/Monoids/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.5.9.6.  Let 𝐌, 𝐍 be monoids. Then the following are equivalent:

  1. Iso(𝐌, 𝐍) is nonempty
  2. 𝐌 = 𝐍

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of monoids."
`;

exports[`render hlm library: 2.5.9.7 Algebra/Monoids/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.5.9.7.  Let 𝐌, 𝐍 be monoids, φ : 𝐌 ↔ 𝐍 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐍, 𝐌)

No proof."
`;

exports[`render hlm library: 2.5.10.1 Algebra/Monoids/Submonoids/submonoid%20set 1`] = `
"Definition 2.5.10.1.  Let 𝐌 be a monoid, S ⊆ (𝐌). We define:

  S is a submonoid of 𝐌  :⇔  [∀ a, b ∈ S : a • b ∈ S] and e_𝐌 ∈ S

References.

* https://en.wikipedia.org/wiki/Monoid#Submonoids
* (https://mathworld.wolfram.com/Submonoid.html seems incorrect)
* (https://proofwiki.org/wiki/Definition:Submonoid ditto)
* https://ncatlab.org/nlab/show/submonoid
* https://leanprover-community.github.io/mathlib_docs/group_theory/submonoid/basic.html#submonoid"
`;

exports[`render hlm library: 2.5.10.2 Algebra/Monoids/Submonoids/subset%20monoid 1`] = `
"Definition 2.5.10.2.  Let 𝐌 be a monoid, S ⊆ (𝐌) such that S is a submonoid of 𝐌. We define

  [S]_𝐌

by:

  [S]_[M,∗,e] := [S, ∗∣_S, e] is a monoid  (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)

References.

* https://leanprover-community.github.io/mathlib_docs/group_theory/submonoid/basic.html#subtype.monoid"
`;

exports[`render hlm library: 2.5.10.3 Algebra/Monoids/Submonoids/submonoid 1`] = `
"Definition 2.5.10.3.  Let 𝐌, 𝐍 be monoids. We define:

  𝐌 ≤ 𝐍  :⇔  ∃ homomorphism φ : 𝐌 → 𝐍 : φ is injective
    ⇔  ∃ S ⊆ (𝐍) : [S is a submonoid of 𝐍 and 𝐌 = [S]_𝐍]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.5.11.1 Algebra/Monoids/Examples/natural%20numbers%20with%20addition 1`] = `
"Definition 2.5.11.1.  We define:

  (ℕ, +) := [ℕ, +, 0] is a monoid

References.

* https://en.wikipedia.org/wiki/Monoid#Examples
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.add_monoid"
`;

exports[`render hlm library: 2.5.11.2 Algebra/Monoids/Examples/natural%20numbers%20with%20multiplication 1`] = `
"Definition 2.5.11.2.  We define:

  (ℕ, ⋅) := [ℕ, ⋅, 1] is a monoid

References.

* https://en.wikipedia.org/wiki/Monoid#Examples
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.monoid"
`;

exports[`render hlm library: 2.5.12 Algebra/Monoids/invertible 1`] = `
"Definition 2.5.12.  Let 𝐌 be a monoid, a ∈ 𝐌. We define:

  a is invertible  :⇔  ∃ b ∈ 𝐌 : a • b = b • a = e_𝐌
    ⇔  ∃! b ∈ 𝐌 : a • b = b • a = e_𝐌

Equivalence.  No proof.

References.

* https://mathworld.wolfram.com/Invertible.html
* https://proofwiki.org/wiki/Definition:Invertible_Element
* https://ncatlab.org/nlab/show/unit#units_in_monoids
* https://leanprover-community.github.io/mathlib_docs/algebra/group/units.html#is_unit"
`;

exports[`render hlm library: 2.5.13 Algebra/Monoids/inverse 1`] = `
"Definition 2.5.13.  Let 𝐌 be a monoid, a ∈ 𝐌 such that a is invertible. For b ∈ 𝐌, we define:

  a^-1 = b  :⇔  a • b = e_𝐌

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Multiplicative_inverse
* https://mathworld.wolfram.com/MultiplicativeInverse.html"
`;

exports[`render hlm library: 2.5.14 Algebra/Monoids/power%20to%20natural%20number 1`] = `
"Definition 2.5.14.  Let 𝐌 be a monoid, a ∈ 𝐌, n ∈ ℕ. We define

  a^n

by:

  a^0 := e_𝐌
  a^(x+1) := a^x • a  (x ∈ ℕ)

References.

* https://proofwiki.org/wiki/Definition:Power_of_Element/Monoid
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.pow"
`;

exports[`render hlm library: 2.5.15 Algebra/Monoids/power%20to%20integer 1`] = `
"Definition 2.5.15.  Let 𝐌 be a monoid, a ∈ 𝐌 such that a is invertible, z ∈ ℤ. We define:

  a^z := {a^z if z ≥ 0, (a^-1)^(−z) if z < 0"
`;

exports[`render hlm library: 2.5.16 Algebra/Monoids/iterated%20operation 1`] = `
"Definition 2.5.16.  Let 𝐌 be a commutative monoid. We define

  ∏_𝐌

by:

  ∏_[M,∗,e] := [e ∗ ⋅⋅⋅] is an iterated operation on M  (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)

Example.

\`$../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $Carrier(𝐌 = 𝐌), ⨂ = $\\"iterated operation\\"(𝐌 = 𝐌), n = n, _1 = {#(i: %Element($../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 2.6.1 Algebra/Groups/group 1`] = `
"Definition 2.6.1.  Let G be a set, ∗ : G × G → G be an operation on G, e ∈ G, i : G → G be a function. We define:

  (G, ∗, e, i) forms a group  :⇔  (G, ∗, e) forms a monoid and ∀ a ∈ G : a ∗ i(a) = i(a) ∗ a = e

References.

* https://en.wikipedia.org/wiki/Group_(mathematics)
* https://mathworld.wolfram.com/Group.html
* https://proofwiki.org/wiki/Definition:Group
* https://ncatlab.org/nlab/show/group
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#group"
`;

exports[`render hlm library: 2.6.2 Algebra/Groups/Groups 1`] = `
"Definition 2.6.2.  We define:

  𝓖𝓻𝓹 :=: {[G, ∗, e, i] | G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group}

  [G, ∗, e, i] = [H, ⋆, f, j]  :⇔  ∃ φ : G ↔ H : [∗ ≃^φ ⋆ and e ≃^φ f and i ≃^φ j]  (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function, H is a set, ⋆ : H × H → H is an operation on H, f ∈ H, j : H → H is a function with suitable conditions)

We write “let 𝐆 be a group” for “let 𝐆 ∈ 𝓖𝓻𝓹.”

References.

* https://en.wikipedia.org/wiki/Group_(mathematics)
* https://mathworld.wolfram.com/Group.html
* https://proofwiki.org/wiki/Definition:Group
* https://ncatlab.org/nlab/show/group
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#group"
`;

exports[`render hlm library: 2.6.3 Algebra/Groups/monoid%20with%20inverses 1`] = `
"Definition 2.6.3.  Let 𝐌 be a monoid such that ∀ a ∈ 𝐌 : a is invertible. We define:

  𝐌_𝓖𝓻𝓹 := [M, ∗, e, (M → M, a ↦ a^-1)] if 𝐌 = [M, ∗, e] (M is a set, ∗ : M × M → M is an operation on M, e ∈ M such that (M, ∗, e) forms a monoid)"
`;

exports[`render hlm library: 2.6.4 Algebra/Groups/Carrier 1`] = `
"Definition 2.6.4.  Let 𝐆 be a group. We define

  (𝐆)

by:

  ([G, ∗, e, i]) := G  (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)

We write “let a ∈ 𝐆” for “let a ∈ (𝐆).”

Remarks.

This definition retrieves a representative carrier set from a group (which is actually an equivalence class of groups), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.6.5 Algebra/Groups/operation 1`] = `
"Definition 2.6.5.  Let 𝐆 be a group, a, b ∈ 𝐆. We define:

  a • b := a ∗ b if 𝐆 = [G, ∗, e, i] (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)

Remarks.

This definition lets us multiply elements without decomposing the group."
`;

exports[`render hlm library: 2.6.6 Algebra/Groups/identity 1`] = `
"Definition 2.6.6.  Let 𝐆 be a group. We define

  e_𝐆

by:

  e_[G,∗,e,i] := e  (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)"
`;

exports[`render hlm library: 2.6.7 Algebra/Groups/inverse 1`] = `
"Definition 2.6.7.  Let 𝐆 be a group, a ∈ 𝐆. We define:

  a^-1 := i(a) if 𝐆 = [G, ∗, e, i] (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)"
`;

exports[`render hlm library: 2.6.8 Algebra/Groups/abelian 1`] = `
"Definition 2.6.8.  Let 𝐆 be a group. We define

  𝐆 is abelian

by:

  [G, ∗, e, i] is abelian  :⇔  ∗ is commutative  (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)

References.

* https://en.wikipedia.org/wiki/Abelian_group
* https://mathworld.wolfram.com/Abelian.html
* https://proofwiki.org/wiki/Definition:Abelian_Group
* https://ncatlab.org/nlab/show/abelian+group
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#comm_group"
`;

exports[`render hlm library: 2.6.9 Algebra/Groups/abelian%20group 1`] = `
"Definition 2.6.9.  Let G be a set, ∗ : G × G → G be an operation on G, e ∈ G, i : G → G be a function. We define:

  (G, ∗, e, i) forms an abelian group  :⇔  (G, ∗, e, i) forms a group and [G, ∗, e, i] is abelian
    ⇔  (G, ∗, e, i) forms a group and ∗ is commutative

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Abelian_group
* https://mathworld.wolfram.com/Abelian.html
* https://proofwiki.org/wiki/Definition:Abelian_Group
* https://ncatlab.org/nlab/show/abelian+group
* https://leanprover-community.github.io/mathlib_docs/algebra/group/basic.html#comm_group"
`;

exports[`render hlm library: 2.6.10 Algebra/Groups/power%20to%20natural%20number 1`] = `
"Definition 2.6.10.  Let 𝐆 be a group, a ∈ 𝐆, n ∈ ℕ. We define

  a^n

by:

  a^0 := e_𝐆
  a^(x+1) := a^x • a  (x ∈ ℕ)

References.

* https://proofwiki.org/wiki/Definition:Power_of_Element/Monoid
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.pow"
`;

exports[`render hlm library: 2.6.11 Algebra/Groups/power%20to%20integer 1`] = `
"Definition 2.6.11.  Let 𝐆 be a group, a ∈ 𝐆, z ∈ ℤ. We define:

  a^z := {a^z if z ≥ 0, (a^-1)^(−z) if z < 0

References.

* https://proofwiki.org/wiki/Definition:Power_of_Element/Group
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#gpow"
`;

exports[`render hlm library: 2.6.12.1 Algebra/Groups/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.6.12.1.  Let 𝐆, 𝐇 be groups. We define:

  Hom(𝐆, 𝐇) := {f : (𝐆) → (𝐇) : [∀ a, b ∈ 𝐆 : f(a • b) = f(a) • f(b)] and f(e_𝐆) = e_𝐇 and ∀ c ∈ 𝐆 : f(c^-1) = (f(c))^-1}
   = {f : (𝐆) → (𝐇) : ∀ a, b ∈ 𝐆 : f(a • b) = f(a) • f(b)}

We write “let φ : 𝐆 → 𝐇 be a homomorphism” for “let φ ∈ Hom(𝐆, 𝐇).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Group_homomorphism
* https://mathworld.wolfram.com/GroupHomomorphism.html
* https://proofwiki.org/wiki/Definition:Group_Homomorphism
* https://ncatlab.org/nlab/show/homomorphism
* https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom"
`;

exports[`render hlm library: 2.6.12.2 Algebra/Groups/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.6.12.2.  Let 𝐆, 𝐇 be groups. We define:

  Iso(𝐆, 𝐇) := {homomorphisms φ : 𝐆 → 𝐇 : φ is bijective}
   = {f : (𝐆) ↔ (𝐇) : ∀ a, b ∈ 𝐆 : f(a • b) = f(a) • f(b)}

We write “let φ : 𝐆 ↔ 𝐇 be an isomorphism” for “let φ ∈ Iso(𝐆, 𝐇).”

Equality.  No proof."
`;

exports[`render hlm library: 2.6.12.3 Algebra/Groups/Homomorphisms/Automorphisms 1`] = `
"Definition 2.6.12.3.  Let 𝐆 be a group. We define:

  Aut(𝐆) := Iso(𝐆, 𝐆)

We write “let φ : 𝐆 ↔ 𝐆 be an automorphism” for “let φ ∈ Aut(𝐆).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Group_Automorphism
* https://ncatlab.org/nlab/show/automorphism
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut"
`;

exports[`render hlm library: 2.6.12.4 Algebra/Groups/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.6.12.4.  Let 𝐆 be a group. We define:

  Aut(𝐆) := [Aut(𝐆)]_(𝑆_(𝐆))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group
* https://leanprover-community.github.io/mathlib_docs/data/equiv/mul_add.html#mul_aut.group"
`;

exports[`render hlm library: 2.6.12.5 Algebra/Groups/Homomorphisms/Kernel 1`] = `
"Definition 2.6.12.5.  Let 𝐆, 𝐇 be groups, φ : 𝐆 → 𝐇 be a homomorphism. We define:

  Ker(φ) := φ^-1({e_𝐇})

References.

* https://en.wikipedia.org/wiki/Kernel_(algebra)#Group_homomorphisms
* https://mathworld.wolfram.com/GroupKernel.html
* https://proofwiki.org/wiki/Definition:Kernel_of_Group_Homomorphism
* https://ncatlab.org/nlab/show/kernel
* https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#is_group_hom.ker"
`;

exports[`render hlm library: 2.6.12.6 Algebra/Groups/Homomorphisms/identity 1`] = `
"Definition 2.6.12.6.  Let 𝐆 be a group. We define:

  id_𝐆 := id_(𝐆)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group/hom.html#monoid_hom.id"
`;

exports[`render hlm library: 2.6.12.7 Algebra/Groups/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.6.12.7.  Let 𝐆, 𝐇 be groups. Then the following are equivalent:

  1. Iso(𝐆, 𝐇) is nonempty
  2. 𝐆 = 𝐇

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of groups."
`;

exports[`render hlm library: 2.6.12.8 Algebra/Groups/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.6.12.8.  Let 𝐆, 𝐇 be groups, φ : 𝐆 ↔ 𝐇 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐇, 𝐆)

No proof."
`;

exports[`render hlm library: 2.6.13.1 Algebra/Groups/Subgroups/subgroup%20set 1`] = `
"Definition 2.6.13.1.  Let 𝐆 be a group, S ⊆ (𝐆). We define:

  S is a subgroup of 𝐆  :⇔  [∀ a, b ∈ S : a • b ∈ S] and e_𝐆 ∈ S and ∀ c ∈ S : c^-1 ∈ S

References.

* https://en.wikipedia.org/wiki/Subgroup
* https://mathworld.wolfram.com/Subgroup.html
* https://proofwiki.org/wiki/Definition:Subgroup
* https://ncatlab.org/nlab/show/subgroup
* https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#is_subgroup"
`;

exports[`render hlm library: 2.6.13.2 Algebra/Groups/Subgroups/subset%20group 1`] = `
"Definition 2.6.13.2.  Let 𝐆 be a group, S ⊆ (𝐆) such that S is a subgroup of 𝐆. We define

  [S]_𝐆

by:

  [S]_[G,∗,e,i] := [S, ∗∣_S, e, i∣_S^S] is a group  (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)

References.

* https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#subtype.group"
`;

exports[`render hlm library: 2.6.13.3 Algebra/Groups/Subgroups/subgroup 1`] = `
"Definition 2.6.13.3.  Let 𝐆, 𝐇 be groups. We define:

  𝐆 ≤ 𝐇  :⇔  ∃ homomorphism φ : 𝐆 → 𝐇 : φ is injective
    ⇔  ∃ S ⊆ (𝐇) : [S is a subgroup of 𝐇 and 𝐆 = [S]_𝐇]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.6.13.4 Algebra/Groups/Subgroups/normal%20subgroup%20set 1`] = `
"Definition 2.6.13.4.  Let 𝐆 be a group, S ⊆ (𝐆). We define:

  S is a normal subgroup of 𝐆  :⇔  S is a subgroup of 𝐆 and ∀ s ∈ S, g ∈ 𝐆 : g • s • g^-1 ∈ S
    ⇔  S is a subgroup of 𝐆 and ∀ s ∈ S, h ∈ 𝐆 : h^-1 • s • h ∈ S
    ⇔  ∃ group 𝐇, homomorphism φ : 𝐆 → 𝐇 : S = Ker(φ)

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Normal_subgroup
* https://mathworld.wolfram.com/NormalSubgroup.html
* https://proofwiki.org/wiki/Definition:Normal_Subgroup
* https://ncatlab.org/nlab/show/normal+subgroup
* https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#normal_subgroup"
`;

exports[`render hlm library: 2.6.13.5 Algebra/Groups/Subgroups/normal%20subgroup 1`] = `
"Definition 2.6.13.5.  Let 𝐆, 𝐇 be groups. We define:

  𝐆 ⊴ 𝐇  :⇔  ∃ S ⊆ (𝐇) : [S is a normal subgroup of 𝐇 and 𝐆 = [S]_𝐇]"
`;

exports[`render hlm library: 2.6.13.6 Algebra/Groups/Subgroups/Span 1`] = `
"Definition 2.6.13.6.  Let 𝐆 be a group, X ⊆ (𝐆). We define:

  〈X〉 := ⋂{(S) ∈ 𝒫(𝐆) : S is a subgroup of 𝐆 and X ⊆ S}

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics) (see also https://en.wikipedia.org/wiki/Generating_set_of_a_group)
* https://proofwiki.org/wiki/Definition:Generated_Subgroup
* https://ncatlab.org/nlab/show/Moore+closure
* https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#group.closure"
`;

exports[`render hlm library: 2.6.13.7 Algebra/Groups/Subgroups/Span%20of%20element 1`] = `
"Definition 2.6.13.7.  Let 𝐆 be a group, g ∈ 𝐆. We define:

  〈g〉 := 〈{g}〉
   = {g^z : z ∈ ℤ}

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Cyclic_group
* https://proofwiki.org/wiki/Definition:Cyclic_Group
* https://ncatlab.org/nlab/show/cyclic+group
* https://leanprover-community.github.io/mathlib_docs/group_theory/subgroup.html#gpowers"
`;

exports[`render hlm library: 2.6.14.1 Algebra/Groups/Quotients/quotient%20group 1`] = `
"Definition 2.6.14.1.  Let 𝐆 be a group, S ⊆ (𝐆) such that S is a normal subgroup of 𝐆, ∼ := [∃ s ∈ S : g • s = h]_(g,h ∈ (𝐆)), Q := (𝐆)∕∼. We define:

  𝐆∕S := [Q, (Q × Q → Q, ([g]_∼, [h]_∼) ↦ [g • h]_∼), [e_𝐆]_∼, (Q → Q, [g]_∼ ↦ [g^-1]_∼)] is a group

References.

* https://en.wikipedia.org/wiki/Quotient_group
* https://mathworld.wolfram.com/QuotientGroup.html
* https://proofwiki.org/wiki/Definition:Quotient_Group
* https://ncatlab.org/nlab/show/quotient+group
* https://leanprover-community.github.io/mathlib_docs/group_theory/quotient_group.html#quotient_group.group"
`;

exports[`render hlm library: 2.6.15.1 Algebra/Groups/Examples/integers 1`] = `
"Definition 2.6.15.1.  We define:

  ℤ := [ℤ, +, 0, −] is a group

References.

* https://en.wikipedia.org/wiki/Group_(mathematics)#First_example:_the_integers
* https://proofwiki.org/wiki/Definition:Additive_Group_of_Integers"
`;

exports[`render hlm library: 2.6.15.2 Algebra/Groups/Examples/cyclic%20group 1`] = `
"Definition 2.6.15.2.  Let n ∈ ℕ. We define:

  𝐶_n := ℤ∕nℤ

References.

* https://en.wikipedia.org/wiki/Cyclic_group
* https://mathworld.wolfram.com/CyclicGroup.html
* https://proofwiki.org/wiki/Definition:Cyclic_Group/Notation
* https://ncatlab.org/nlab/show/cyclic+group#examples"
`;

exports[`render hlm library: 2.6.15.3 Algebra/Groups/Examples/symmetric%20group 1`] = `
"Definition 2.6.15.3.  Let X be a set. We define:

  𝑆_X := [X ↔ X, ∘, id_X, ((X ↔ X) → (X ↔ X), f ↦ f^-1)] is a group

References.

* https://en.wikipedia.org/wiki/Symmetric_group
* https://proofwiki.org/wiki/Definition:Symmetric_Group
* https://ncatlab.org/nlab/show/symmetric+group"
`;

exports[`render hlm library: 2.6.15.4 Algebra/Groups/Examples/finite%20symmetric%20group 1`] = `
"Definition 2.6.15.4.  Let n ∈ ℕ. We define:

  𝑆_n := 𝑆_(ℕ_(<n))

References.

* https://en.wikipedia.org/wiki/Symmetric_group
* https://mathworld.wolfram.com/SymmetricGroup.html
* https://proofwiki.org/wiki/Definition:Symmetric_Group/n_Letters
* https://ncatlab.org/nlab/show/symmetric+group"
`;

exports[`render hlm library: 2.6.16 Algebra/Groups/iterated%20operation 1`] = `
"Definition 2.6.16.  Let 𝐆 be an abelian group. We define

  ∏_𝐆

by:

  ∏_[G,∗,e,i] := [e ∗ ⋅⋅⋅] is an iterated operation on G  (G is a set, ∗ : G × G → G is an operation on G, e ∈ G, i : G → G is a function such that (G, ∗, e, i) forms a group)

Example.

\`$../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $Carrier(𝐆 = 𝐆), ⨂ = $\\"iterated operation\\"(𝐆 = 𝐆), n = n, _1 = {#(i: %Element($../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 2.6.17.1 Algebra/Groups/Order/group%20order 1`] = `
"Definition 2.6.17.1.  Let 𝐆 be a group. We define:

  |𝐆| := |(𝐆)|

References.

* https://en.wikipedia.org/wiki/Order_(group_theory)
* https://mathworld.wolfram.com/GroupOrder.html
* https://proofwiki.org/wiki/Definition:Order_of_Structure
* https://ncatlab.org/nlab/show/order+of+a+group"
`;

exports[`render hlm library: 2.6.17.2 Algebra/Groups/Order/finite 1`] = `
"Definition 2.6.17.2.  Let 𝐆 be a group. We define:

  𝐆 is finite  :⇔  |𝐆| is finite
    ⇔  (𝐆) is finite

  𝐆 is infinite  :⇔  𝐆 is not finite

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Finite_group
* https://proofwiki.org/wiki/Definition:Order_of_Structure/Finite_Structure"
`;

exports[`render hlm library: 2.6.17.3.1 Algebra/Groups/Order/Number%20of%20groups/Groups%20with%20order 1`] = `
"Definition 2.6.17.3.1.  Let κ be a cardinal number. We define:

  𝓖𝓻𝓹_κ := {groups 𝐆 : |𝐆| = κ}

We write “let 𝐆 be a group of order κ” for “let 𝐆 ∈ 𝓖𝓻𝓹_κ.”

Remarks.

This is the set of all isomorphism classes of groups of order \`κ\`. (Note that all collections satisfying certain non-circularity rules are sets in HLM.)"
`;

exports[`render hlm library: 2.6.17.3.2 Algebra/Groups/Order/Number%20of%20groups/number%20of%20groups%20with%20order 1`] = `
"Definition 2.6.17.3.2.  Let n ∈ ℕ. We define:

  gnu(n) := |𝓖𝓻𝓹_n|

References.

* https://en.wikipedia.org/wiki/Finite_group#Number_of_groups_of_a_given_order
* http://oeis.org/A000001"
`;

exports[`render hlm library: 2.6.17.3.3 Algebra/Groups/Order/Number%20of%20groups/Number%20of%20small%20groups 1`] = `
"Proposition 2.6.17.3.3.

  seq(gnu) starts with (0, 1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51, 1, 2, 1, 14, 1, 2, 2, 14, 1, 6, 1, 4, 2, 2, 1, 52, 2, 5, 1, 5, 1, 15, 2, 13, 2, 2, 1, 13, 1, 2, 4, 267, 1, 4, 1, 5, 1, 4, 1, 50, 1, 2, 3, 4, 1, 6, 1, 52, 15, 2, 1, 15, 1, 2, 1, 12, 1, 10, 1, 4, 2, 2, 1, 231, 1, 5, 2, 16, 1, 4, 1, 14, 2, 2, 1, 45, 1, 6, 2, 43, 1, 6, 1, 5, 4, 2, 1, 47, 2, 2, 1, 4, 5, 16, 1, 2328, 2, 4, 1, 10, 1, 2, 5, 15, 1, 4, 1, 11, 1, 2, 1, 197, 1, 2, 6, 5, 1, 13, 1, 12, 2, 4, 2, 18, 1, 2, 1, 238, 1, 55, 1, 5, 2, 2, 1, 57, 2, 4, 5, 4, 1, 4, 2, 42, 1, 2, 1, 37, 1, 4, 2, 12, 1, 6, 1, 4, 13, 4, 1, 1543, 1, 2, 2, 12, 1, 10, 1, 52, 2, 2, 2, 12, 2, 2, 2, 51, 1, 12, 1, 5, 1, 2, 1, 177, 1, 2, 2, 15, 1, 6, 1, 197, 6, 2, 1, 15, 1, 4, 2, 14, 1, 16, 1, 4, 2, 4, 1, 208, 1, 5, 67, 5, 2, 4, 1, 12, 1, 15, 1, 46, 2, 2, 1, 56092, 1, 6, 1, 15, 2, 2, 1, 39, 1, 4, 1, 4, 1, 30, 1, 54, 5, 2, 4, 10, 1, 2, 4, 40, 1, 4, 1, 4, 2, 4, 1, 1045, 2, 4, 2, 5, 1, 23, 1, 14, 5, 2, 1, 49, 2, 2, 1, 42, 2, 10, 1, 9, 2, 6, 1, 61, 1, 2, 4, 4, 1, 4, 1, 1640, 1, 4, 1, 176, 2, 2, 2, 15, 1, 12, 1, 4, 5, 2, 1, 228, 1, 5, 1, 15, 1, 18, 5, 12, 1, 2, 1, 12, 1, 10, 14, 195, 1, 4, 2, 5, 2, 2, 1, 162, 2, 2, 3, 11, 1, 6, 1, 42, 2, 4, 1, 15, 1, 4, 7, 12, 1, 60, 1, 11, 2, 2, 1, 20169, 2, 2, 4, 5, 1, 12, 1, 44, 1, 2, 1, 30, 1, 2, 5, 221, 1, 6, 1, 5, 16, 6, 1, 46, 1, 6, 1, 4, 1, 10, 1, 235, 2, 4, 1, 41, 1, 2, 2, 14, 2, 4, 1, 4, 2, 4, 1, 775, 1, 4, 1, 5, 1, 6, 1, 51, 13, 4, 1, 18, 1, 2, 1, 1396, 1, 34, 1, 5, 2, 2, 1, 54, 1, 2, 5, 11, 1, 12, 1, 51, 4, 2, 1, 55, 1, 4, 2, 12, 1, 6, 2, 11, 2, 2, 1, 1213, 1, 2, 2, 12, 1, 261, 1, 14, 2, 10, 1, 12, 1, 4, 4, 42, 2, 4, 1, 56, 1, 2, 1, 202, 2, 6, 6, 4, 1, 8, 1, 10494213, 15, 2, 1, 15, 1, 4, 1, 49, 1, 10, 1, 4, 6, 2, 1, 170, 2, 4, 2, 9, 1, 4, 1, 12, 1, 2, 2, 119, 1, 2, 2, 246, 1, 24, 1, 5, 4, 16, 1, 39, 1, 2, 2, 4, 1, 16, 1, 180, 1, 2, 1, 10, 1, 2, 49, 12, 1, 12, 1, 11, 1, 4, 2, 8681, 1, 5, 2, 15, 1, 6, 1, 15, 4, 2, 1, 66, 1, 4, 1, 51, 1, 30, 1, 5, 2, 4, 1, 205, 1, 6, 4, 4, 7, 4, 1, 195, 3, 6, 1, 36, 1, 2, 2, 35, 1, 6, 1, 15, 5, 2, 1, 260, 15, 2, 2, 5, 1, 32, 1, 12, 2, 2, 1, 12, 2, 4, 2, 21541, 1, 4, 1, 9, 2, 4, 1, 757, 1, 10, 5, 4, 1, 6, 2, 53, 5, 4, 1, 40, 1, 2, 2, 12, 1, 18, 1, 4, 2, 4, 1, 1280, 1, 2, 17, 16, 1, 4, 1, 53, 1, 4, 1, 51, 1, 15, 2, 42, 2, 8, 1, 5, 4, 2, 1, 44, 1, 2, 1, 36, 1, 62, 1, 1387, 1, 2, 1, 10, 1, 6, 4, 15, 1, 12, 2, 4, 1, 2, 1, 840, 1, 5, 2, 5, 2, 13, 1, 40, 504, 4, 1, 18, 1, 2, 6, 195, 2, 10, 1, 15, 5, 4, 1, 54, 1, 2, 2, 11, 1, 39, 1, 42, 1, 4, 2, 189, 1, 2, 2, 39, 1, 6, 1, 4, 2, 2, 1, 1090235, 1, 12, 1, 5, 1, 16, 4, 15, 5, 2, 1, 53, 1, 4, 5, 172, 1, 4, 1, 5, 1, 4, 2, 137, 1, 2, 1, 4, 1, 24, 1, 1211, 2, 2, 1, 15, 1, 4, 1, 14, 1, 113, 1, 16, 2, 4, 1, 205, 1, 2, 11, 20, 1, 4, 1, 12, 5, 4, 1, 30, 1, 4, 2, 1630, 2, 6, 1, 9, 13, 2, 1, 186, 2, 2, 1, 4, 2, 10, 2, 51, 2, 10, 1, 10, 1, 4, 5, 12, 1, 12, 1, 11, 2, 2, 1, 4725, 1, 2, 3, 9, 1, 8, 1, 14, 4, 4, 5, 18, 1, 2, 1, 221, 1, 68, 1, 15, 1, 2, 1, 61, 2, 4, 15, 4, 1, 4, 1, 19349, 2, 2, 1, 150, 1, 4, 7, 15, 2, 6, 1, 4, 2, 8, 1, 222, 1, 2, 4, 5, 1, 30, 1, 39, 2, 2, 1, 34, 2, 2, 4, 235, 1, 18, 2, 5, 1, 2, 2, 222, 1, 4, 2, 11, 1, 6, 1, 42, 13, 4, 1, 15, 1, 10, 1, 42, 1, 10, 2, 4, 1, 2, 1, 11394, 2, 4, 2, 5, 1, 12, 1, 42, 2, 4, 1, 900, 1, 2, 6, 51, 1, 6, 2, 34, 5, 2, 1, 46, 1, 4, 2, 11, 1, 30, 1, 196, 2, 6, 1, 10, 1, 2, 15, 199, 1, 4, 1, 4, 2, 2, 1, 954, 1, 6, 2, 13, 1, 23, 2, 12, 2, 2, 1, 37, 1, 4, 2, 49487365422, 4, 66, 2, 5, 19, 4, 1, 54, 1, 4, 2, 11, 1, 4, 1, 231, 1, 2, 1, 36, 2, 2, 2, 12, 1, 40, 1, 4, 51, 4, 2, 1028, 1, 5, 1, 15, 1, 10, 1, 35, 2, 4, 1, 12, 1, 4, 4, 42, 1, 4, 2, 5, 1, 10, 1, 583, 2, 2, 6, 4, 2, 6, 1, 1681, 6, 4, 1, 77, 1, 2, 2, 15, 1, 16, 1, 51, 2, 4, 1, 170, 1, 4, 5, 5, 1, 12, 1, 12, 2, 2, 1, 46, 1, 4, 2, 1092, 1, 8, 1, 5, 14, 2, 2, 39, 1, 4, 2, 4, 1, 254, 1, 42, 2, 2, 1, 41, 1, 2, 5, 39, 1, 4, 1, 11, 1, 10, 1, 157877, 1, 2, 4, 16, 1, 6, 1, 49, 13, 4, 1, 18, 1, 4, 1, 53, 1, 32, 1, 5, 1, 2, 2, 279, 1, 4, 2, 11, 1, 4, 3, 235, 2, 2, 1, 99, 1, 8, 2, 14, 1, 6, 1, 11, 14, 2, 1, 1040, 1, 2, 1, 13, 2, 16, 1, 12, 5, 27, 1, 12, 1, 2, 69, 1387, 1, 16, 1, 20, 2, 4, 1, 164, 4, 2, 2, 4, 1, 12, 1, 153, 2, 2, 1, 15, 1, 2, 2, 51, 1, 30, 1, 4, 1, 4, 1, 1460, 1, 55, 4, 5, 1, 12, 2, 14, 1, 4, 1, 131, 1, 2, 2, 42, 3, 6, 1, 5, 5, 4, 1, 44, 1, 10, 3, 11, 1, 10, 1, 1116461, 5, 2, 1, 10, 1, 2, 4, 35, 1, 12, 1, 11, 1, 2, 1, 3609, 1, 4, 2, 50, 1, 24, 1, 12, 2, 2, 1, 18, 1, 6, 2, 244, 1, 18, 1, 9, 2, 2, 1, 181, 1, 2, 51, 4, 2, 12, 1, 42, 1, 8, 5, 61, 1, 4, 1, 12, 1, 6, 1, 11, 2, 4, 1, 11720, 1, 2, 1, 5, 1, 112, 1, 52, 1, 2, 2, 12, 1, 4, 4, 245, 1, 4, 1, 9, 5, 2, 1, 211, 2, 4, 2, 38, 1, 6, 15, 195, 15, 6, 2, 29, 1, 2, 1, 14, 1, 32, 1, 4, 2, 4, 1, 198, 1, 4, 8, 5, 1, 4, 1, 153, 1, 2, 1, 227, 2, 4, 5, 19324, 1, 8, 1, 5, 4, 4, 1, 39, 1, 2, 2, 15, 4, 16, 1, 53, 6, 4, 1, 40, 1, 12, 5, 12, 1, 4, 2, 4, 1, 2, 1, 5958, 1, 4, 5, 12, 2, 6, 1, 14, 4, 10, 1, 40, 1, 2, 2, 179, 1, 1798, 1, 15, 2, 4, 1, 61, 1, 2, 5, 4, 1, 46, 1, 1387, 1, 6, 2, 36, 2, 2, 1, 49, 1, 24, 1, 11, 10, 2, 1, 222, 1, 4, 3, 5, 1, 10, 1, 41, 2, 4, 1, 174, 1, 2, 2, 195, 2, 4, 1, 15, 1, 6, 1, 889, 1, 2, 2, 4, 1, 12, 2, 178, 13, 2, 1, 15, 4, 4, 1, 12, 1, 20, 1, 4, 5, 4, 1, 408641062, 1, 2, 60, 36, 1, 4, 1, 15, 2, 2, 1, 46, 1, 16, 1, 54, 1, 24, 2, 5, 2, 4, 1, 221, 1, 4, 1, 11, 1, 30, 1, 928, 2, 4, 1, 10, 2, 2, 13, 14, 1, 4, 1, 11, 2, 6, 1, 697, 1, 4, 3, 5, 1, 8, 1, 12, 5, 2, 2, 64, 1, 4, 2, 10281, 1, 10, 1, 5, 1, 4, 1, 54, 1, 8, 2, 11, 1, 4, 1, 51, 6, 2, 1, 477, 1, 2, 2, 56, 5, 6, 1, 11, 5, 4, 1, 1213, 1, 4, 2, 5, 1, 72, 1, 68, 2, 2, 1, 12, 1, 2, 13, 42, 1, 38, 1, 9, 2, 2, 2, 137, 1, 2, 5, 11, 1, 6, 1, 21507, 5, 10, 1, 15, 1, 4, 1, 34, 2, 60, 2, 4, 5, 2, 1, 1005, 2, 5, 2, 5, 1, 4, 1, 12, 1, 10, 1, 30, 1, 10, 1, 235, 1, 6, 1, 50, 309, 4, 2, 39, 7, 2, 1, 11, 1, 36, 2, 42, 2, 2, 5, 40, 1, 2, 2, 39, 1, 12, 1, 4, 3, 2, 1, 47937, 1, 4, 2, 5, 1, 13, 1, 35, 4, 4, 1, 37, 1, 4, 2, 51, 1, 16, 1, 9, 1, 30, 2, 64, 1, 2, 14, 4, 1, 4, 1, 1285, 1, 2, 1, 228, 1, 2, 5, 53, 1, 8, 2, 4, 2, 2, 4, 260, 1, 6, 1, 15, 1, 110, 1, 12, 2, 4, 1, 12, 1, 4, 5, 1083553, 1, 12, 1, 5, 1, 4, 1, 749, 1, 4, 2, 11, 3, 30, 1, 54, 13, 6, 1, 15, 2, 2, 9, 12, 1, 10, 1, 35, 2, 2, 1, 1264, 2, 4, 6, 5, 1, 18, 1, 14, 2, 4, 1, 117, 1, 2, 2, 178, 1, 6, 1, 5, 4, 4, 1, 162, 2, 10, 1, 4, 1, 16, 1, 1630, 2, 2, 2, 56, 1, 10, 15, 15, 1, 4, 1, 4, 2, 12, 1, 1096, 1, 2, 21, 9, 1, 6, 1, 39, 5, 2, 1, 18, 1, 4, 2, 195, 1, 120, 1, 9, 2, 2, 1, 54, 1, 4, 4, 36, 1, 4, 1, 186, 2, 2, 1, 36, 1, 6, 15, 12, 1, 8, 1, 4, 5, 4, 1, 241004, 1, 5, 1, 15, 4, 10, 1, 15, 2, 4, 1, 34, 1, 2, 4, 167, 1, 12, 1, 15, 1, 2, 1, 3973, 1, 4, 1, 4, 1, 40, 1, 235, 11, 2, 1, 15, 1, 6, 1, 144, 1, 18, 1, 4, 2, 2, 2, 203, 1, 4, 15, 15, 1, 12, 2, 39, 1, 4, 1, 120, 1, 2, 2, 1388, 1, 6, 1, 13, 4, 4, 1, 39, 1, 2, 5, 4, 1, 66, 1, 963, 1, 8, 1, 10, 2, 4, 4, 12, 2, 12, 1, 4, 2, 4, 2, 6538, 1, 2, 2, 20, 1, 6, 2, 46, 63, 2, 1, 88, 1, 12, 1, 42, 1, 10, 2, 5, 5, 2, 1, 175, 2, 2, 2, 11, 1, 12, 1)

No proof.

References.

* https://en.wikipedia.org/wiki/Finite_group#Number_of_groups_of_a_given_order
* http://oeis.org/A000001
* https://www.math.auckland.ac.nz/~obrien/research/gnu.pdf"
`;

exports[`render hlm library: 2.6.17.4 Algebra/Groups/Order/element%20order 1`] = `
"Definition 2.6.17.4.  Let 𝐆 be a group, g ∈ 𝐆, S := {n ∈ ℕ_+ : g^n = e_𝐆}. We define:

  |g| := |〈g〉|
   = {min(S) if S is nonempty, ℵ_0 if S is empty

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Order_(group_theory)
* https://mathworld.wolfram.com/GroupOrder.html
* https://proofwiki.org/wiki/Definition:Order_of_Group_Element
* https://ncatlab.org/nlab/show/order+of+a+group#OrderOfAnElementOfAGroup
* https://leanprover-community.github.io/mathlib_docs/group_theory/order_of_element.html#order_of"
`;

exports[`render hlm library: 2.6.17.5 Algebra/Groups/Order/Lagranges%20theorem 1`] = `
"Theorem 2.6.17.5 (Lagrange's theorem).  Let 𝐆 be a finite group, S ⊆ (𝐆) such that S is a subgroup of 𝐆. Then:

  |S| ∣ |𝐆|

No proof.

References.

* https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)
* https://mathworld.wolfram.com/LagrangesGroupTheorem.html
* https://proofwiki.org/wiki/Lagrange%27s_Theorem_(Group_Theory)
* https://ncatlab.org/nlab/show/index+of+a+subgroup#properties
* https://leanprover-community.github.io/mathlib_docs/group_theory/order_of_element.html#card_subgroup_dvd_card"
`;

exports[`render hlm library: 2.6.17.6 Algebra/Groups/Order/Lagranges%20corollary 1`] = `
"Corollary 2.6.17.6.  Let 𝐆 be a finite group, g ∈ 𝐆. Then:

  |g| ∣ |𝐆|

No proof.

References.

* https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)#Applications
* https://proofwiki.org/wiki/Order_of_Element_Divides_Order_of_Finite_Group
* https://leanprover-community.github.io/mathlib_docs/group_theory/order_of_element.html#order_of_dvd_card_univ"
`;

exports[`render hlm library: 2.6.17.7.1 Algebra/Groups/Order/P-Groups/p-element 1`] = `
"Definition 2.6.17.7.1.  Let 𝐆 be a group, g ∈ 𝐆, p be a prime. We define:

  g is a p-element  :⇔  ∃ n ∈ ℕ : |g| = p^n
    ⇔  ∃ m ∈ ℕ : g^(p^m) = e_𝐆

Equivalence.  No proof.

References.

* https://proofwiki.org/wiki/Definition:P-Element"
`;

exports[`render hlm library: 2.6.17.7.2 Algebra/Groups/Order/P-Groups/p-group 1`] = `
"Definition 2.6.17.7.2.  Let 𝐆 be a group, p be a prime. We define:

  𝐆 is a p-group  :⇔  ∀ g ∈ 𝐆 : g is a p-element

References.

* https://en.wikipedia.org/wiki/P-group
* https://mathworld.wolfram.com/p-Group.html
* https://proofwiki.org/wiki/Definition:P-Group
* https://ncatlab.org/nlab/show/p-primary+group"
`;

exports[`render hlm library: 2.6.17.7.3 Algebra/Groups/Order/P-Groups/p-subgroup 1`] = `
"Definition 2.6.17.7.3.  Let 𝐆 be a group, H ⊆ (𝐆), p be a prime. We define:

  H is a p-subgroup of 𝐆  :⇔  H is a subgroup of 𝐆 and [H]_𝐆 is a p-group"
`;

exports[`render hlm library: 2.6.18.1 Algebra/Groups/Sylow/sylow%20subgroup 1`] = `
"Definition 2.6.18.1.  Let 𝐆 be a group, H ⊆ (𝐆), p be a prime. We define:

  H is a Sylow p-subgroup of 𝐆  :⇔  H is a maximal subset I of (𝐆) such that I is a p-subgroup of 𝐆

References.

* https://en.wikipedia.org/wiki/Sylow_theorems
* https://mathworld.wolfram.com/Sylowp-Subgroup.html
* https://proofwiki.org/wiki/Definition:Sylow_p-Subgroup
* https://ncatlab.org/nlab/show/Sylow+p-subgroup"
`;

exports[`render hlm library: 2.6.18.2 Algebra/Groups/Sylow/First%20Sylow%20theorem 1`] = `
"Theorem 2.6.18.2 (First Sylow theorem).  Let 𝐆 be a finite group, p be a prime. Then:

  ∃ H ⊆ (𝐆) : [H is a Sylow p-subgroup of 𝐆 and |H| = p^(mult(p,|𝐆|))]

No proof.

References.

* https://en.wikipedia.org/wiki/Sylow_theorems#Theorems
* https://mathworld.wolfram.com/SylowTheorems.html
* https://proofwiki.org/wiki/First_Sylow_Theorem
* https://ncatlab.org/nlab/show/Sylow+p-subgroup#facts"
`;

exports[`render hlm library: 2.7.1 Algebra/Semirings/semiring 1`] = `
"Definition 2.7.1.  Let R be a set, ⊕ : R × R → R be an operation on R, 0 ∈ R, ⊙ : R × R → R be an operation on R, 1 ∈ R. We define:

  (R, ⊕, 0, ⊙, 1) forms a semiring  :⇔  (R, ⊕, 0) forms a commutative monoid and (R, ⊙, 1) forms a monoid and ⊙ is distributive over ⊕ and 0 is an absorbing element for ⊙

References.

* https://en.wikipedia.org/wiki/Semiring
* https://proofwiki.org/wiki/Definition:Rig#Also_defined_as
* https://ncatlab.org/nlab/show/rig
* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#semi_ring_theory
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#semiring"
`;

exports[`render hlm library: 2.7.2 Algebra/Semirings/Semirings 1`] = `
"Definition 2.7.2.  We define:

  𝓢𝓮𝓶𝓲𝓡𝓲𝓷𝓰 :=: {[R, ⊕, 0, ⊙, 1] | R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring}

  [R, ⊕, 0, ⊙, 1] = [S, ⋆, 𝟢, ∗, 𝟣]  :⇔  ∃ φ : R ↔ S : [⊕ ≃^φ ⋆ and 0 ≃^φ 𝟢 and ⊙ ≃^φ ∗ and 1 ≃^φ 𝟣]  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R, S is a set, ⋆ : S × S → S is an operation on S, 𝟢 ∈ S, ∗ : S × S → S is an operation on S, 𝟣 ∈ S with suitable conditions)

We write “let 𝐑 be a semiring” for “let 𝐑 ∈ 𝓢𝓮𝓶𝓲𝓡𝓲𝓷𝓰.”

References.

* https://en.wikipedia.org/wiki/Semiring
* https://proofwiki.org/wiki/Definition:Rig#Also_defined_as
* https://ncatlab.org/nlab/show/rig
* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#semi_ring_theory
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#semiring"
`;

exports[`render hlm library: 2.7.3 Algebra/Semirings/Carrier 1`] = `
"Definition 2.7.3.  Let 𝐑 be a semiring. We define

  (𝐑)

by:

  ([R, ⊕, 0, ⊙, 1]) := R  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)

We write “let a ∈ 𝐑” for “let a ∈ (𝐑).”

Remarks.

This definition retrieves a representative carrier set from a semiring (which is actually an equivalence class of semirings), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.7.4 Algebra/Semirings/sum 1`] = `
"Definition 2.7.4.  Let 𝐑 be a semiring, a, b ∈ 𝐑. We define:

  a + b := a ⊕ b if 𝐑 = [R, ⊕, 0, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)

Remarks.

This definition lets us add elements without decomposing the semiring."
`;

exports[`render hlm library: 2.7.5 Algebra/Semirings/zero 1`] = `
"Definition 2.7.5.  Let 𝐑 be a semiring. We define

  0_𝐑

by:

  0_[R,⊕,0,⊙,1] := 0  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)"
`;

exports[`render hlm library: 2.7.6 Algebra/Semirings/additive%20monoid 1`] = `
"Definition 2.7.6.  Let 𝐑 be a semiring. We define

  [𝐑, +]

by:

  [[R, ⊕, 0, ⊙, 1], +] := [R, ⊕, 0] is a monoid  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#semiring.to_add_comm_monoid"
`;

exports[`render hlm library: 2.7.7 Algebra/Semirings/product 1`] = `
"Definition 2.7.7.  Let 𝐑 be a semiring, a, b ∈ 𝐑. We define:

  a ⋅ b := a ⊙ b if 𝐑 = [R, ⊕, 0, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)

Remarks.

This definition lets us multiply elements without decomposing the semiring."
`;

exports[`render hlm library: 2.7.8 Algebra/Semirings/one 1`] = `
"Definition 2.7.8.  Let 𝐑 be a semiring. We define

  1_𝐑

by:

  1_[R,⊕,0,⊙,1] := 1  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)"
`;

exports[`render hlm library: 2.7.9 Algebra/Semirings/multiplicative%20monoid 1`] = `
"Definition 2.7.9.  Let 𝐑 be a semiring. We define

  [𝐑, ⋅]

by:

  [[R, ⊕, 0, ⊙, 1], ⋅] := [R, ⊙, 1] is a monoid  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#semiring.to_monoid"
`;

exports[`render hlm library: 2.7.10.1 Algebra/Semirings/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.7.10.1.  Let 𝐑, 𝐒 be semirings. We define:

  Hom(𝐑, 𝐒) := {f : (𝐑) → (𝐒) : [∀ a, b ∈ 𝐑 : f(a + b) = f(a) + f(b)] and f(0_𝐑) = 0_𝐒 and [∀ c, d ∈ 𝐑 : f(c ⋅ d) = f(c) ⋅ f(d)] and f(1_𝐑) = 1_𝐒}

We write “let φ : 𝐑 → 𝐒 be a homomorphism” for “let φ ∈ Hom(𝐑, 𝐒).”

References.

* https://en.wikipedia.org/wiki/Homomorphism
* https://proofwiki.org/wiki/Definition:Homomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/homomorphism
* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#semi_morph
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring_hom"
`;

exports[`render hlm library: 2.7.10.2 Algebra/Semirings/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.7.10.2.  Let 𝐑, 𝐒 be semirings. We define:

  Iso(𝐑, 𝐒) := {homomorphisms φ : 𝐑 → 𝐒 : φ is bijective}
   = {f : (𝐑) ↔ (𝐒) : [∀ a, b ∈ 𝐑 : f(a + b) = f(a) + f(b)] and f(0_𝐑) = 0_𝐒 and [∀ c, d ∈ 𝐑 : f(c ⋅ d) = f(c) ⋅ f(d)] and f(1_𝐑) = 1_𝐒}

We write “let φ : 𝐑 ↔ 𝐒 be an isomorphism” for “let φ ∈ Iso(𝐑, 𝐒).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Isomorphism
* https://proofwiki.org/wiki/Definition:Isomorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 2.7.10.3 Algebra/Semirings/Homomorphisms/Automorphisms 1`] = `
"Definition 2.7.10.3.  Let 𝐑 be a semiring. We define:

  Aut(𝐑) := Iso(𝐑, 𝐑)

We write “let φ : 𝐑 ↔ 𝐑 be an automorphism” for “let φ ∈ Aut(𝐑).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism
* https://leanprover-community.github.io/mathlib_docs/data/equiv/ring.html#ring_aut"
`;

exports[`render hlm library: 2.7.10.4 Algebra/Semirings/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.7.10.4.  Let 𝐑 be a semiring. We define:

  Aut(𝐑) := [Aut(𝐑)]_(𝑆_(𝐑))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group
* https://leanprover-community.github.io/mathlib_docs/data/equiv/ring.html#ring_aut.group"
`;

exports[`render hlm library: 2.7.10.5 Algebra/Semirings/Homomorphisms/Kernel 1`] = `
"Definition 2.7.10.5.  Let 𝐑, 𝐒 be semirings, φ : 𝐑 → 𝐒 be a homomorphism. We define:

  Ker(φ) := φ^-1({0_𝐒})"
`;

exports[`render hlm library: 2.7.10.6 Algebra/Semirings/Homomorphisms/identity 1`] = `
"Definition 2.7.10.6.  Let 𝐑 be a semiring. We define:

  id_𝐑 := id_(𝐑)

References.

* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#IDphi
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring_hom.id"
`;

exports[`render hlm library: 2.7.10.7 Algebra/Semirings/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.7.10.7.  Let 𝐑, 𝐒 be semirings. Then the following are equivalent:

  1. Iso(𝐑, 𝐒) is nonempty
  2. 𝐑 = 𝐒

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of semirings."
`;

exports[`render hlm library: 2.7.10.8 Algebra/Semirings/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.7.10.8.  Let 𝐑, 𝐒 be semirings, φ : 𝐑 ↔ 𝐒 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐒, 𝐑)

No proof."
`;

exports[`render hlm library: 2.7.11.1 Algebra/Semirings/Subsemirings/subsemiring%20set 1`] = `
"Definition 2.7.11.1.  Let 𝐑 be a semiring, S ⊆ (𝐑). We define:

  S is a subsemiring of 𝐑  :⇔  [∀ a, b ∈ S : a + b ∈ S] and 0_𝐑 ∈ S and [∀ c, d ∈ S : c ⋅ d ∈ S] and 1_𝐑 ∈ S"
`;

exports[`render hlm library: 2.7.11.2 Algebra/Semirings/Subsemirings/subset%20semiring 1`] = `
"Definition 2.7.11.2.  Let 𝐑 be a semiring, S ⊆ (𝐑) such that S is a subsemiring of 𝐑. We define

  [S]_𝐑

by:

  [S]_[R,⊕,0,⊙,1] := [S, ⊕∣_S, 0, ⊙∣_S, 1] is a semiring  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊙, 1) forms a semiring)"
`;

exports[`render hlm library: 2.7.11.3 Algebra/Semirings/Subsemirings/subsemiring 1`] = `
"Definition 2.7.11.3.  Let 𝐑, 𝐒 be semirings. We define:

  𝐑 ≤ 𝐒  :⇔  ∃ homomorphism φ : 𝐑 → 𝐒 : φ is injective
    ⇔  ∃ S ⊆ (𝐒) : [S is a subsemiring of 𝐒 and 𝐑 = [S]_𝐒]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.7.12 Algebra/Semirings/product%20with%20natural%20number 1`] = `
"Definition 2.7.12.  Let 𝐑 be a semiring, n ∈ ℕ, a ∈ 𝐑. We define

  n ⋅ a

by:

  0 ⋅ a := 0_𝐑
  (x + 1) ⋅ a := x ⋅ a + a  (x ∈ ℕ)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#add_monoid.smul"
`;

exports[`render hlm library: 2.7.13 Algebra/Semirings/power%20to%20natural%20number 1`] = `
"Definition 2.7.13.  Let 𝐑 be a semiring, a ∈ 𝐑, n ∈ ℕ. We define

  a^n

by:

  a^0 := 1_𝐑
  a^(x+1) := a^x ⋅ a  (x ∈ ℕ)

References.

* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#pow_N
* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.pow"
`;

exports[`render hlm library: 2.7.14.1 Algebra/Semirings/Examples/natural%20numbers 1`] = `
"Definition 2.7.14.1.  We define:

  ℕ := [ℕ, +, 0, ⋅, 1] is a semiring

References.

* https://en.wikipedia.org/wiki/Semiring#Examples
* https://ncatlab.org/nlab/show/rig#examples
* https://leanprover-community.github.io/mathlib_docs/core/init/data/nat/lemmas.html#nat.semiring"
`;

exports[`render hlm library: 2.7.15.1 Algebra/Semirings/Iterated%20operations/iterated%20sum 1`] = `
"Definition 2.7.15.1.  Let 𝐑 be a semiring. We define:

  ∑_𝐑 := ∏_[𝐑,+]

Example.

\`$../../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../Carrier(𝐑 = 𝐑), ⨂ = $\\"iterated sum\\"(𝐑 = 𝐑), n = n, _1 = {#(i: %Element($../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 2.7.15.2 Algebra/Semirings/Iterated%20operations/iterated%20product 1`] = `
"Definition 2.7.15.2.  Let 𝐑 be a commutative semiring. We define:

  ∏_𝐑 := ∏_[𝐑,⋅]

Example.

\`$../../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../Carrier(𝐑 = 𝐑), ⨂ = $\\"iterated product\\"(𝐑 = 𝐑), n = n, _1 = {#(i: %Element($../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 2.7.16.1 Algebra/Semirings/Formulas/Binomial%20theorem 1`] = `
"Theorem 2.7.16.1 (Binomial theorem).  Let 𝐑 be a semiring, a, b ∈ 𝐑, n ∈ ℕ. Then:

  (a + b)^n = ∑_𝐑_(k = 0)^n (n, k) ⋅ a^(n−k) ⋅ b^k

No proof.

References.

* https://en.wikipedia.org/wiki/Binomial_theorem
* https://mathworld.wolfram.com/BinomialTheorem.html
* https://proofwiki.org/wiki/Binomial_Theorem
* https://ncatlab.org/nlab/show/binomial+theorem#combinatorial_interpretation
* https://leanprover-community.github.io/mathlib_docs/data/nat/choose.html#add_pow"
`;

exports[`render hlm library: 2.8.1 Algebra/Rings/ring 1`] = `
"Definition 2.8.1.  Let R be a set, ⊕ : R × R → R be an operation on R, 0 ∈ R, ⊖ : R → R be a function, ⊙ : R × R → R be an operation on R, 1 ∈ R. We define:

  (R, ⊕, 0, ⊖, ⊙, 1) forms a ring  :⇔  (R, ⊕, 0, ⊖) forms an abelian group and (R, ⊙, 1) forms a monoid and ⊙ is distributive over ⊕ and 0 is an absorbing element for ⊙ and ∀ a, b ∈ R : a ⊙ ⊖(b) = ⊖(a) ⊙ b = ⊖(a ⊙ b)
    ⇔  (R, ⊕, 0, ⊖) forms an abelian group and (R, ⊙, 1) forms a monoid and ⊙ is distributive over ⊕
    ⇔  (R, ⊕, 0, ⊙, 1) forms a semiring and ∀ a ∈ R : a ⊕ ⊖(a) = ⊖(a) ⊕ a = 0

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Ring_(mathematics)
* https://mathworld.wolfram.com/UnitRing.html
* https://proofwiki.org/wiki/Definition:Ring_with_Unity
* https://ncatlab.org/nlab/show/ring
* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#ring_theory
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring"
`;

exports[`render hlm library: 2.8.2 Algebra/Rings/Rings 1`] = `
"Definition 2.8.2.  We define:

  𝓡𝓲𝓷𝓰 :=: {[R, ⊕, 0, ⊖, ⊙, 1] | R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring}

  [R, ⊕, 0, ⊖, ⊙, 1] = [S, ⋆, 𝟢, ∼, ∗, 𝟣]  :⇔  ∃ φ : R ↔ S : [⊕ ≃^φ ⋆ and 0 ≃^φ 𝟢 and ⊖ ≃^φ ∼ and ⊙ ≃^φ ∗ and 1 ≃^φ 𝟣]  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R, S is a set, ⋆ : S × S → S is an operation on S, 𝟢 ∈ S, ∼ : S → S is a function, ∗ : S × S → S is an operation on S, 𝟣 ∈ S with suitable conditions)

We write “let 𝐑 be a ring” for “let 𝐑 ∈ 𝓡𝓲𝓷𝓰.”

References.

* https://en.wikipedia.org/wiki/Ring_(mathematics)
* https://mathworld.wolfram.com/UnitRing.html
* https://proofwiki.org/wiki/Definition:Ring_with_Unity
* https://ncatlab.org/nlab/show/ring
* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#ring_theory
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring"
`;

exports[`render hlm library: 2.8.3 Algebra/Rings/Carrier 1`] = `
"Definition 2.8.3.  Let 𝐑 be a ring. We define

  (𝐑)

by:

  ([R, ⊕, 0, ⊖, ⊙, 1]) := R  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

We write “let a ∈ 𝐑” for “let a ∈ (𝐑).”

Remarks.

This definition retrieves a representative carrier set from a ring (which is actually an equivalence class of rings), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.8.4 Algebra/Rings/sum 1`] = `
"Definition 2.8.4.  Let 𝐑 be a ring, a, b ∈ 𝐑. We define:

  a + b := a ⊕ b if 𝐑 = [R, ⊕, 0, ⊖, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

Remarks.

This definition lets us add elements without decomposing the ring."
`;

exports[`render hlm library: 2.8.5 Algebra/Rings/zero 1`] = `
"Definition 2.8.5.  Let 𝐑 be a ring. We define

  0_𝐑

by:

  0_[R,⊕,0,⊖,⊙,1] := 0  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)"
`;

exports[`render hlm library: 2.8.6 Algebra/Rings/additive%20inverse 1`] = `
"Definition 2.8.6.  Let 𝐑 be a ring, a ∈ 𝐑. We define:

  −a := ⊖(a) if 𝐑 = [R, ⊕, 0, ⊖, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)"
`;

exports[`render hlm library: 2.8.7 Algebra/Rings/difference 1`] = `
"Definition 2.8.7.  Let 𝐑 be a ring, a, b ∈ 𝐑. We define:

  a − b := a + (−b)"
`;

exports[`render hlm library: 2.8.8 Algebra/Rings/additive%20group 1`] = `
"Definition 2.8.8.  Let 𝐑 be a ring. We define

  [𝐑, +]

by:

  [[R, ⊕, 0, ⊖, ⊙, 1], +] := [R, ⊕, 0, ⊖] is a group  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring.to_add_comm_group"
`;

exports[`render hlm library: 2.8.9 Algebra/Rings/product 1`] = `
"Definition 2.8.9.  Let 𝐑 be a ring, a, b ∈ 𝐑. We define:

  a ⋅ b := a ⊙ b if 𝐑 = [R, ⊕, 0, ⊖, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

Remarks.

This definition lets us multiply elements without decomposing the ring."
`;

exports[`render hlm library: 2.8.10 Algebra/Rings/one 1`] = `
"Definition 2.8.10.  Let 𝐑 be a ring. We define

  1_𝐑

by:

  1_[R,⊕,0,⊖,⊙,1] := 1  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)"
`;

exports[`render hlm library: 2.8.11 Algebra/Rings/commutative 1`] = `
"Definition 2.8.11.  Let 𝐑 be a ring. We define

  𝐑 is commutative

by:

  [R, ⊕, 0, ⊖, ⊙, 1] is commutative  :⇔  ⊙ is commutative  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)"
`;

exports[`render hlm library: 2.8.12 Algebra/Rings/multiplicative%20monoid 1`] = `
"Definition 2.8.12.  Let 𝐑 be a ring. We define

  [𝐑, ⋅]

by:

  [[R, ⊕, 0, ⊖, ⊙, 1], ⋅] := [R, ⊙, 1] is a monoid  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring.to_monoid"
`;

exports[`render hlm library: 2.8.13.1 Algebra/Rings/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.8.13.1.  Let 𝐑, 𝐒 be rings. We define:

  Hom(𝐑, 𝐒) := {f : (𝐑) → (𝐒) : [∀ a, b ∈ 𝐑 : f(a + b) = f(a) + f(b)] and f(0_𝐑) = 0_𝐒 and [∀ c ∈ 𝐑 : f(−c) = −f(c)] and [∀ d, e ∈ 𝐑 : f(d ⋅ e) = f(d) ⋅ f(e)] and f(1_𝐑) = 1_𝐒}
   = {f : (𝐑) → (𝐒) : [∀ a, b ∈ 𝐑 : f(a + b) = f(a) + f(b)] and [∀ d, e ∈ 𝐑 : f(d ⋅ e) = f(d) ⋅ f(e)] and f(1_𝐑) = 1_𝐒}

We write “let φ : 𝐑 → 𝐒 be a homomorphism” for “let φ ∈ Hom(𝐑, 𝐒).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Ring_homomorphism
* https://mathworld.wolfram.com/RingHomomorphism.html
* https://proofwiki.org/wiki/Definition:Unital_Ring_Homomorphism
* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#ring_morph
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring_hom"
`;

exports[`render hlm library: 2.8.13.2 Algebra/Rings/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.8.13.2.  Let 𝐑, 𝐒 be rings. We define:

  Iso(𝐑, 𝐒) := {homomorphisms φ : 𝐑 → 𝐒 : φ is bijective}
   = {f : (𝐑) ↔ (𝐒) : [∀ a, b ∈ 𝐑 : f(a + b) = f(a) + f(b)] and [∀ d, e ∈ 𝐑 : f(d ⋅ e) = f(d) ⋅ f(e)] and f(1_𝐑) = 1_𝐒}

We write “let φ : 𝐑 ↔ 𝐒 be an isomorphism” for “let φ ∈ Iso(𝐑, 𝐒).”

Equality.  No proof."
`;

exports[`render hlm library: 2.8.13.3 Algebra/Rings/Homomorphisms/Automorphisms 1`] = `
"Definition 2.8.13.3.  Let 𝐑 be a ring. We define:

  Aut(𝐑) := Iso(𝐑, 𝐑)

We write “let φ : 𝐑 ↔ 𝐑 be an automorphism” for “let φ ∈ Aut(𝐑).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism
* https://leanprover-community.github.io/mathlib_docs/data/equiv/ring.html#ring_aut"
`;

exports[`render hlm library: 2.8.13.4 Algebra/Rings/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.8.13.4.  Let 𝐑 be a ring. We define:

  Aut(𝐑) := [Aut(𝐑)]_(𝑆_(𝐑))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group
* https://leanprover-community.github.io/mathlib_docs/data/equiv/ring.html#ring_aut.group"
`;

exports[`render hlm library: 2.8.13.5 Algebra/Rings/Homomorphisms/Kernel 1`] = `
"Definition 2.8.13.5.  Let 𝐑, 𝐒 be rings, φ : 𝐑 → 𝐒 be a homomorphism. We define:

  Ker(φ) := φ^-1({0_𝐒})"
`;

exports[`render hlm library: 2.8.13.6 Algebra/Rings/Homomorphisms/identity 1`] = `
"Definition 2.8.13.6.  Let 𝐑 be a ring. We define:

  id_𝐑 := id_(𝐑)

References.

* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#IDphi
* https://leanprover-community.github.io/mathlib_docs/algebra/ring/basic.html#ring_hom.id"
`;

exports[`render hlm library: 2.8.13.7 Algebra/Rings/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.8.13.7.  Let 𝐑, 𝐒 be rings. Then the following are equivalent:

  1. Iso(𝐑, 𝐒) is nonempty
  2. 𝐑 = 𝐒

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of rings."
`;

exports[`render hlm library: 2.8.13.8 Algebra/Rings/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.8.13.8.  Let 𝐑, 𝐒 be rings, φ : 𝐑 ↔ 𝐒 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐒, 𝐑)

No proof."
`;

exports[`render hlm library: 2.8.14.1 Algebra/Rings/Subrings/subring%20set 1`] = `
"Definition 2.8.14.1.  Let 𝐑 be a ring, S ⊆ (𝐑). We define:

  S is a subring of 𝐑  :⇔  [∀ a, b ∈ S : a + b ∈ S] and 0_𝐑 ∈ S and [∀ c ∈ S : −c ∈ S] and [∀ d, e ∈ S : d ⋅ e ∈ S] and 1_𝐑 ∈ S

References.

* https://en.wikipedia.org/wiki/Subring
* https://proofwiki.org/wiki/Definition:Subring#Also_defined_as
* https://leanprover-community.github.io/mathlib_docs/ring_theory/subring.html#is_subring"
`;

exports[`render hlm library: 2.8.14.2 Algebra/Rings/Subrings/subset%20ring 1`] = `
"Definition 2.8.14.2.  Let 𝐑 be a ring, S ⊆ (𝐑) such that S is a subring of 𝐑. We define

  [S]_𝐑

by:

  [S]_[R,⊕,0,⊖,⊙,1] := [S, ⊕∣_S, 0, ⊖∣_S^S, ⊙∣_S, 1] is a ring  (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

References.

* https://leanprover-community.github.io/mathlib_docs/ring_theory/subring.html#subtype.ring"
`;

exports[`render hlm library: 2.8.14.3 Algebra/Rings/Subrings/subring 1`] = `
"Definition 2.8.14.3.  Let 𝐑, 𝐒 be rings. We define:

  𝐑 ≤ 𝐒  :⇔  ∃ homomorphism φ : 𝐑 → 𝐒 : φ is injective
    ⇔  ∃ S ⊆ (𝐒) : [S is a subring of 𝐒 and 𝐑 = [S]_𝐒]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.8.15 Algebra/Rings/unit 1`] = `
"Definition 2.8.15.  Let 𝐑 be a ring, a ∈ 𝐑. We define:

  a is a unit  :⇔  ∃ b ∈ 𝐑 : a ⋅ b = b ⋅ a = 1_𝐑
    ⇔  ∃! b ∈ 𝐑 : a ⋅ b = b ⋅ a = 1_𝐑

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Unit_(ring_theory)
* https://mathworld.wolfram.com/Unit.html
* https://proofwiki.org/wiki/Definition:Unit_of_Ring
* https://ncatlab.org/nlab/show/unit#units_in_rings
* https://leanprover-community.github.io/mathlib_docs/algebra/group/units.html#is_unit"
`;

exports[`render hlm library: 2.8.16 Algebra/Rings/Units 1`] = `
"Definition 2.8.16.  Let 𝐑 be a ring. We define:

  𝐑^× := {a ∈ 𝐑 : a is a unit}

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group/units.html#units"
`;

exports[`render hlm library: 2.8.17 Algebra/Rings/multiplicative%20inverse 1`] = `
"Definition 2.8.17.  Let 𝐑 be a ring, a ∈ 𝐑^×. For b ∈ 𝐑^×, we define:

  a^-1 = b  :⇔  a ⋅ b = 1_𝐑

Well-definedness.  No proof."
`;

exports[`render hlm library: 2.8.18 Algebra/Rings/unit%20group 1`] = `
"Definition 2.8.18.  Let 𝐑 be a ring. We define:

  [𝐑^×] := [𝐑^×, ⊙∣_(𝐑^×), 1, (𝐑^× → 𝐑^×, a ↦ a^-1)] if 𝐑 = [R, ⊕, 0, ⊖, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

References.

* https://en.wikipedia.org/wiki/Unit_(ring_theory)#Group_of_units
* https://proofwiki.org/wiki/Definition:Group_of_Units/Ring
* https://leanprover-community.github.io/mathlib_docs/algebra/group/units.html#units.comm_group"
`;

exports[`render hlm library: 2.8.19 Algebra/Rings/product%20with%20natural%20number 1`] = `
"Definition 2.8.19.  Let 𝐑 be a ring, n ∈ ℕ, a ∈ 𝐑. We define

  n ⋅ a

by:

  0 ⋅ a := 0_𝐑
  (x + 1) ⋅ a := x ⋅ a + a  (x ∈ ℕ)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#add_monoid.smul"
`;

exports[`render hlm library: 2.8.20 Algebra/Rings/product%20with%20integer 1`] = `
"Definition 2.8.20.  Let 𝐑 be a ring, z ∈ ℤ, a ∈ 𝐑. We define:

  z ⋅ a := {z ⋅ a if z ≥ 0, (−z) ⋅ (−a) if z < 0

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#gsmul"
`;

exports[`render hlm library: 2.8.21 Algebra/Rings/power%20to%20natural%20number 1`] = `
"Definition 2.8.21.  Let 𝐑 be a ring, a ∈ 𝐑, n ∈ ℕ. We define

  a^n

by:

  a^0 := 1_𝐑
  a^(x+1) := a^x ⋅ a  (x ∈ ℕ)

References.

* https://coq.inria.fr/library/Coq.setoid_ring.Ring_theory.html#pow_N"
`;

exports[`render hlm library: 2.8.22.1 Algebra/Rings/Ideals/left%20ideal 1`] = `
"Definition 2.8.22.1.  Let 𝐑 be a ring, I ⊆ (𝐑). We define:

  I is a left ideal of 𝐑  :⇔  I is a subgroup of [𝐑, +] and ∀ i ∈ I, r ∈ 𝐑 : r ⋅ i ∈ I

References.

* https://en.wikipedia.org/wiki/Ideal_(ring_theory)
* https://mathworld.wolfram.com/LeftIdeal.html
* https://proofwiki.org/wiki/Definition:Ideal_of_Ring/Left_Ideal
* https://ncatlab.org/nlab/show/ideal#in_rings_and_other_rigs"
`;

exports[`render hlm library: 2.8.22.2 Algebra/Rings/Ideals/right%20ideal 1`] = `
"Definition 2.8.22.2.  Let 𝐑 be a ring, I ⊆ (𝐑). We define:

  I is a right ideal of 𝐑  :⇔  I is a subgroup of [𝐑, +] and ∀ i ∈ I, r ∈ 𝐑 : i ⋅ r ∈ I

References.

* https://en.wikipedia.org/wiki/Ideal_(ring_theory)
* https://mathworld.wolfram.com/RightIdeal.html
* https://proofwiki.org/wiki/Definition:Ideal_of_Ring/Right_Ideal
* https://ncatlab.org/nlab/show/ideal#in_rings_and_other_rigs"
`;

exports[`render hlm library: 2.8.22.3 Algebra/Rings/Ideals/ideal 1`] = `
"Definition 2.8.22.3.  Let 𝐑 be a ring, I ⊆ (𝐑). We define:

  I is an ideal of 𝐑  :⇔  I is a left ideal of 𝐑 and I is a right ideal of 𝐑
    ⇔  ∃ ring 𝐒, homomorphism φ : 𝐑 → 𝐒 : I = Ker(φ)

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Ideal_(ring_theory)
* https://mathworld.wolfram.com/Ideal.html
* https://proofwiki.org/wiki/Definition:Ideal_of_Ring
* https://ncatlab.org/nlab/show/ideal#in_rings_and_other_rigs
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#ideal"
`;

exports[`render hlm library: 2.8.23.1 Algebra/Rings/Quotients/quotient%20ring 1`] = `
"Definition 2.8.23.1.  Let 𝐑 be a ring, I ⊆ (𝐑) such that I is an ideal of 𝐑, ∼ := [∃ s ∈ I : g + s = h]_(g,h ∈ (𝐑)), Q := (𝐑)∕∼. We define:

  𝐑∕I := [Q, (Q × Q → Q, ([g]_∼, [h]_∼) ↦ [g + h]_∼), [0_𝐑]_∼, (Q → Q, [g]_∼ ↦ [−g]_∼), (Q × Q → Q, ([g]_∼, [h]_∼) ↦ [g ⋅ h]_∼), [1_𝐑]_∼] is a ring

References.

* https://en.wikipedia.org/wiki/Quotient_ring
* https://mathworld.wolfram.com/QuotientRing.html
* https://proofwiki.org/wiki/Definition:Quotient_Ring
* https://ncatlab.org/nlab/show/quotient+ring
* https://leanprover-community.github.io/mathlib_docs/ring_theory/ideal/basic.html#ideal.quotient.comm_ring"
`;

exports[`render hlm library: 2.8.24.1 Algebra/Rings/Examples/integers 1`] = `
"Definition 2.8.24.1.  We define:

  ℤ := [ℤ, +, 0, −, ⋅, 1] is a ring

References.

* https://en.wikipedia.org/wiki/Ring_(mathematics)#Basic_examples
* https://ncatlab.org/nlab/show/ring#Examples
* https://leanprover-community.github.io/mathlib_docs/core/init/data/int/basic.html#int.comm_ring"
`;

exports[`render hlm library: 2.8.24.2 Algebra/Rings/Examples/Multiples%20are%20an%20ideal%20of%20integers 1`] = `
"Proposition 2.8.24.2.  Let n ∈ ℕ. Then:

  nℤ is an ideal of ℤ

No proof.

References.

* https://en.wikipedia.org/wiki/Ideal_(ring_theory)#Examples_and_properties"
`;

exports[`render hlm library: 2.8.25.1 Algebra/Rings/Iterated%20operations/iterated%20sum 1`] = `
"Definition 2.8.25.1.  Let 𝐑 be a ring. We define:

  ∑_𝐑 := ∏_[𝐑,+]

Example.

\`$../../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../Carrier(𝐑 = 𝐑), ⨂ = $\\"iterated sum\\"(𝐑 = 𝐑), n = n, _1 = {#(i: %Element($../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 2.8.25.2 Algebra/Rings/Iterated%20operations/iterated%20product 1`] = `
"Definition 2.8.25.2.  Let 𝐑 be a commutative ring. We define:

  ∏_𝐑 := ∏_[𝐑,⋅]

Example.

\`$../../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $../Carrier(𝐑 = 𝐑), ⨂ = $\\"iterated product\\"(𝐑 = 𝐑), n = n, _1 = {#(i: %Element($../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_pi_notation
* https://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 2.8.26.1 Algebra/Rings/Polynomials/Polynomials 1`] = `
"Definition 2.8.26.1.  Let 𝐑 be a ring, X be a variable. We define:

  𝐑[X] :=: {(0)_(𝐑[X]), (pX+a) | p ∈ 𝐑[X], a ∈ 𝐑 such that [p ≠ (0)_(𝐑[X]) or a ≠ 0_𝐑]}

  (pX+a) = (qX+b)  :⇔  p = q and a = b  (p ∈ 𝐑[X], a ∈ 𝐑, q ∈ 𝐑[X], b ∈ 𝐑 with suitable conditions)

(𝐑) ⊆: 𝐑[X] via
a = {(0)_(𝐑[X]) if a = 0_𝐑, ((0)_(𝐑[X])X+a) if a ≠ 0_𝐑

  Well-definedness.  No proof.

Remarks.

The variable \`X\` does not serve any mathematical purpose but helps improve readability. However, it is important that polynomials are defined as a construction so that two polynomials using different variables cannot be mixed.

There are, of course, various different ways to formalize abstract polynomials. We chose to define polynomials inductively in such a way that each inductive step adds one coefficient. The highest coefficient is not allowed to be 0; otherwise equality of polynomials would not behave as expected.

References.

* https://en.wikipedia.org/wiki/Polynomial#Abstract_algebra
* https://proofwiki.org/wiki/Definition:Polynomial_over_Ring/One_Variable
* https://ncatlab.org/nlab/show/polynomial
* https://leanprover-community.github.io/mathlib_docs/data/polynomial/basic.html#polynomial"
`;

exports[`render hlm library: 2.8.26.2 Algebra/Rings/Polynomials/normalized 1`] = `
"Definition 2.8.26.2.  Let 𝐑 be a ring, X be a variable, p ∈ 𝐑[X], a ∈ 𝐑. We define:

  [pX+a] := {(pX+a) if p ≠ (0)_(𝐑[X]) or a ≠ 0_𝐑, (0)_(𝐑[X]) if p = (0)_(𝐑[X]) and a = 0_𝐑

Remarks.

This definition can be understood as follows:
* Usually, it just yields the constructor term with the given arguments.
* However, if \`p\` is the zero polynomial and \`a\` is zero, that term would be invalid, and the zero polynomial must be returned instead."
`;

exports[`render hlm library: 2.8.26.3 Algebra/Rings/Polynomials/monomial 1`] = `
"Definition 2.8.26.3.  Let 𝐑 be a ring, X be a variable, a ∈ 𝐑, n ∈ ℕ. We define

  aX^n

by:

  aX^0 := a
  aX^(m+1) := [(aX^m)X+0_𝐑]  (m ∈ ℕ)

Remarks.

This definition is useful to build polynomials in their familiar style."
`;

exports[`render hlm library: 2.8.26.4 Algebra/Rings/Polynomials/monomial%20with%20exponent%20one 1`] = `
"Definition 2.8.26.4.  Let 𝐑 be a ring, X be a variable, a ∈ 𝐑. We define:

  aX := aX^1
   = [aX+(0)_(𝐑[X])]
   = {(0)_(𝐑[X]) if a = 0_𝐑, (aX+0_𝐑) if a ≠ 0_𝐑

Equality.  No proof."
`;

exports[`render hlm library: 2.8.26.5 Algebra/Rings/Polynomials/sum 1`] = `
"Definition 2.8.26.5.  Let 𝐑 be a ring, X be a variable, p, q ∈ 𝐑[X]. We define

  p + q

by:

  p + (0)_(𝐑[X]) := p
  (0)_(𝐑[X]) + (sX+b) := (sX+b)  (s ∈ 𝐑[X], b ∈ 𝐑 such that [s ≠ (0)_(𝐑[X]) or b ≠ 0_𝐑])
  (rX+a) + (sX+b) := [(r + s)X+(a + b)]  (r ∈ 𝐑[X], a ∈ 𝐑, s ∈ 𝐑[X], b ∈ 𝐑 with suitable conditions)"
`;

exports[`render hlm library: 2.8.26.6 Algebra/Rings/Polynomials/additive%20inverse 1`] = `
"Definition 2.8.26.6.  Let 𝐑 be a ring, X be a variable, p ∈ 𝐑[X]. We define

  −p

by:

  −(0)_(𝐑[X]) := (0)_(𝐑[X])
  −(qX+a) := ((−q)X+(−a))  (q ∈ 𝐑[X], a ∈ 𝐑 such that [q ≠ (0)_(𝐑[X]) or a ≠ 0_𝐑])"
`;

exports[`render hlm library: 2.8.26.7 Algebra/Rings/Polynomials/difference 1`] = `
"Definition 2.8.26.7.  Let 𝐑 be a ring, X be a variable, p, q ∈ 𝐑[X]. We define:

  p − q := p + (−q)"
`;

exports[`render hlm library: 2.8.26.8 Algebra/Rings/Polynomials/product%20with%20left%20scalar 1`] = `
"Definition 2.8.26.8.  Let 𝐑 be a ring, X be a variable, a ∈ 𝐑, p ∈ 𝐑[X]. We define

  a ⋅ p

by:

  a ⋅ (0)_(𝐑[X]) := (0)_(𝐑[X])
  a ⋅ (qX+b) := [(a ⋅ q)X+(a ⋅ b)]  (q ∈ 𝐑[X], b ∈ 𝐑 such that [q ≠ (0)_(𝐑[X]) or b ≠ 0_𝐑])"
`;

exports[`render hlm library: 2.8.26.9 Algebra/Rings/Polynomials/product%20with%20right%20scalar 1`] = `
"Definition 2.8.26.9.  Let 𝐑 be a ring, X be a variable, p ∈ 𝐑[X], a ∈ 𝐑. We define

  p ⋅ a

by:

  (0)_(𝐑[X]) ⋅ a := (0)_(𝐑[X])
  (qX+b) ⋅ a := [(q ⋅ a)X+(b ⋅ a)]  (q ∈ 𝐑[X], b ∈ 𝐑 such that [q ≠ (0)_(𝐑[X]) or b ≠ 0_𝐑])"
`;

exports[`render hlm library: 2.8.26.10 Algebra/Rings/Polynomials/product 1`] = `
"Definition 2.8.26.10.  Let 𝐑 be a ring, X be a variable, p, q ∈ 𝐑[X]. We define

  p ⋅ q

by:

  (0)_(𝐑[X]) ⋅ q := (0)_(𝐑[X])
  (rX+a) ⋅ q := [(r ⋅ q)X+0_𝐑] + a ⋅ q  (r ∈ 𝐑[X], a ∈ 𝐑 such that [r ≠ (0)_(𝐑[X]) or a ≠ 0_𝐑])"
`;

exports[`render hlm library: 2.8.26.11 Algebra/Rings/Polynomials/polynomial%20ring 1`] = `
"Definition 2.8.26.11.  Let 𝐑 be a ring, X be a variable. We define:

  𝐑[X] := [𝐑[X], +, (0)_(𝐑[X]), −, ⋅, 1_𝐑] is a ring

References.

* https://en.wikipedia.org/wiki/Polynomial_ring
* https://proofwiki.org/wiki/Definition:Polynomial_Ring#One_Indeterminate
* https://ncatlab.org/nlab/show/polynomial
* https://leanprover-community.github.io/mathlib_docs/data/polynomial/basic.html#polynomial.comm_semiring"
`;

exports[`render hlm library: 2.8.26.12 Algebra/Rings/Polynomials/value 1`] = `
"Definition 2.8.26.12.  Let 𝐑 be a ring, X be a variable, p ∈ 𝐑[X], a ∈ 𝐑 such that ∀ r ∈ 𝐑 : a ⋅ r = r ⋅ a. We define

  p(a)

by:

  (0)_(𝐑[X])(a) := 0_𝐑
  (qX+b)(a) := q(a) ⋅ a + b  (q ∈ 𝐑[X], b ∈ 𝐑 such that [q ≠ (0)_(𝐑[X]) or b ≠ 0_𝐑])

References.

* https://en.wikipedia.org/wiki/Polynomial_ring#Polynomial_evaluation
* https://leanprover-community.github.io/mathlib_docs/data/polynomial/basic.html#polynomial.eval"
`;

exports[`render hlm library: 2.8.26.13 Algebra/Rings/Polynomials/dimension 1`] = `
"Definition 2.8.26.13.  Let 𝐑 be a ring, X be a variable, p ∈ 𝐑[X]. We define

  dim(p)

by:

  dim((0)_(𝐑[X])) := 0
  dim(qX+a) := dim(q) + 1  (q ∈ 𝐑[X], a ∈ 𝐑 such that [q ≠ (0)_(𝐑[X]) or a ≠ 0_𝐑])

Remarks.

This is mostly a helper definition to define the degree (see \`$degree\`). However, in many cases this definition may actually be more useful than the degree itself.

It is called \\"dimension\\" because for a field \`𝐅\`, the set of polynomials over \`𝐅\` with \\"dimension\\" \`d\` form a \`d\`-dimensional vector space over \`𝐅\`."
`;

exports[`render hlm library: 2.8.26.14 Algebra/Rings/Polynomials/degree 1`] = `
"Definition 2.8.26.14.  Let 𝐑 be a ring, X be a variable, p ∈ 𝐑[X] ∖ {(0)_(𝐑[X])}. We define:

  deg(p) := dim(p) − 1

References.

* https://en.wikipedia.org/wiki/Degree_of_a_polynomial
* https://mathworld.wolfram.com/PolynomialDegree.html
* https://proofwiki.org/wiki/Definition:Degree_of_Polynomial#One_variable
* https://leanprover-community.github.io/mathlib_docs/data/polynomial/basic.html#polynomial.degree"
`;

exports[`render hlm library: 2.8.27 Algebra/Rings/kronecker%20delta 1`] = `
"Definition 2.8.27 (Kronecker delta).  Let 𝐑 be a ring, S be a set, i, j ∈ S. We define:

  δ_𝐑,i,j := {1_𝐑 if i = j, 0_𝐑 if i ≠ j

References.

* https://en.wikipedia.org/wiki/Kronecker_delta
* https://mathworld.wolfram.com/KroneckerDelta.html
* https://proofwiki.org/wiki/Definition:Kronecker_Delta
* https://ncatlab.org/nlab/show/Kronecker+delta"
`;

exports[`render hlm library: 2.8.28.1 Algebra/Rings/Matrices/Matrices 1`] = `
"Definition 2.8.28.1.  Let 𝐑 be a ring, m, n ∈ ℕ. We define:

  𝐑^(m×n) :=: {[a_i,j]_i < m,j < n | a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n)}

  [a_i,j]_i < m,j < n = [b_i,j]_i < m,j < n  :⇔  ∀ i ∈ ℕ_(<m), j ∈ ℕ_(<n) : a_i,j = b_i,j  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n), b_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n))

References.

* https://en.wikipedia.org/wiki/Matrix_(mathematics)
* https://mathworld.wolfram.com/Matrix.html
* https://proofwiki.org/wiki/Definition:Matrix
* https://ncatlab.org/nlab/show/matrix
* https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html#matrix"
`;

exports[`render hlm library: 2.8.28.2 Algebra/Rings/Matrices/Vectors 1`] = `
"Definition 2.8.28.2.  Let 𝐑 be a ring, n ∈ ℕ. We define:

  𝐑^n := 𝐑^(1×n)

References.

* https://en.wikipedia.org/wiki/Row_and_column_vectors
* https://mathworld.wolfram.com/ColumnVector.html
* https://proofwiki.org/wiki/Definition:Column_Matrix"
`;

exports[`render hlm library: 2.8.28.3 Algebra/Rings/Matrices/matrix 1`] = `
"Definition 2.8.28.3 (Matrix notation).

We write:

\`$matrix(𝐑 = 𝐑, items = [[\\"a_0,0\\", \\"a_1,0\\", \\"⋯\\", \\"a_m-1,0\\"],[\\"a_0,1\\", \\"a_1,1\\", \\"⋯\\", \\"a_m-1,1\\"],[\\"⋮\\", \\"⋮\\", \\" \\", \\"⋮\\"],[\\"a_0,n-1\\", \\"a_1,n-1\\", \\"⋯\\", \\"a_m-1,n-1\\"]])\` := \`$Matrices(𝐑 = 𝐑, m = m, n = n).matrix(_1 = {#(i: %Element($../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = m)), j: %Element($../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = \\"a_i,j\\"}})\`"
`;

exports[`render hlm library: 2.8.28.4 Algebra/Rings/Matrices/sum 1`] = `
"Definition 2.8.28.4.  Let 𝐑 be a ring, m, n ∈ ℕ, A, B ∈ 𝐑^(m×n). We define

  A + B

by:

  [a_i,j]_i < m,j < n + [b_i,j]_i < m,j < n := [a_i,j + b_i,j]_i < m,j < n  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n), b_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n))"
`;

exports[`render hlm library: 2.8.28.5 Algebra/Rings/Matrices/zero 1`] = `
"Definition 2.8.28.5.  Let 𝐑 be a ring, m, n ∈ ℕ. We define:

  0_(𝐑^(m×n)) := [0_𝐑]_i < m,j < n"
`;

exports[`render hlm library: 2.8.28.6 Algebra/Rings/Matrices/additive%20inverse 1`] = `
"Definition 2.8.28.6.  Let 𝐑 be a ring, m, n ∈ ℕ, A ∈ 𝐑^(m×n). We define

  −A

by:

  −[a_i,j]_i < m,j < n := [−a_i,j]_i < m,j < n  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n))"
`;

exports[`render hlm library: 2.8.28.7 Algebra/Rings/Matrices/difference 1`] = `
"Definition 2.8.28.7.  Let 𝐑 be a ring, m, n ∈ ℕ, A, B ∈ 𝐑^(m×n). We define

  A − B

by:

  [a_i,j]_i < m,j < n − [b_i,j]_i < m,j < n := [a_i,j − b_i,j]_i < m,j < n  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n), b_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n))"
`;

exports[`render hlm library: 2.8.28.8 Algebra/Rings/Matrices/product 1`] = `
"Definition 2.8.28.8.  Let 𝐑 be a ring, l, m, n ∈ ℕ, A ∈ 𝐑^(l×m), B ∈ 𝐑^(m×n). We define

  A ⋅ B

by:

  [a_i,j]_i < l,j < m ⋅ [b_j,k]_j < m,k < n := [∑_𝐑_(j < m) a_i,j ⋅ b_j,k]_i < l,k < n  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<l) and j ∈ ℕ_(<m), b_j,k ∈ 𝐑 for each j ∈ ℕ_(<m) and k ∈ ℕ_(<n))

References.

* https://en.wikipedia.org/wiki/Matrix_multiplication
* https://mathworld.wolfram.com/MatrixMultiplication.html
* https://proofwiki.org/wiki/Definition:Matrix_Product_(Conventional)
* https://ncatlab.org/nlab/show/matrix+calculus
* https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html#matrix.mul"
`;

exports[`render hlm library: 2.8.28.9 Algebra/Rings/Matrices/product%20with%20left%20scalar 1`] = `
"Definition 2.8.28.9.  Let 𝐑 be a ring, m, n ∈ ℕ, r ∈ 𝐑, A ∈ 𝐑^(m×n). We define

  r ⋅ A

by:

  r ⋅ [a_i,j]_i < m,j < n := [r ⋅ a_i,j]_i < m,j < n  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n))"
`;

exports[`render hlm library: 2.8.28.10 Algebra/Rings/Matrices/product%20with%20right%20scalar 1`] = `
"Definition 2.8.28.10.  Let 𝐑 be a ring, m, n ∈ ℕ, A ∈ 𝐑^(m×n), r ∈ 𝐑. We define

  A ⋅ r

by:

  [a_i,j]_i < m,j < n ⋅ r := [a_i,j ⋅ r]_i < m,j < n  (a_i,j ∈ 𝐑 for each i ∈ ℕ_(<m) and j ∈ ℕ_(<n))"
`;

exports[`render hlm library: 2.8.28.11 Algebra/Rings/Matrices/identity 1`] = `
"Definition 2.8.28.11.  Let 𝐑 be a ring, n ∈ ℕ. We define:

  I_(𝐑^(n×n)) := [δ_𝐑,i,j]_i < n,j < n

References.

* https://en.wikipedia.org/wiki/Identity_matrix
* https://mathworld.wolfram.com/IdentityMatrix.html
* https://proofwiki.org/wiki/Definition:Unit_Matrix
* https://ncatlab.org/nlab/show/identity+matrix
* https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html#matrix.has_one"
`;

exports[`render hlm library: 2.8.28.12 Algebra/Rings/Matrices/matrix%20ring 1`] = `
"Definition 2.8.28.12.  Let 𝐑 be a ring, n ∈ ℕ. We define:

  𝐑^(n×n) := [𝐑^(n×n), +, 0_(𝐑^(n×n)), −, ⋅, I_(𝐑^(n×n))] is a ring

References.

* https://en.wikipedia.org/wiki/Matrix_ring
* https://proofwiki.org/wiki/Definition:Ring_of_Square_Matrices
* https://ncatlab.org/nlab/show/matrix+algebra
* https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html#matrix.ring"
`;

exports[`render hlm library: 2.8.28.13.1 Algebra/Rings/Matrices/Examples/Identity%20matrix%20of%20dimension%201 1`] = `
"Example 2.8.28.13.1.  Let 𝐑 be a ring. Then:

  I_(𝐑^(1×1)) = [1_𝐑]

No proof."
`;

exports[`render hlm library: 2.8.28.13.2 Algebra/Rings/Matrices/Examples/Identity%20matrix%20of%20dimension%202 1`] = `
"Example 2.8.28.13.2.  Let 𝐑 be a ring. Then:

  I_(𝐑^(2×2)) = [1_𝐑 0_𝐑, 0_𝐑 1_𝐑]

No proof."
`;

exports[`render hlm library: 2.8.29.1.1 Algebra/Rings/Modules/Left%20modules/left%20module 1`] = `
"Definition 2.8.29.1.1.  Let 𝐑 be a ring, M be a set, ⊕ : M × M → M be an operation on M, 0 ∈ M, ⊖ : M → M be a function, ⊙ : (𝐑) × M → M be an operation. We define:

  (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module  :⇔  (M, ⊕, 0, ⊖) forms an abelian group and ⊙ is left-distributive over ⊕ and [∀ a, b ∈ 𝐑, x ∈ M : (a + b) ⊙ x = (a ⊙ x) ⊕ (b ⊙ x)] and [∀ x ∈ M : 0_𝐑 ⊙ x = 0] and 0 is a right absorbing element for ⊙ and [∀ a ∈ 𝐑, x ∈ M : (−a) ⊙ x = a ⊙ ⊖(x) = ⊖(a ⊙ x)] and [∀ a, b ∈ 𝐑, x ∈ M : (a ⋅ b) ⊙ x = a ⊙ (b ⊙ x)] and 1_𝐑 is a left identity for ⊙
    ⇔  (M, ⊕, 0, ⊖) forms an abelian group and ⊙ is left-distributive over ⊕ and [∀ a, b ∈ 𝐑, x ∈ M : (a + b) ⊙ x = (a ⊙ x) ⊕ (b ⊙ x)] and [∀ a, b ∈ 𝐑, x ∈ M : (a ⋅ b) ⊙ x = a ⊙ (b ⊙ x)] and 1_𝐑 is a left identity for ⊙

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)
* https://mathworld.wolfram.com/Module.html
* https://proofwiki.org/wiki/Definition:Unitary_Module
* https://ncatlab.org/nlab/show/module#ModulesOverARingInTermsOfStabilizedSlices
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#module"
`;

exports[`render hlm library: 2.8.29.1.2 Algebra/Rings/Modules/Left%20modules/Left%20modules 1`] = `
"Definition 2.8.29.1.2.  Let 𝐑 be a ring. We define:

  𝓛𝓜𝓸𝓭(𝐑) :=: {[M, ⊕, 0, ⊖, ⊙]_𝐑 | M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module}

  [M, ⊕, 0, ⊖, ⊙]_𝐑 = [N, ⋆, 𝟢, ∼, ∗]_𝐑  :⇔  ∃ φ : M ↔ N : [⊕ ≃^φ ⋆ and 0 ≃^φ 𝟢 and ⊖ ≃^φ ∼ and ⊙ ≃^φ ∗]  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation, N is a set, ⋆ : N × N → N is an operation on N, 𝟢 ∈ N, ∼ : N → N is a function, ∗ : (𝐑) × N → N is an operation with suitable conditions)

We write “let 𝐌 be a left 𝐑-module” for “let 𝐌 ∈ 𝓛𝓜𝓸𝓭(𝐑).”

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)
* https://mathworld.wolfram.com/Module.html
* https://proofwiki.org/wiki/Definition:Unitary_Module
* https://ncatlab.org/nlab/show/module#ModulesOverARingInTermsOfStabilizedSlices
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#module"
`;

exports[`render hlm library: 2.8.29.1.3 Algebra/Rings/Modules/Left%20modules/Carrier 1`] = `
"Definition 2.8.29.1.3.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define

  (𝐌)

by:

  ([M, ⊕, 0, ⊖, ⊙]_𝐑) := M  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)

We write “let x ∈ 𝐌” for “let x ∈ (𝐌).”

Remarks.

This definition retrieves a representative carrier set from a module (which is actually an equivalence class of modules), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.8.29.1.4 Algebra/Rings/Modules/Left%20modules/sum 1`] = `
"Definition 2.8.29.1.4.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, x, y ∈ 𝐌. We define:

  x + y := x ⊕ y if 𝐌 = [M, ⊕, 0, ⊖, ⊙]_𝐑 (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.1.5 Algebra/Rings/Modules/Left%20modules/zero 1`] = `
"Definition 2.8.29.1.5.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define

  0_𝐌

by:

  0_([M,⊕,0,⊖,⊙]_𝐑) := 0  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.1.6 Algebra/Rings/Modules/Left%20modules/additive%20inverse 1`] = `
"Definition 2.8.29.1.6.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, x ∈ 𝐌. We define:

  −x := ⊖(x) if 𝐌 = [M, ⊕, 0, ⊖, ⊙]_𝐑 (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.1.7 Algebra/Rings/Modules/Left%20modules/difference 1`] = `
"Definition 2.8.29.1.7.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, x, y ∈ 𝐌. We define:

  x − y := x + (−y)"
`;

exports[`render hlm library: 2.8.29.1.8 Algebra/Rings/Modules/Left%20modules/additive%20group 1`] = `
"Definition 2.8.29.1.8.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define

  [𝐌, +]

by:

  [[M, ⊕, 0, ⊖, ⊙]_𝐑, +] := [M, ⊕, 0, ⊖] is a group  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)

Remarks.

Addition of module elements as a group."
`;

exports[`render hlm library: 2.8.29.1.9 Algebra/Rings/Modules/Left%20modules/product 1`] = `
"Definition 2.8.29.1.9.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, a ∈ 𝐑, x ∈ 𝐌. We define:

  a ⋅ x := a ⊙ x if 𝐌 = [M, ⊕, 0, ⊖, ⊙]_𝐑 (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.1.10 Algebra/Rings/Modules/Left%20modules/iterated%20sum 1`] = `
"Definition 2.8.29.1.10.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  ∑_𝐌 := ∏_[𝐌,+]

Example.

\`$../../../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $Carrier(𝐑 = 𝐑, 𝐌 = 𝐌), ⨂ = $\\"iterated sum\\"(𝐑 = 𝐑, 𝐌 = 𝐌), n = n, _1 = {#(i: %Element($../../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 2.8.29.1.11.1 Algebra/Rings/Modules/Left%20modules/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.8.29.1.11.1.  Let 𝐑 be a ring, 𝐌, 𝐍 be left 𝐑-modules. We define:

  Hom(𝐌, 𝐍) := {f : (𝐌) → (𝐍) : [∀ x, y ∈ 𝐌 : f(x + y) = f(x) + f(y)] and f(0_𝐌) = 0_𝐍 and [∀ z ∈ 𝐌 : f(−z) = −f(z)] and ∀ a ∈ 𝐑, w ∈ 𝐌 : f(a ⋅ w) = a ⋅ f(w)}
   = {f : (𝐌) → (𝐍) : ∀ a, b ∈ 𝐑, x, y ∈ 𝐌 : f(a ⋅ x + b ⋅ y) = a ⋅ f(x) + b ⋅ f(y)}

We write “let φ : 𝐌 → 𝐍 be a homomorphism” for “let φ ∈ Hom(𝐌, 𝐍).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_homomorphism
* https://proofwiki.org/wiki/Definition:Linear_Transformation
* https://ncatlab.org/nlab/show/homomorphism
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#linear_map"
`;

exports[`render hlm library: 2.8.29.1.11.2 Algebra/Rings/Modules/Left%20modules/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.8.29.1.11.2.  Let 𝐑 be a ring, 𝐌, 𝐍 be left 𝐑-modules. We define:

  Iso(𝐌, 𝐍) := {homomorphisms φ : 𝐌 → 𝐍 : φ is bijective}
   = {f : (𝐌) ↔ (𝐍) : ∀ a, b ∈ 𝐑, x, y ∈ 𝐌 : f(a ⋅ x + b ⋅ y) = a ⋅ f(x) + b ⋅ f(y)}

We write “let φ : 𝐌 ↔ 𝐍 be an isomorphism” for “let φ ∈ Iso(𝐌, 𝐍).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_homomorphism#Terminology
* https://proofwiki.org/wiki/Definition:Isomorphism_(Abstract_Algebra)/R-Algebraic_Structure_Isomorphism/Module_Isomorphism
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 2.8.29.1.11.3 Algebra/Rings/Modules/Left%20modules/Homomorphisms/Automorphisms 1`] = `
"Definition 2.8.29.1.11.3.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  Aut(𝐌) := Iso(𝐌, 𝐌)

We write “let φ : 𝐌 ↔ 𝐌 be an automorphism” for “let φ ∈ Aut(𝐌).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism"
`;

exports[`render hlm library: 2.8.29.1.11.4 Algebra/Rings/Modules/Left%20modules/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.8.29.1.11.4.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  Aut(𝐌) := [Aut(𝐌)]_(𝑆_(𝐌))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group"
`;

exports[`render hlm library: 2.8.29.1.11.5 Algebra/Rings/Modules/Left%20modules/Homomorphisms/Kernel 1`] = `
"Definition 2.8.29.1.11.5.  Let 𝐑 be a ring, 𝐌, 𝐍 be left 𝐑-modules, φ : 𝐌 → 𝐍 be a homomorphism. We define:

  Ker(φ) := φ^-1({0_𝐍})

References.

* https://en.wikipedia.org/wiki/Module_homomorphism
* https://mathworld.wolfram.com/ModuleKernel.html
* https://proofwiki.org/wiki/Definition:Kernel_of_Linear_Transformation
* https://ncatlab.org/nlab/show/kernel
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/basic.html#linear_map.ker"
`;

exports[`render hlm library: 2.8.29.1.11.6 Algebra/Rings/Modules/Left%20modules/Homomorphisms/identity 1`] = `
"Definition 2.8.29.1.11.6.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  id_𝐌 := id_(𝐌)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#linear_map.id"
`;

exports[`render hlm library: 2.8.29.1.11.7 Algebra/Rings/Modules/Left%20modules/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.8.29.1.11.7.  Let 𝐑 be a ring, 𝐌, 𝐍 be left 𝐑-modules. Then the following are equivalent:

  1. Iso(𝐌, 𝐍) is nonempty
  2. 𝐌 = 𝐍

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of modules."
`;

exports[`render hlm library: 2.8.29.1.11.8 Algebra/Rings/Modules/Left%20modules/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.8.29.1.11.8.  Let 𝐑 be a ring, 𝐌, 𝐍 be left 𝐑-modules, φ : 𝐌 ↔ 𝐍 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐍, 𝐌)

No proof."
`;

exports[`render hlm library: 2.8.29.1.12.1 Algebra/Rings/Modules/Left%20modules/Submodules/submodule%20set 1`] = `
"Definition 2.8.29.1.12.1.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, S ⊆ (𝐌). We define:

  S is a submodule of 𝐌  :⇔  [∀ a, b ∈ S : a + b ∈ S] and 0_𝐌 ∈ S and [∀ c ∈ S : −c ∈ S] and ∀ d ∈ 𝐑, e ∈ S : d ⋅ e ∈ S
    ⇔  ∀ d ∈ 𝐑, e ∈ S : d ⋅ e ∈ S

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)#Submodules_and_homomorphisms
* https://mathworld.wolfram.com/Submodule.html
* https://proofwiki.org/wiki/Definition:Submodule
* https://ncatlab.org/nlab/show/submodule
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#submodule"
`;

exports[`render hlm library: 2.8.29.1.12.2 Algebra/Rings/Modules/Left%20modules/Submodules/subset%20module 1`] = `
"Definition 2.8.29.1.12.2.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, S ⊆ (𝐌) such that S is a submodule of 𝐌. We define

  [S]_𝐌

by:

  [S]_([M,⊕,0,⊖,⊙]_𝐑) := [S, ⊕∣_S, 0, ⊖∣_S^S, ⊙∣_((𝐑)×S)]_𝐑 is a left 𝐑-module  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : (𝐑) × M → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a left 𝐑-module)

References.

* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#submodule.module"
`;

exports[`render hlm library: 2.8.29.1.12.3 Algebra/Rings/Modules/Left%20modules/Submodules/submodule 1`] = `
"Definition 2.8.29.1.12.3.  Let 𝐑 be a ring, 𝐌, 𝐍 be left 𝐑-modules. We define:

  𝐌 ≤ 𝐍  :⇔  ∃ homomorphism φ : 𝐌 → 𝐍 : φ is injective
    ⇔  ∃ S ⊆ (𝐍) : [S is a submodule of 𝐍 and 𝐌 = [S]_𝐍]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.8.29.1.12.4 Algebra/Rings/Modules/Left%20modules/Submodules/Span 1`] = `
"Definition 2.8.29.1.12.4.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, X ⊆ (𝐌). We define:

  〈X〉 := ⋂{(S) ∈ 𝒫(𝐌) : S is a submodule of 𝐌 and X ⊆ S}

Remarks.

According to https://proofwiki.org/wiki/Equivalence_of_Definitions_of_Generated_Submodule, the linear span of a set as defined here is equal to the set of all linear combinations (see \`$../Coordinates/Span\`). However, this probably requires the set to be well-orderable, and should be a separate theorem in that case.

References.

* https://en.wikipedia.org/wiki/Linear_span#Generalizations
* https://proofwiki.org/wiki/Definition:Generated_Submodule"
`;

exports[`render hlm library: 2.8.29.1.12.5 Algebra/Rings/Modules/Left%20modules/Submodules/Span%20of%20element 1`] = `
"Definition 2.8.29.1.12.5.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, x ∈ 𝐌. We define:

  〈x〉 := 〈{x}〉
   = {a ⋅ x : a ∈ 𝐑}

Equality.  No proof."
`;

exports[`render hlm library: 2.8.29.1.13.1 Algebra/Rings/Modules/Left%20modules/Coordinates/Element%20sequences 1`] = `
"Definition 2.8.29.1.13.1.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  𝐌^⋆ := (𝐌)^⋆

We write “let 𝒙 be an element sequence on 𝐌” for “let 𝒙 ∈ 𝐌^⋆.”

Remarks.

The main point of defining sequences of module elements is to define when such a sequence is a basis. We want all bases to be ordered, so that coordinates and matrices make sense. To cover as many cases as possible, we use ordinal-indexed sequences."
`;

exports[`render hlm library: 2.8.29.1.13.2 Algebra/Rings/Modules/Left%20modules/Coordinates/Coordinates 1`] = `
"Definition 2.8.29.1.13.2.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, 𝒙 be an element sequence on 𝐌, α := |𝒙|. We define:

  Coord_𝒙 := {(a_k)_(k < α) ∈ (𝐑)^α : ∃ S ⊆ 𝓞𝓻𝓭_(<α) : [S is finite and ∀ j ∈ 𝓞𝓻𝓭_(<α) ∖ S : a_j = 0_𝐑]}

We write “let 𝐚 be a coordinate sequence for 𝒙” for “let 𝐚 ∈ Coord_𝒙.”

Remarks.

This defines the set of valid coordinate sequences corresponding to a given element sequence \`𝒙\`. This set only depends on the length of \`𝒙\`. A coordinate sequence is a sequence of ring elements that has the same length and finite support.

For an element sequence \`𝒙\` and a corresponding coordinate sequence  \`𝐚\`, we can define a linear combination \`$\\"linear combination\\"(𝐑 = 𝐑, 𝐌 = 𝐌, 𝒙 = 𝒙, 𝐚 = 𝐚)\`."
`;

exports[`render hlm library: 2.8.29.1.13.3 Algebra/Rings/Modules/Left%20modules/Coordinates/linear%20combination 1`] = `
"Definition 2.8.29.1.13.3.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, 𝒙 be an element sequence on 𝐌, 𝐚 be a coordinate sequence for 𝒙. We define

  𝐚 ⋅ 𝒙

by:

  (a_k)_(k < |((x_k)_(k < α))_((𝐌)^α)|) ⋅ ((x_k)_(k < α))_((𝐌)^α) := ∑_𝐌_(k ∈ 𝓞𝓻𝓭_(<α)) a_k ⋅ x_k  (α is an ordinal number, (x_k)_(k < α) is a/an α-tuple on (𝐌), a_k ∈ 𝐑 for each k ∈ 𝓞𝓻𝓭_(<|𝒙|))

References.

* https://en.wikipedia.org/wiki/Linear_combination
* https://mathworld.wolfram.com/LinearCombination.html
* https://proofwiki.org/wiki/Definition:Linear_Combination
* https://ncatlab.org/nlab/show/linear+combination
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/finsupp.html#finsupp.total"
`;

exports[`render hlm library: 2.8.29.1.13.4 Algebra/Rings/Modules/Left%20modules/Coordinates/linearly%20dependent 1`] = `
"Definition 2.8.29.1.13.4.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, 𝒙 be an element sequence on 𝐌. We define:

  𝒙 is linearly dependent  :⇔  ∃ 𝐚 ∈ Coord_𝒙 ∖ {(0_𝐑)_(k < |𝒙|)} : 𝐚 ⋅ 𝒙 = 0_𝐌

  𝒙 is linearly independent  :⇔  𝒙 is not linearly dependent

References.

* https://en.wikipedia.org/wiki/Linear_independence
* https://mathworld.wolfram.com/LinearlyDependentVectors.html
* https://proofwiki.org/wiki/Definition:Linearly_Dependent
* https://ncatlab.org/nlab/show/linearly+independent+subset
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/basis.html#linear_independent"
`;

exports[`render hlm library: 2.8.29.1.13.5 Algebra/Rings/Modules/Left%20modules/Coordinates/Span 1`] = `
"Definition 2.8.29.1.13.5.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, 𝒙 be an element sequence on 𝐌. We define

  〈𝒙〉

by:

  〈((x_k)_(k < α))_((𝐌)^α)〉 := 〈{x_k : k ∈ 𝓞𝓻𝓭_(<α)}〉  (α is an ordinal number, (x_k)_(k < α) is a/an α-tuple on (𝐌))
   = {𝐚 ⋅ 𝒙 : 𝐚 is a coordinate sequence for 𝒙}

Equality.  No proof.

Remarks.

The span of an element sequence is defined as (equivalently) either the span of the set of elements or the set of all linear combinations.

References.

* https://en.wikipedia.org/wiki/Linear_span#Generalizations
* https://proofwiki.org/wiki/Definition:Generated_Submodule"
`;

exports[`render hlm library: 2.8.29.1.13.6 Algebra/Rings/Modules/Left%20modules/Coordinates/finitely%20generated 1`] = `
"Definition 2.8.29.1.13.6.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  𝐌 is finitely generated  :⇔  ∃ 𝒙 ∈ 𝐌^⋆ : [𝒙 is finite and 〈𝒙〉 = (𝐌)]

References.

* https://en.wikipedia.org/wiki/Finitely_generated_module
* https://proofwiki.org/wiki/Definition:Finitely_Generated_Module
* https://ncatlab.org/nlab/show/finitely+generated+module"
`;

exports[`render hlm library: 2.8.29.1.13.7 Algebra/Rings/Modules/Left%20modules/Coordinates/basis 1`] = `
"Definition 2.8.29.1.13.7.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, 𝒙 be an element sequence on 𝐌. We define:

  𝒙 is a basis  :⇔  𝒙 is linearly independent and 〈𝒙〉 = (𝐌)
    ⇔  ∀ m ∈ 𝐌 : ∃! 𝐚 ∈ Coord_𝒙 : 𝐚 ⋅ 𝒙 = m

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Basis_(linear_algebra)
* https://proofwiki.org/wiki/Definition:Ordered_Basis
* https://ncatlab.org/nlab/show/basis+of+a+free+module
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/basis.html#is_basis"
`;

exports[`render hlm library: 2.8.29.1.13.8 Algebra/Rings/Modules/Left%20modules/Coordinates/Bases 1`] = `
"Definition 2.8.29.1.13.8.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module. We define:

  Ba(𝐌) := {𝒙 ∈ 𝐌^⋆ : 𝒙 is a basis}

We write “let 𝒙 be a basis of 𝐌” for “let 𝒙 ∈ Ba(𝐌).”"
`;

exports[`render hlm library: 2.8.29.1.13.9 Algebra/Rings/Modules/Left%20modules/Coordinates/basis%20coordinates 1`] = `
"Definition 2.8.29.1.13.9.  Let 𝐑 be a ring, 𝐌 be a left 𝐑-module, 𝒙 be a basis of 𝐌, m ∈ 𝐌. For 𝐚 ∈ Coord_𝒙, we define:

  coord_𝒙(m) = 𝐚  :⇔  𝐚 ⋅ 𝒙 = m

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Basis_(linear_algebra)#Coordinates
* https://proofwiki.org/wiki/Definition:Coordinate_System/Coordinate
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/basis.html#is_basis.repr"
`;

exports[`render hlm library: 2.8.29.1.14.1 Algebra/Rings/Modules/Left%20modules/Examples/ideal%20module 1`] = `
"Definition 2.8.29.1.14.1.  Let 𝐑 be a ring, I ⊆ (𝐑) such that I is a left ideal of 𝐑. We define:

  [I]_𝐑 := [I, ⊕∣_I, 0, ⊖∣_I^I, ⊙∣_(R×I)]_𝐑 if 𝐑 = [R, ⊕, 0, ⊖, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)#Examples
* https://proofwiki.org/wiki/Left_Ideal_is_Left_Module_over_Ring
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#ideal (defined as submodule)"
`;

exports[`render hlm library: 2.8.29.1.14.2 Algebra/Rings/Modules/Left%20modules/Examples/polynomial%20module 1`] = `
"Definition 2.8.29.1.14.2.  Let 𝐑 be a ring, X be a variable. We define:

  𝐑[X] := [𝐑[X], +, (0)_(𝐑[X]), −, ⋅]_𝐑 is a left 𝐑-module

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)#Examples
* https://proofwiki.org/wiki/Definition:Module_Structure_of_Polynomial_Ring
* https://leanprover-community.github.io/mathlib_docs/data/polynomial/basic.html#polynomial.module"
`;

exports[`render hlm library: 2.8.29.1.14.3 Algebra/Rings/Modules/Left%20modules/Examples/matrix%20module 1`] = `
"Definition 2.8.29.1.14.3.  Let 𝐑 be a ring, m, n ∈ ℕ. We define:

  𝐑^(m×n) := [𝐑^(m×n), +, 0_(𝐑^(m×n)), −, ⋅]_𝐑 is a left 𝐑-module

References.

* https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html#matrix.module"
`;

exports[`render hlm library: 2.8.29.2.1 Algebra/Rings/Modules/Right%20modules/right%20module 1`] = `
"Definition 2.8.29.2.1.  Let 𝐑 be a ring, M be a set, ⊕ : M × M → M be an operation on M, 0 ∈ M, ⊖ : M → M be a function, ⊙ : M × (𝐑) → M be an operation. We define:

  (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module  :⇔  (M, ⊕, 0, ⊖) forms an abelian group and ⊙ is right-distributive over ⊕ and [∀ x ∈ M, a, b ∈ 𝐑 : x ⊙ (a + b) = (x ⊙ a) ⊕ (x ⊙ b)] and [∀ x ∈ M : x ⊙ 0_𝐑 = 0] and 0 is a left absorbing element for ⊙ and [∀ a ∈ 𝐑, x ∈ M : x ⊙ (−a) = ⊖(x) ⊙ a = ⊖(x ⊙ a)] and [∀ x ∈ M, a, b ∈ 𝐑 : x ⊙ (a ⋅ b) = (x ⊙ a) ⊙ b] and 1_𝐑 is a right identity for ⊙
    ⇔  (M, ⊕, 0, ⊖) forms an abelian group and ⊙ is right-distributive over ⊕ and [∀ x ∈ M, a, b ∈ 𝐑 : x ⊙ (a + b) = (x ⊙ a) ⊕ (x ⊙ b)] and [∀ x ∈ M, a, b ∈ 𝐑 : x ⊙ (a ⋅ b) = (x ⊙ a) ⊙ b] and 1_𝐑 is a right identity for ⊙

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)
* https://mathworld.wolfram.com/Module.html
* https://proofwiki.org/wiki/Definition:Unitary_Module
* https://ncatlab.org/nlab/show/module#ModulesOverARingInTermsOfStabilizedSlices"
`;

exports[`render hlm library: 2.8.29.2.2 Algebra/Rings/Modules/Right%20modules/Right%20modules 1`] = `
"Definition 2.8.29.2.2.  Let 𝐑 be a ring. We define:

  𝓡𝓜𝓸𝓭(𝐑) :=: {[M, ⊕, 0, ⊖, ⊙]_𝐑 | M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module}

  [M, ⊕, 0, ⊖, ⊙]_𝐑 = [N, ⋆, 𝟢, ∼, ∗]_𝐑  :⇔  ∃ φ : M ↔ N : [⊕ ≃^φ ⋆ and 0 ≃^φ 𝟢 and ⊖ ≃^φ ∼ and ⊙ ≃^φ ∗]  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation, N is a set, ⋆ : N × N → N is an operation on N, 𝟢 ∈ N, ∼ : N → N is a function, ∗ : N × (𝐑) → N is an operation with suitable conditions)

We write “let 𝐌 be a right 𝐑-module” for “let 𝐌 ∈ 𝓡𝓜𝓸𝓭(𝐑).”

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)
* https://mathworld.wolfram.com/Module.html
* https://proofwiki.org/wiki/Definition:Unitary_Module
* https://ncatlab.org/nlab/show/module#ModulesOverARingInTermsOfStabilizedSlices"
`;

exports[`render hlm library: 2.8.29.2.3 Algebra/Rings/Modules/Right%20modules/Carrier 1`] = `
"Definition 2.8.29.2.3.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define

  (𝐌)

by:

  ([M, ⊕, 0, ⊖, ⊙]_𝐑) := M  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)

We write “let x ∈ 𝐌” for “let x ∈ (𝐌).”

Remarks.

This definition retrieves a representative carrier set from a module (which is actually an equivalence class of modules), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.8.29.2.4 Algebra/Rings/Modules/Right%20modules/sum 1`] = `
"Definition 2.8.29.2.4.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, x, y ∈ 𝐌. We define:

  x + y := x ⊕ y if 𝐌 = [M, ⊕, 0, ⊖, ⊙]_𝐑 (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.2.5 Algebra/Rings/Modules/Right%20modules/zero 1`] = `
"Definition 2.8.29.2.5.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define

  0_𝐌

by:

  0_([M,⊕,0,⊖,⊙]_𝐑) := 0  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.2.6 Algebra/Rings/Modules/Right%20modules/additive%20inverse 1`] = `
"Definition 2.8.29.2.6.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, x ∈ 𝐌. We define:

  −x := ⊖(x) if 𝐌 = [M, ⊕, 0, ⊖, ⊙]_𝐑 (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.2.7 Algebra/Rings/Modules/Right%20modules/difference 1`] = `
"Definition 2.8.29.2.7.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, x, y ∈ 𝐌. We define:

  x − y := x + (−y)"
`;

exports[`render hlm library: 2.8.29.2.8 Algebra/Rings/Modules/Right%20modules/additive%20group 1`] = `
"Definition 2.8.29.2.8.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define

  [𝐌, +]

by:

  [[M, ⊕, 0, ⊖, ⊙]_𝐑, +] := [M, ⊕, 0, ⊖] is a group  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)

Remarks.

Addition of module elements as a group."
`;

exports[`render hlm library: 2.8.29.2.9 Algebra/Rings/Modules/Right%20modules/product 1`] = `
"Definition 2.8.29.2.9.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, x ∈ 𝐌, a ∈ 𝐑. We define:

  x ⋅ a := x ⊙ a if 𝐌 = [M, ⊕, 0, ⊖, ⊙]_𝐑 (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.2.10 Algebra/Rings/Modules/Right%20modules/iterated%20sum 1`] = `
"Definition 2.8.29.2.10.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  ∑_𝐌 := ∏_[𝐌,+]

Example.

\`$../../../../Essentials/Operations/\\"Iterated operations\\"/\\"indexed by natural number\\"(X = $Carrier(𝐑 = 𝐑, 𝐌 = 𝐌), ⨂ = $\\"iterated sum\\"(𝐑 = 𝐑, 𝐌 = 𝐌), n = n, _1 = {#(i: %Element($../../../../Essentials/Numbers/Natural/Subsets/\\"Segment (less)\\"(n = n))), {a = {a[i = i]}}})\`

References.

* https://en.wikipedia.org/wiki/Summation
* https://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 2.8.29.2.11.1 Algebra/Rings/Modules/Right%20modules/Homomorphisms/Homomorphisms 1`] = `
"Definition 2.8.29.2.11.1.  Let 𝐑 be a ring, 𝐌, 𝐍 be right 𝐑-modules. We define:

  Hom(𝐌, 𝐍) := {f : (𝐌) → (𝐍) : [∀ x, y ∈ 𝐌 : f(x + y) = f(x) + f(y)] and f(0_𝐌) = 0_𝐍 and [∀ z ∈ 𝐌 : f(−z) = −f(z)] and ∀ a ∈ 𝐑, w ∈ 𝐌 : f(w ⋅ a) = f(w) ⋅ a}
   = {f : (𝐌) → (𝐍) : ∀ a, b ∈ 𝐑, x, y ∈ 𝐌 : f(x ⋅ a + y ⋅ b) = f(x) ⋅ a + f(y) ⋅ b}

We write “let φ : 𝐌 → 𝐍 be a homomorphism” for “let φ ∈ Hom(𝐌, 𝐍).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_homomorphism
* https://proofwiki.org/wiki/Definition:Linear_Transformation
* https://ncatlab.org/nlab/show/homomorphism"
`;

exports[`render hlm library: 2.8.29.2.11.2 Algebra/Rings/Modules/Right%20modules/Homomorphisms/Isomorphisms 1`] = `
"Definition 2.8.29.2.11.2.  Let 𝐑 be a ring, 𝐌, 𝐍 be right 𝐑-modules. We define:

  Iso(𝐌, 𝐍) := {homomorphisms φ : 𝐌 → 𝐍 : φ is bijective}
   = {f : (𝐌) ↔ (𝐍) : ∀ a, b ∈ 𝐑, x, y ∈ 𝐌 : f(x ⋅ a + y ⋅ b) = f(x) ⋅ a + f(y) ⋅ b}

We write “let φ : 𝐌 ↔ 𝐍 be an isomorphism” for “let φ ∈ Iso(𝐌, 𝐍).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Module_homomorphism#Terminology
* https://proofwiki.org/wiki/Definition:Isomorphism_(Abstract_Algebra)/R-Algebraic_Structure_Isomorphism/Module_Isomorphism
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 2.8.29.2.11.3 Algebra/Rings/Modules/Right%20modules/Homomorphisms/Automorphisms 1`] = `
"Definition 2.8.29.2.11.3.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  Aut(𝐌) := Iso(𝐌, 𝐌)

We write “let φ : 𝐌 ↔ 𝐌 be an automorphism” for “let φ ∈ Aut(𝐌).”

References.

* https://en.wikipedia.org/wiki/Automorphism
* https://mathworld.wolfram.com/Automorphism.html
* https://proofwiki.org/wiki/Definition:Automorphism_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/automorphism"
`;

exports[`render hlm library: 2.8.29.2.11.4 Algebra/Rings/Modules/Right%20modules/Homomorphisms/automorphism%20group 1`] = `
"Definition 2.8.29.2.11.4.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  Aut(𝐌) := [Aut(𝐌)]_(𝑆_(𝐌))

References.

* https://en.wikipedia.org/wiki/Automorphism_group
* https://mathworld.wolfram.com/AutomorphismGroup.html
* https://proofwiki.org/wiki/Definition:Automorphism_Group
* https://ncatlab.org/nlab/show/automorphism#automorphism_group"
`;

exports[`render hlm library: 2.8.29.2.11.5 Algebra/Rings/Modules/Right%20modules/Homomorphisms/Kernel 1`] = `
"Definition 2.8.29.2.11.5.  Let 𝐑 be a ring, 𝐌, 𝐍 be right 𝐑-modules, φ : 𝐌 → 𝐍 be a homomorphism. We define:

  Ker(φ) := φ^-1({0_𝐍})

References.

* https://en.wikipedia.org/wiki/Module_homomorphism
* https://mathworld.wolfram.com/ModuleKernel.html
* https://proofwiki.org/wiki/Definition:Kernel_of_Linear_Transformation
* https://ncatlab.org/nlab/show/kernel"
`;

exports[`render hlm library: 2.8.29.2.11.6 Algebra/Rings/Modules/Right%20modules/Homomorphisms/identity 1`] = `
"Definition 2.8.29.2.11.6.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  id_𝐌 := id_(𝐌)"
`;

exports[`render hlm library: 2.8.29.2.11.7 Algebra/Rings/Modules/Right%20modules/Homomorphisms/Equality%20criterion 1`] = `
"Proposition 2.8.29.2.11.7.  Let 𝐑 be a ring, 𝐌, 𝐍 be right 𝐑-modules. Then the following are equivalent:

  1. Iso(𝐌, 𝐍) is nonempty
  2. 𝐌 = 𝐍

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of modules."
`;

exports[`render hlm library: 2.8.29.2.11.8 Algebra/Rings/Modules/Right%20modules/Homomorphisms/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.8.29.2.11.8.  Let 𝐑 be a ring, 𝐌, 𝐍 be right 𝐑-modules, φ : 𝐌 ↔ 𝐍 be an isomorphism. Then:

  φ^-1 ∈ Iso(𝐍, 𝐌)

No proof."
`;

exports[`render hlm library: 2.8.29.2.12.1 Algebra/Rings/Modules/Right%20modules/Submodules/submodule%20set 1`] = `
"Definition 2.8.29.2.12.1.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, S ⊆ (𝐌). We define:

  S is a submodule of 𝐌  :⇔  [∀ a, b ∈ S : a + b ∈ S] and 0_𝐌 ∈ S and [∀ c ∈ S : −c ∈ S] and ∀ d ∈ S, e ∈ 𝐑 : d ⋅ e ∈ S

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)#Submodules_and_homomorphisms
* https://mathworld.wolfram.com/Submodule.html
* https://proofwiki.org/wiki/Definition:Submodule
* https://ncatlab.org/nlab/show/submodule"
`;

exports[`render hlm library: 2.8.29.2.12.2 Algebra/Rings/Modules/Right%20modules/Submodules/subset%20module 1`] = `
"Definition 2.8.29.2.12.2.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, S ⊆ (𝐌) such that S is a submodule of 𝐌. We define

  [S]_𝐌

by:

  [S]_([M,⊕,0,⊖,⊙]_𝐑) := [S, ⊕∣_S, 0, ⊖∣_S^S, ⊙∣_(S×(𝐑))]_𝐑 is a right 𝐑-module  (M is a set, ⊕ : M × M → M is an operation on M, 0 ∈ M, ⊖ : M → M is a function, ⊙ : M × (𝐑) → M is an operation such that (M, ⊕, 0, ⊖, ⊙) forms a right 𝐑-module)"
`;

exports[`render hlm library: 2.8.29.2.12.3 Algebra/Rings/Modules/Right%20modules/Submodules/submodule 1`] = `
"Definition 2.8.29.2.12.3.  Let 𝐑 be a ring, 𝐌, 𝐍 be right 𝐑-modules. We define:

  𝐌 ≤ 𝐍  :⇔  ∃ homomorphism φ : 𝐌 → 𝐍 : φ is injective
    ⇔  ∃ S ⊆ (𝐍) : [S is a submodule of 𝐍 and 𝐌 = [S]_𝐍]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.8.29.2.12.4 Algebra/Rings/Modules/Right%20modules/Submodules/Span 1`] = `
"Definition 2.8.29.2.12.4.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, X ⊆ (𝐌). We define:

  〈X〉 := ⋂{(S) ∈ 𝒫(𝐌) : S is a submodule of 𝐌 and X ⊆ S}

Remarks.

According to https://proofwiki.org/wiki/Equivalence_of_Definitions_of_Generated_Submodule, the linear span of a set as defined here is equal to the set of all linear combinations (see \`$../Coordinates/Span\`). However, this probably requires the set to be well-orderable, and should be a separate theorem in that case.

References.

* https://en.wikipedia.org/wiki/Linear_span#Generalizations
* https://proofwiki.org/wiki/Definition:Generated_Submodule"
`;

exports[`render hlm library: 2.8.29.2.12.5 Algebra/Rings/Modules/Right%20modules/Submodules/Span%20of%20element 1`] = `
"Definition 2.8.29.2.12.5.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, x ∈ 𝐌. We define:

  〈x〉 := 〈{x}〉
   = {x ⋅ a : a ∈ 𝐑}

Equality.  No proof."
`;

exports[`render hlm library: 2.8.29.2.13.1 Algebra/Rings/Modules/Right%20modules/Coordinates/Element%20sequences 1`] = `
"Definition 2.8.29.2.13.1.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  𝐌^⋆ := (𝐌)^⋆

We write “let 𝒙 be an element sequence on 𝐌” for “let 𝒙 ∈ 𝐌^⋆.”

Remarks.

The main point of defining sequences of module elements is to define when such a sequence is a basis. We want all bases to be ordered, so that coordinates and matrices make sense. To cover as many cases as possible, we use ordinal-indexed sequences."
`;

exports[`render hlm library: 2.8.29.2.13.2 Algebra/Rings/Modules/Right%20modules/Coordinates/Coordinates 1`] = `
"Definition 2.8.29.2.13.2.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, 𝒙 be an element sequence on 𝐌, α := |𝒙|. We define:

  Coord_𝒙 := {(a_k)_(k < α) ∈ (𝐑)^α : ∃ S ⊆ 𝓞𝓻𝓭_(<α) : [S is finite and ∀ j ∈ 𝓞𝓻𝓭_(<α) ∖ S : a_j = 0_𝐑]}

We write “let 𝐚 be a coordinate sequence for 𝒙” for “let 𝐚 ∈ Coord_𝒙.”

Remarks.

This defines the set of valid coordinate sequences corresponding to a given element sequence \`𝒙\`. This set only depends on the length of \`𝒙\`. A coordinate sequence is a sequence of ring elements that has the same length and finite support.

For an element sequence \`𝒙\` and a corresponding coordinate sequence  \`𝐚\`, we can define a linear combination \`$\\"linear combination\\"(𝐑 = 𝐑, 𝐌 = 𝐌, 𝒙 = 𝒙, 𝐚 = 𝐚)\`."
`;

exports[`render hlm library: 2.8.29.2.13.3 Algebra/Rings/Modules/Right%20modules/Coordinates/linear%20combination 1`] = `
"Definition 2.8.29.2.13.3.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, 𝒙 be an element sequence on 𝐌, 𝐚 be a coordinate sequence for 𝒙. We define

  𝒙 ⋅ 𝐚

by:

  ((x_k)_(k < α))_((𝐌)^α) ⋅ (a_k)_(k < |((x_k)_(k < α))_((𝐌)^α)|) := ∑_𝐌_(k ∈ 𝓞𝓻𝓭_(<α)) x_k ⋅ a_k  (α is an ordinal number, (x_k)_(k < α) is a/an α-tuple on (𝐌), a_k ∈ 𝐑 for each k ∈ 𝓞𝓻𝓭_(<|𝒙|))

References.

* https://en.wikipedia.org/wiki/Linear_combination
* https://mathworld.wolfram.com/LinearCombination.html
* https://proofwiki.org/wiki/Definition:Linear_Combination
* https://ncatlab.org/nlab/show/linear+combination"
`;

exports[`render hlm library: 2.8.29.2.13.4 Algebra/Rings/Modules/Right%20modules/Coordinates/linearly%20dependent 1`] = `
"Definition 2.8.29.2.13.4.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, 𝒙 be an element sequence on 𝐌. We define:

  𝒙 is linearly dependent  :⇔  ∃ 𝐚 ∈ Coord_𝒙 ∖ {(0_𝐑)_(k < |𝒙|)} : 𝒙 ⋅ 𝐚 = 0_𝐌

  𝒙 is linearly independent  :⇔  𝒙 is not linearly dependent

References.

* https://en.wikipedia.org/wiki/Linear_independence
* https://mathworld.wolfram.com/LinearlyDependentVectors.html
* https://proofwiki.org/wiki/Definition:Linearly_Dependent
* https://ncatlab.org/nlab/show/linearly+independent+subset"
`;

exports[`render hlm library: 2.8.29.2.13.5 Algebra/Rings/Modules/Right%20modules/Coordinates/Span 1`] = `
"Definition 2.8.29.2.13.5.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, 𝒙 be an element sequence on 𝐌. We define

  〈𝒙〉

by:

  〈((x_k)_(k < α))_((𝐌)^α)〉 := 〈{x_k : k ∈ 𝓞𝓻𝓭_(<α)}〉  (α is an ordinal number, (x_k)_(k < α) is a/an α-tuple on (𝐌))
   = {𝒙 ⋅ 𝐚 : 𝐚 is a coordinate sequence for 𝒙}

Equality.  No proof."
`;

exports[`render hlm library: 2.8.29.2.13.6 Algebra/Rings/Modules/Right%20modules/Coordinates/finitely%20generated 1`] = `
"Definition 2.8.29.2.13.6.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  𝐌 is finitely generated  :⇔  ∃ 𝒙 ∈ 𝐌^⋆ : [𝒙 is finite and 〈𝒙〉 = (𝐌)]

References.

* https://en.wikipedia.org/wiki/Finitely_generated_module
* https://proofwiki.org/wiki/Definition:Finitely_Generated_Module
* https://ncatlab.org/nlab/show/finitely+generated+module"
`;

exports[`render hlm library: 2.8.29.2.13.7 Algebra/Rings/Modules/Right%20modules/Coordinates/basis 1`] = `
"Definition 2.8.29.2.13.7.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, 𝒙 be an element sequence on 𝐌. We define:

  𝒙 is a basis  :⇔  𝒙 is linearly independent and 〈𝒙〉 = (𝐌)
    ⇔  ∀ m ∈ 𝐌 : ∃! 𝐚 ∈ Coord_𝒙 : 𝒙 ⋅ 𝐚 = m

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Basis_(linear_algebra)
* https://proofwiki.org/wiki/Definition:Ordered_Basis
* https://ncatlab.org/nlab/show/basis+of+a+free+module"
`;

exports[`render hlm library: 2.8.29.2.13.8 Algebra/Rings/Modules/Right%20modules/Coordinates/Bases 1`] = `
"Definition 2.8.29.2.13.8.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module. We define:

  Ba(𝐌) := {𝒙 ∈ 𝐌^⋆ : 𝒙 is a basis}

We write “let 𝒙 be a basis of 𝐌” for “let 𝒙 ∈ Ba(𝐌).”"
`;

exports[`render hlm library: 2.8.29.2.13.9 Algebra/Rings/Modules/Right%20modules/Coordinates/basis%20coordinates 1`] = `
"Definition 2.8.29.2.13.9.  Let 𝐑 be a ring, 𝐌 be a right 𝐑-module, 𝒙 be a basis of 𝐌, m ∈ 𝐌. For 𝐚 ∈ Coord_𝒙, we define:

  coord_𝒙(m) = 𝐚  :⇔  𝒙 ⋅ 𝐚 = m

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Basis_(linear_algebra)#Coordinates
* https://proofwiki.org/wiki/Definition:Coordinate_System/Coordinate"
`;

exports[`render hlm library: 2.8.29.2.14.1 Algebra/Rings/Modules/Right%20modules/Examples/ideal%20module 1`] = `
"Definition 2.8.29.2.14.1.  Let 𝐑 be a ring, I ⊆ (𝐑) such that I is a right ideal of 𝐑. We define:

  [I]_𝐑 := [I, ⊕∣_I, 0, ⊖∣_I^I, ⊙∣_(I×R)]_𝐑 if 𝐑 = [R, ⊕, 0, ⊖, ⊙, 1] (R is a set, ⊕ : R × R → R is an operation on R, 0 ∈ R, ⊖ : R → R is a function, ⊙ : R × R → R is an operation on R, 1 ∈ R such that (R, ⊕, 0, ⊖, ⊙, 1) forms a ring)

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)#Examples
* https://proofwiki.org/wiki/Right_Ideal_is_Right_Module_over_Ring"
`;

exports[`render hlm library: 2.8.29.2.14.2 Algebra/Rings/Modules/Right%20modules/Examples/polynomial%20module 1`] = `
"Definition 2.8.29.2.14.2.  Let 𝐑 be a ring, X be a variable. We define:

  𝐑[X] := [𝐑[X], +, (0)_(𝐑[X]), −, ⋅]_𝐑 is a right 𝐑-module

References.

* https://en.wikipedia.org/wiki/Module_(mathematics)#Examples
* https://proofwiki.org/wiki/Definition:Module_Structure_of_Polynomial_Ring"
`;

exports[`render hlm library: 2.8.29.2.14.3 Algebra/Rings/Modules/Right%20modules/Examples/matrix%20module 1`] = `
"Definition 2.8.29.2.14.3.  Let 𝐑 be a ring, m, n ∈ ℕ. We define:

  𝐑^(m×n) := [𝐑^(m×n), +, 0_(𝐑^(m×n)), −, ⋅]_𝐑 is a right 𝐑-module"
`;

exports[`render hlm library: 2.9.1 Algebra/Fields/Fields 1`] = `
"Definition 2.9.1.  We define:

  𝓕𝓵𝓭 := {rings 𝐑 : 𝐑 is commutative and 𝐑^× = (𝐑) ∖ {0_𝐑}}

We write “let 𝐅 be a field” for “let 𝐅 ∈ 𝓕𝓵𝓭.”

References.

* https://en.wikipedia.org/wiki/Field_(mathematics)
* https://mathworld.wolfram.com/Field.html
* https://proofwiki.org/wiki/Definition:Field_(Abstract_Algebra)
* https://ncatlab.org/nlab/show/field
* https://coq.inria.fr/library/Coq.setoid_ring.Field_theory.html#field_theory
* https://leanprover-community.github.io/mathlib_docs/algebra/field.html#field"
`;

exports[`render hlm library: 2.9.2 Algebra/Fields/quotient 1`] = `
"Definition 2.9.2.  Let 𝐅 be a field, b ∈ 𝐅, a ∈ 𝐅^×. For x ∈ 𝐅, we define:

  b∕a = x  :⇔  b = x ⋅ a

Well-definedness.  No proof."
`;

exports[`render hlm library: 2.9.3.1 Algebra/Fields/Subfields/subfield%20set 1`] = `
"Definition 2.9.3.1.  Let 𝐅 be a field, S ⊆ (𝐅). We define:

  S is a subfield of 𝐅  :⇔  S is a subring of 𝐅 and ∀ a ∈ S ∖ {0_𝐅} : a^-1 ∈ S

References.

* https://en.wikipedia.org/wiki/Field_extension
* https://mathworld.wolfram.com/Subfield.html
* https://proofwiki.org/wiki/Definition:Subfield
* https://ncatlab.org/nlab/show/subfield
* https://leanprover-community.github.io/mathlib_docs/field_theory/subfield.html#is_subfield"
`;

exports[`render hlm library: 2.9.4.1 Algebra/Fields/Examples/rational%20numbers 1`] = `
"Definition 2.9.4.1.  We define:

  ℚ := [ℚ, +, 0, −, ⋅, 1] is a ring

References.

* https://leanprover-community.github.io/mathlib_docs/data/rat/basic.html#rat.field"
`;

exports[`render hlm library: 2.9.4.2 Algebra/Fields/Examples/real%20numbers 1`] = `
"Definition 2.9.4.2.  We define:

  ℝ := [ℝ, +, 0, −, ⋅, 1] is a ring

References.

* https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real.field"
`;

exports[`render hlm library: 2.9.4.3 Algebra/Fields/Examples/complex%20numbers 1`] = `
"Definition 2.9.4.3.  We define:

  ℂ := [ℂ, +, 0, −, ⋅, 1] is a ring

References.

* https://leanprover-community.github.io/mathlib_docs/data/complex/basic.html#complex.field"
`;

exports[`render hlm library: 2.9.4.4 Algebra/Fields/Examples/prime%20field 1`] = `
"Definition 2.9.4.4.  Let p be a prime. We define:

  𝔽_p := ℤ∕pℤ

References.

* https://en.wikipedia.org/wiki/Finite_field
* https://mathworld.wolfram.com/PrimeField.html
* https://proofwiki.org/wiki/Ring_of_Integers_Modulo_Prime_is_Field
* https://ncatlab.org/nlab/show/prime+field
* https://leanprover-community.github.io/mathlib_docs/data/zmod/basic.html#zmod.field"
`;

exports[`render hlm library: 2.9.5.1 Algebra/Fields/Prime%20fields/Eulers%20criterion 1`] = `
"Proposition 2.9.5.1 (Euler's criterion).  Let p be an odd prime, a ∈ (𝔽_p)^×. Then the following are equivalent:

  1. ∃ y ∈ 𝔽_p : y^2 = a
  2. a^((p−1)∕2) = 1_(𝔽_p)

No proof.

References.

* https://en.wikipedia.org/wiki/Euler%27s_criterion
* https://proofwiki.org/wiki/Euler%27s_Criterion"
`;

exports[`render hlm library: 3.1.1 Linear%20algebra/Vector%20spaces/Vector%20spaces 1`] = `
"Definition 3.1.1.  Let 𝐅 be a field. We define:

  𝓥𝓮𝓬(𝐅) := 𝓛𝓜𝓸𝓭(𝐅)

We write “let 𝐕 be a vector space over 𝐅” for “let 𝐕 ∈ 𝓥𝓮𝓬(𝐅).”

Remarks.

For vector spaces, we reuse the definitions related to modules over a ring where applicable.

References.

* https://en.wikipedia.org/wiki/Vector_space
* https://mathworld.wolfram.com/VectorSpace.html
* https://proofwiki.org/wiki/Definition:Vector_Space
* https://ncatlab.org/nlab/show/vector+space
* https://leanprover-community.github.io/mathlib_docs/algebra/module/basic.html#vector_space"
`;

exports[`render hlm library: 3.1.2 Linear%20algebra/Vector%20spaces/finite-dimensional 1`] = `
"Definition 3.1.2.  Let 𝐅 be a field, 𝐕 be a vector space over 𝐅. We define:

  𝐕 is finite-dimensional  :⇔  ∃ 𝒙 ∈ Ba(𝐕) : 𝒙 is finite
    ⇔  𝐕 is finitely generated

  𝐕 is infinite-dimensional  :⇔  𝐕 is not finite-dimensional

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Dimension_(vector_space)
* https://proofwiki.org/wiki/Definition:Dimension_of_Vector_Space/Finite
* https://ncatlab.org/nlab/show/finite-dimensional+vector+space
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/finite_dimensional.html#finite_dimensional"
`;

exports[`render hlm library: 3.1.3 Linear%20algebra/Vector%20spaces/dimension 1`] = `
"Definition 3.1.3.  Let 𝐅 be a field, 𝐕 be a finite-dimensional vector space over 𝐅. For n ∈ ℕ, we define:

  dim(𝐕) = n  :⇔  ∀ 𝒙 ∈ Ba(𝐕) : |𝒙| = n
    ⇔  ∃ 𝒙 ∈ Ba(𝐕) : |𝒙| = n
    ⇔  ∀ 𝒙 ∈ 𝐕^⋆ s.t. 〈𝒙〉 = (𝐕) : |𝒙| ≥ n

Equivalence.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Dimension_(vector_space)
* https://mathworld.wolfram.com/Dimension.html
* https://proofwiki.org/wiki/Definition:Dimension_of_Vector_Space
* https://ncatlab.org/nlab/show/dimension#of_spaces
* https://leanprover-community.github.io/mathlib_docs/linear_algebra/finite_dimensional.html#finite_dimensional.findim"
`;

exports[`render hlm library: 3.1.4.1 Linear%20algebra/Vector%20spaces/Examples/column%20vector%20space 1`] = `
"Definition 3.1.4.1.  Let 𝐅 be a field, n ∈ ℕ. We define:

  𝐅^n := [𝐅^n, +, 0_(𝐅^(1×n)), −, ⋅]_𝐅
   = 𝐅^(1×n)

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Vector_space#Coordinate_spaces"
`;

exports[`render hlm library: 3.1.4.2 Linear%20algebra/Vector%20spaces/Examples/Finite-dimensional%20vector%20spaces%20are%20isomorphic%20to%20column%20vector%20spaces 1`] = `
"Proposition 3.1.4.2.  Let 𝐅 be a field, 𝐕 be a finite-dimensional vector space over 𝐅. Then:

  𝐕 = 𝐅^(dim(𝐕))

No proof.

References.

* https://en.wikipedia.org/wiki/Dimension_(vector_space)#Facts
* https://proofwiki.org/wiki/Same_Dimensional_Vector_Spaces_are_Isomorphic"
`;

exports[`render hlm library: 4.1 Category%20theory/Categories 1`] = `
"Definition 4.1.  Let u ∈ ℕ. We define:

  𝓒𝓪𝓽_u :=: {[O, (M_𝐀,𝐁)_(𝐀,𝐁 ∈ O), (i_𝐂)_(𝐂 ∈ O), (∘_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ O)]_u | O is a set, M_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ O, i_𝐂 ∈ M_𝐂,𝐂 for each 𝐂 ∈ O, ∘_𝐃,𝐄,𝐅 : M_𝐄,𝐅 × M_𝐃,𝐄 → M_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ O, [∀ 𝐖, 𝐗, 𝐘, 𝐙 ∈ O, f ∈ M_𝐖,𝐗, g ∈ M_𝐗,𝐘, h ∈ M_𝐘,𝐙 : (h ∘_𝐗,𝐘,𝐙 g) ∘_𝐖,𝐗,𝐙 f = h ∘_𝐖,𝐘,𝐙 (g ∘_𝐖,𝐗,𝐘 f)], [∀ 𝐗, 𝐘 ∈ O, f ∈ M_𝐗,𝐘 : i_𝐘 ∘_𝐗,𝐘,𝐘 f = f ∘_𝐗,𝐗,𝐘 i_𝐗 = f], [∀ 𝐗, 𝐘 ∈ O s.t. [∃ f ∈ M_𝐗,𝐘, g ∈ M_𝐘,𝐗 : [f ∘_𝐘,𝐗,𝐘 g = i_𝐘 and g ∘_𝐗,𝐘,𝐗 f = i_𝐗]] : 𝐗 = 𝐘]}

  [O, (M_𝐀,𝐁)_(𝐀,𝐁 ∈ O), (i_𝐂)_(𝐂 ∈ O), (∘_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ O)]_u = [P, (N_𝐀,𝐁)_(𝐀,𝐁 ∈ P), (j_𝐂)_(𝐂 ∈ P), (∙_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ P)]_u  :⇔  ∃ φ : O ↔ P, ψ_𝐀,𝐁 : M_𝐀,𝐁 ↔ N_φ(𝐀),φ(𝐁) f.e. 𝐀, 𝐁 ∈ O : [[∀ 𝐂 ∈ O : i_𝐂 ≃^(ψ_𝐂,𝐂) j_(φ(𝐂))] and ∀ 𝐃, 𝐄, 𝐅 ∈ O : ∘_𝐃,𝐄,𝐅 ≃^ψ_𝐄,𝐅,ψ_𝐃,𝐄,ψ_𝐃,𝐅 ∙_φ(𝐃),φ(𝐄),φ(𝐅)]  (O is a set, M_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ O, i_𝐂 ∈ M_𝐂,𝐂 for each 𝐂 ∈ O, ∘_𝐃,𝐄,𝐅 : M_𝐄,𝐅 × M_𝐃,𝐄 → M_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ O, P is a set, N_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ P, j_𝐂 ∈ N_𝐂,𝐂 for each 𝐂 ∈ P, ∙_𝐃,𝐄,𝐅 : N_𝐄,𝐅 × N_𝐃,𝐄 → N_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ P with suitable conditions)

We write “let 𝓒 be a/an u-small category” for “let 𝓒 ∈ 𝓒𝓪𝓽_u.”

Remarks.

This definition of categories includes the additional requirement that all categories are [skeletal](https://en.wikipedia.org/wiki/Skeleton_(category_theory)). The reasoning behind this is that I expect the equality definition above, which is derived purely syntactically, to be equivalent to _isomorphism_ of categories, not _equivalence_. That is, without this restriction, two isomorphic categories would be considered equal, but two equivalent categories would not necessarily be. (This needs to be verified.)

For skeletal categories, the two concepts coincide. Since in HLM, all of the usual examples of categories happen to be skeletal anyway, and we care about equivalence much more than isomorphism, it makes sense to include this requirement directly in the definition of a category.

The natural number \`u\` is required to be able to define a category of (smaller) categories or functors, which would otherwise be prevented by non-circularity rules. Informally, \`u\` can be regarded as a \\"universe size\\" that is relevant only in the context of category theory. (The \\"universes\\" that are implicit in other contexts are already large enough.)

References.

* https://en.wikipedia.org/wiki/Category_(mathematics)
* https://mathworld.wolfram.com/Category.html
* https://proofwiki.org/wiki/Definition:Category
* https://ncatlab.org/nlab/show/category
* https://leanprover-community.github.io/mathlib_docs/category_theory/category/default.html#category_theory.category"
`;

exports[`render hlm library: 4.2 Category%20theory/Objects 1`] = `
"Definition 4.2.  Let u ∈ ℕ, 𝓒 be a/an u-small category. We define

  Ob(𝓒)

by:

  Ob([O, (M_𝐀,𝐁)_(𝐀,𝐁 ∈ O), (i_𝐂)_(𝐂 ∈ O), (∘_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ O)]_u) := O  (O is a set, M_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ O, i_𝐂 ∈ M_𝐂,𝐂 for each 𝐂 ∈ O, ∘_𝐃,𝐄,𝐅 : M_𝐄,𝐅 × M_𝐃,𝐄 → M_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ O with suitable conditions)

We write “let 𝐗 ∈ 𝓒” for “let 𝐗 ∈ Ob(𝓒).”

Remarks.

This definition retrieves a representative set of objects from a category (which is actually an equivalence class of categories), and enables typical abuse of notation."
`;

exports[`render hlm library: 4.3 Category%20theory/Morphisms 1`] = `
"Definition 4.3.  Let u ∈ ℕ, 𝓒 be a/an u-small category, 𝐗, 𝐘 ∈ 𝓒. We define:

  Hom(𝐗, 𝐘) := M_𝐗,𝐘 if 𝓒 = [O, (M_𝐀,𝐁)_(𝐀,𝐁 ∈ O), (i_𝐂)_(𝐂 ∈ O), (∘_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ O)]_u (O is a set, M_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ O, i_𝐂 ∈ M_𝐂,𝐂 for each 𝐂 ∈ O, ∘_𝐃,𝐄,𝐅 : M_𝐄,𝐅 × M_𝐃,𝐄 → M_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ O with suitable conditions)

We write “let F : 𝐗 → 𝐘 be a morphism” for “let F ∈ Hom(𝐗, 𝐘).”

References.

* https://en.wikipedia.org/wiki/Morphism
* https://mathworld.wolfram.com/Morphism.html
* https://proofwiki.org/wiki/Definition:Morphism
* https://ncatlab.org/nlab/show/morphism"
`;

exports[`render hlm library: 4.4 Category%20theory/identity 1`] = `
"Definition 4.4.  Let u ∈ ℕ, 𝓒 be a/an u-small category, 𝐗 ∈ 𝓒. We define:

  id_𝐗 := i_𝐗 if 𝓒 = [O, (M_𝐀,𝐁)_(𝐀,𝐁 ∈ O), (i_𝐂)_(𝐂 ∈ O), (∘_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ O)]_u (O is a set, M_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ O, i_𝐂 ∈ M_𝐂,𝐂 for each 𝐂 ∈ O, ∘_𝐃,𝐄,𝐅 : M_𝐄,𝐅 × M_𝐃,𝐄 → M_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ O with suitable conditions)

References.

* https://proofwiki.org/wiki/Definition:Identity_Morphism"
`;

exports[`render hlm library: 4.5 Category%20theory/composition 1`] = `
"Definition 4.5.  Let u ∈ ℕ, 𝓒 be a/an u-small category, 𝐗, 𝐘, 𝐙 ∈ 𝓒, f : 𝐗 → 𝐘, g : 𝐘 → 𝐙 be morphisms. We define:

  g ∘ f := g ∘_𝐗,𝐘,𝐙 f if 𝓒 = [O, (M_𝐀,𝐁)_(𝐀,𝐁 ∈ O), (i_𝐂)_(𝐂 ∈ O), (∘_𝐃,𝐄,𝐅)_(𝐃,𝐄,𝐅 ∈ O)]_u (O is a set, M_𝐀,𝐁 is a set for each 𝐀, 𝐁 ∈ O, i_𝐂 ∈ M_𝐂,𝐂 for each 𝐂 ∈ O, ∘_𝐃,𝐄,𝐅 : M_𝐄,𝐅 × M_𝐃,𝐄 → M_𝐃,𝐅 is an operation for each 𝐃, 𝐄, 𝐅 ∈ O with suitable conditions)

References.

* https://proofwiki.org/wiki/Definition:Composition_of_Morphisms"
`;

exports[`render hlm library: 4.6 Category%20theory/Isomorphisms 1`] = `
"Definition 4.6.  Let u ∈ ℕ, 𝓒 be a/an u-small category, 𝐗, 𝐘 ∈ 𝓒. We define:

  Iso(𝐗, 𝐘) := {f : 𝐗 → 𝐘 : ∃ g : 𝐘 → 𝐗 : [g ∘ f = id_𝐗 and f ∘ g = id_𝐘]}
   = {f : 𝐗 → 𝐘 : ∃! g : 𝐘 → 𝐗 : [g ∘ f = id_𝐗 and f ∘ g = id_𝐘]}

We write “let F : 𝐗 ↔ 𝐘 be an isomorphism” for “let F ∈ Iso(𝐗, 𝐘).”

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Isomorphism#Category_theoretic_view
* https://mathworld.wolfram.com/Isomorphism.html
* https://proofwiki.org/wiki/Definition:Isomorphism_(Category_Theory)
* https://ncatlab.org/nlab/show/isomorphism"
`;

exports[`render hlm library: 4.7.1 Category%20theory/Functors/Functors 1`] = `
"Definition 4.7.1.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category. We define:

  Fun(𝓒, 𝓓) :=: {(𝓒 → 𝓓, 𝐗 ↦ 𝐘_𝐗, (f : 𝐀 → 𝐁) ↦ g_𝐀,𝐁,f) | 𝐘_𝐗 ∈ 𝓓 for each 𝐗 ∈ 𝓒, g_𝐀,𝐁,f : 𝐘_𝐀 → 𝐘_𝐁 is a morphism for each 𝐀, 𝐁 ∈ 𝓒 and f : 𝐀 → 𝐁, [∀ 𝐀 ∈ 𝓒 : g_𝐀,𝐀,id_𝐀 = id_(𝐘_𝐀)], [∀ 𝐀, 𝐁, 𝐂 ∈ 𝓒, d : 𝐀 → 𝐁, e : 𝐁 → 𝐂 : g_𝐀,𝐂,e∘d = g_𝐁,𝐂,e ∘ g_𝐀,𝐁,d]}

  (𝓒 → 𝓓, 𝐗 ↦ 𝐘_𝐗, (f : 𝐀 → 𝐁) ↦ g_𝐀,𝐁,f) = (𝓒 → 𝓓, 𝐗 ↦ 𝐘'_𝐗, (f : 𝐀 → 𝐁) ↦ g'_𝐀,𝐁,f)  :⇔  ∃ i_𝐗 : 𝐘_𝐗 ↔ 𝐘'_𝐗 f.e. 𝐗 ∈ 𝓒 : ∀ 𝐀, 𝐁 ∈ 𝓒, f : 𝐀 → 𝐁 : i_𝐁 ∘ g_𝐀,𝐁,f = g'_𝐀,𝐁,f ∘ i_𝐀  (𝐘_𝐗 ∈ 𝓓 for each 𝐗 ∈ 𝓒, g_𝐀,𝐁,f : 𝐘_𝐀 → 𝐘_𝐁 is a morphism for each 𝐀, 𝐁 ∈ 𝓒 and f : 𝐀 → 𝐁, 𝐘'_𝐗 ∈ 𝓓 for each 𝐗 ∈ 𝓒, g'_𝐀,𝐁,f : 𝐘'_𝐀 → 𝐘'_𝐁 is a morphism for each 𝐀, 𝐁 ∈ 𝓒 and f : 𝐀 → 𝐁 with suitable conditions)

We write “let F : 𝓒 → 𝓓 be a functor” for “let F ∈ Fun(𝓒, 𝓓).”

We write “F :  𝓒 → 𝓓, 𝐗 ↦ 𝐘_𝐗, (f : 𝐀 → 𝐁) ↦ g_𝐀,𝐁,f” for “F := (𝓒 → 𝓓, 𝐗 ↦ 𝐘_𝐗, (f : 𝐀 → 𝐁) ↦ g_𝐀,𝐁,f).”

References.

* https://en.wikipedia.org/wiki/Functor
* https://mathworld.wolfram.com/Functor.html
* https://proofwiki.org/wiki/Definition:Functor
* https://ncatlab.org/nlab/show/functor
* https://leanprover-community.github.io/mathlib_docs/category_theory/functor.html#category_theory.functor"
`;

exports[`render hlm library: 4.7.2 Category%20theory/Functors/object%20value 1`] = `
"Definition 4.7.2.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F : 𝓒 → 𝓓 be a functor, 𝐗 ∈ 𝓒. We define

  F(𝐗)

by:

  (𝓒 → 𝓓, 𝐀 ↦ 𝐘_𝐀, (f : 𝐁 → 𝐂) ↦ g_𝐁,𝐂,f)(𝐗) := 𝐘_𝐗  (𝐘_𝐀 ∈ 𝓓 for each 𝐀 ∈ 𝓒, g_𝐁,𝐂,f : 𝐘_𝐁 → 𝐘_𝐂 is a morphism for each 𝐁, 𝐂 ∈ 𝓒 and f : 𝐁 → 𝐂 with suitable conditions)"
`;

exports[`render hlm library: 4.7.3 Category%20theory/Functors/morphism%20value 1`] = `
"Definition 4.7.3.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F : 𝓒 → 𝓓 be a functor, 𝐗, 𝐘 ∈ 𝓒, f : 𝐗 → 𝐘 be a morphism. We define

  F(f)

by:

  (𝓒 → 𝓓, 𝐀 ↦ 𝐃_𝐀, (g : 𝐁 → 𝐂) ↦ h_𝐁,𝐂,g)(f) := h_𝐗,𝐘,f  (𝐃_𝐀 ∈ 𝓓 for each 𝐀 ∈ 𝓒, h_𝐁,𝐂,g : 𝐃_𝐁 → 𝐃_𝐂 is a morphism for each 𝐁, 𝐂 ∈ 𝓒 and g : 𝐁 → 𝐂 with suitable conditions)"
`;

exports[`render hlm library: 4.7.4 Category%20theory/Functors/identity 1`] = `
"Definition 4.7.4.  Let u ∈ ℕ, 𝓒 be a/an u-small category. We define:

  id_𝓒 :  𝓒 → 𝓒, 𝐗 ↦ 𝐗, (f : 𝐀 → 𝐁) ↦ f

References.

* https://proofwiki.org/wiki/Definition:Identity_Functor
* https://ncatlab.org/nlab/show/identity+functor
* https://leanprover-community.github.io/mathlib_docs/category_theory/functor.html#category_theory.functor.id"
`;

exports[`render hlm library: 4.7.5 Category%20theory/Functors/composition 1`] = `
"Definition 4.7.5.  Let u, v, w ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, 𝓔 be a/an w-small category, F : 𝓒 → 𝓓, G : 𝓓 → 𝓔 be functors. We define:

  G ∘ F :  𝓒 → 𝓔, 𝐗 ↦ G(F(𝐗)), (f : 𝐀 → 𝐁) ↦ G(F(f))

References.

* https://proofwiki.org/wiki/Definition:Composition_of_Functors
* https://leanprover-community.github.io/mathlib_docs/category_theory/functor.html#category_theory.functor.comp"
`;

exports[`render hlm library: 4.8.1 Category%20theory/Natural%20transformations/Infranatural%20transformations 1`] = `
"Definition 4.8.1.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F, G : 𝓒 → 𝓓 be functors. We define:

  Infranat(F, G) :=: {(n_𝐗)_(𝐗 ∈ 𝓒) | n_𝐗 : F(𝐗) → G(𝐗) is a morphism for each 𝐗 ∈ 𝓒}

  (n_𝐗)_(𝐗 ∈ 𝓒) = (m_𝐗)_(𝐗 ∈ 𝓒)  :⇔  ∀ 𝐗 ∈ 𝓒 : n_𝐗 = m_𝐗  (n_𝐗 : F(𝐗) → G(𝐗) is a morphism for each 𝐗 ∈ 𝓒, m_𝐗 : F(𝐗) → G(𝐗) is a morphism for each 𝐗 ∈ 𝓒)

We write “let η : F ⇀ G be an infranatural transformation” for “let η ∈ Infranat(F, G).”

Remarks.

Here, we first define infranatural transformations, as a prerequisite for defining natural transformations (see \`$\\"Natural transformations\\"\`). This is necessary if we want to be able to ask whether a given transformation is natural or not.

References.

* https://en.wikipedia.org/wiki/Natural_transformation#Definition: infranatural transformation"
`;

exports[`render hlm library: 4.8.2 Category%20theory/Natural%20transformations/component 1`] = `
"Definition 4.8.2.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F, G : 𝓒 → 𝓓 be functors, η : F ⇀ G be an infranatural transformation, 𝐗 ∈ 𝓒. We define

  η_𝐗

by:

  ((n_𝐘)_(𝐘 ∈ 𝓒))_𝐗 := n_𝐗  (n_𝐘 : F(𝐘) → G(𝐘) is a morphism for each 𝐘 ∈ 𝓒)

References.

https://leanprover-community.github.io/mathlib_docs/category_theory/natural_transformation.html#category_theory.nat_trans.app"
`;

exports[`render hlm library: 4.8.3 Category%20theory/Natural%20transformations/identity 1`] = `
"Definition 4.8.3.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F : 𝓒 → 𝓓 be a functor. We define:

  id_F := (id_(F(𝐗)))_(𝐗 ∈ 𝓒)
   = (F(id_𝐗))_(𝐗 ∈ 𝓒)

Equality.  No proof.

References.

* https://ncatlab.org/nlab/show/identity+natural+transformation
* https://leanprover-community.github.io/mathlib_docs/category_theory/natural_transformation.html#category_theory.nat_trans.id"
`;

exports[`render hlm library: 4.8.4 Category%20theory/Natural%20transformations/vertical%20composition 1`] = `
"Definition 4.8.4.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F, G, H : 𝓒 → 𝓓 be functors, η : F ⇀ G, ε : G ⇀ H be infranatural transformations. We define:

  ε ∘ η := (ε_𝐗 ∘ η_𝐗)_(𝐗 ∈ 𝓒)

References.

* https://en.wikipedia.org/wiki/Natural_transformation#Operations_with_natural_transformations
* https://leanprover-community.github.io/mathlib_docs/category_theory/natural_transformation.html#category_theory.nat_trans.vcomp"
`;

exports[`render hlm library: 4.8.5 Category%20theory/Natural%20transformations/Natural%20transformations 1`] = `
"Definition 4.8.5.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category, F, G : 𝓒 → 𝓓 be functors. We define:

  Nat(F, G) := {η : F ⇀ G : ∀ 𝐗, 𝐘 ∈ 𝓒, f : 𝐗 → 𝐘 : η_𝐘 ∘ F(f) = G(f) ∘ η_𝐗}

We write “let η : F ⇒ G be a natural transformation” for “let η ∈ Nat(F, G).”

References.

* https://en.wikipedia.org/wiki/Natural_transformation
* https://mathworld.wolfram.com/NaturalTransformation.html
* https://proofwiki.org/wiki/Definition:Natural_Transformation
* https://ncatlab.org/nlab/show/natural+transformation
* https://leanprover-community.github.io/mathlib_docs/category_theory/natural_transformation.html#category_theory.nat_trans"
`;

exports[`render hlm library: 4.9.1 Category%20theory/Concrete%20categories/elements 1`] = `
"Definition 4.9.1.  Let u ∈ ℕ, S be a set. We define:

  𝐃𝐢𝐬_u(S) := [S, ({a} ∩ {b})_(a,b ∈ S), (c)_(c ∈ S), (({e} ∩ {f}) × ({d} ∩ {e}) → ({d} ∩ {f}), x ↦ e)_(d,e,f ∈ S)]_u is a/an u-small category

Remarks.

This is one possible formalization of the discrete category obtained from elements of \`S\`. We simply define morphisms to be elements of \`S\` as well, such that \`%setEquals($../Morphisms(u = u, 𝓒 = $elements(u = u, S = S), 𝐗 = a, 𝐘 = a), %enumeration($../identity(u = u, 𝓒 = $elements(u = u, S = S), 𝐗 = a)), %enumeration(a))\`, and \`%setEquals($../Morphisms(u = u, 𝓒 = $elements(u = u, S = S), 𝐗 = a, 𝐘 = b), $../../Essentials/Sets/\\"Empty set\\")\` if \`%not(%equals(a, b))\`.

(Note that the existence of \`x\` in the definition of morphism composition implies that \`%equals(d, e, f)\`.)

References.

* https://en.wikipedia.org/wiki/Discrete_category
* https://ncatlab.org/nlab/show/discrete+category#CategoricalMeaning
* https://proofwiki.org/wiki/Definition:Discrete_Category_on_Set
* https://leanprover-community.github.io/mathlib_docs/category_theory/discrete_category.html#category_theory.discrete_category"
`;

exports[`render hlm library: 4.9.2 Category%20theory/Concrete%20categories/cardinals 1`] = `
"Definition 4.9.2.  Let u ∈ ℕ. We define:

  𝐒𝐞𝐭_u := [𝓒𝓻𝓭, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓒𝓻𝓭), (id_𝐂)_(𝐂 ∈ 𝓒𝓻𝓭), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓒𝓻𝓭)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of sets, i.e. cardinal numbers. In HLM, arbitrary sets cannot be used as objects because it is impossible to ask whether two arbitrary sets are equal. However, cardinal numbers work fine as a replacement, due to the ability to obtain a representative set from a cardinal number. The situation with other categories is similar.

References.

* https://en.wikipedia.org/wiki/Category_of_sets
* https://proofwiki.org/wiki/Definition:Category_of_Sets
* https://ncatlab.org/nlab/show/Set
* https://leanprover-community.github.io/mathlib_docs/category_theory/types.html#category_theory.types"
`;

exports[`render hlm library: 4.9.3 Category%20theory/Concrete%20categories/ordinals 1`] = `
"Definition 4.9.3.  Let u ∈ ℕ. We define:

  𝐖𝐨𝐬𝐞𝐭_u := [𝓞𝓻𝓭, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓞𝓻𝓭), (id_𝐂)_(𝐂 ∈ 𝓞𝓻𝓭), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓞𝓻𝓭)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of well-ordered sets, i.e. ordinal numbers."
`;

exports[`render hlm library: 4.9.4 Category%20theory/Concrete%20categories/pointed%20sets 1`] = `
"Definition 4.9.4.  Let u ∈ ℕ. We define:

  𝐏𝐭𝐒𝐞𝐭_u := [𝓟𝓽𝓢𝓮𝓽, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓟𝓽𝓢𝓮𝓽), (id_𝐂)_(𝐂 ∈ 𝓟𝓽𝓢𝓮𝓽), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓟𝓽𝓢𝓮𝓽)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of pointed sets.

References.

* https://en.wikipedia.org/wiki/Pointed_set
* https://ncatlab.org/nlab/show/pointed+set
* https://proofwiki.org/wiki/Category:Category_of_Pointed_Sets"
`;

exports[`render hlm library: 4.9.5 Category%20theory/Concrete%20categories/magmas 1`] = `
"Definition 4.9.5.  Let u ∈ ℕ. We define:

  𝐌𝐚𝐠_u := [𝓜𝓪𝓰, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓜𝓪𝓰), (id_𝐂)_(𝐂 ∈ 𝓜𝓪𝓰), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓜𝓪𝓰)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of magmas.

References.

* https://en.wikipedia.org/wiki/Category_of_magmas"
`;

exports[`render hlm library: 4.9.6 Category%20theory/Concrete%20categories/semigroups 1`] = `
"Definition 4.9.6.  Let u ∈ ℕ. We define:

  𝐒𝐞𝐦𝐢𝐆𝐫𝐩_u := [𝓢𝓮𝓶𝓲𝓖𝓻𝓹, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓢𝓮𝓶𝓲𝓖𝓻𝓹), (id_𝐂)_(𝐂 ∈ 𝓢𝓮𝓶𝓲𝓖𝓻𝓹), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓢𝓮𝓶𝓲𝓖𝓻𝓹)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of semigroups."
`;

exports[`render hlm library: 4.9.7 Category%20theory/Concrete%20categories/monoids 1`] = `
"Definition 4.9.7.  Let u ∈ ℕ. We define:

  𝐌𝐨𝐧_u := [𝓜𝓸𝓷, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓜𝓸𝓷), (id_𝐂)_(𝐂 ∈ 𝓜𝓸𝓷), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓜𝓸𝓷)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of monoids.

References.

* https://proofwiki.org/wiki/Definition:Category_of_Monoids
* https://leanprover-community.github.io/mathlib_docs/algebra/category/Mon/basic.html#Mon"
`;

exports[`render hlm library: 4.9.8 Category%20theory/Concrete%20categories/groups 1`] = `
"Definition 4.9.8.  Let u ∈ ℕ. We define:

  𝐆𝐫𝐩_u := [𝓖𝓻𝓹, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓖𝓻𝓹), (id_𝐂)_(𝐂 ∈ 𝓖𝓻𝓹), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓖𝓻𝓹)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of groups.

References.

* https://en.wikipedia.org/wiki/Category_of_groups
* https://proofwiki.org/wiki/Definition:Category_of_Groups
* https://ncatlab.org/nlab/show/Grp
* https://leanprover-community.github.io/mathlib_docs/algebra/category/Group/basic.html#Group"
`;

exports[`render hlm library: 4.9.9 Category%20theory/Concrete%20categories/semirings 1`] = `
"Definition 4.9.9.  Let u ∈ ℕ. We define:

  𝐒𝐞𝐦𝐢𝐑𝐢𝐧𝐠_u := [𝓢𝓮𝓶𝓲𝓡𝓲𝓷𝓰, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓢𝓮𝓶𝓲𝓡𝓲𝓷𝓰), (id_𝐂)_(𝐂 ∈ 𝓢𝓮𝓶𝓲𝓡𝓲𝓷𝓰), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓢𝓮𝓶𝓲𝓡𝓲𝓷𝓰)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of semirings."
`;

exports[`render hlm library: 4.9.10 Category%20theory/Concrete%20categories/rings 1`] = `
"Definition 4.9.10.  Let u ∈ ℕ. We define:

  𝐑𝐢𝐧𝐠_u := [𝓡𝓲𝓷𝓰, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓡𝓲𝓷𝓰), (id_𝐂)_(𝐂 ∈ 𝓡𝓲𝓷𝓰), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓡𝓲𝓷𝓰)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of rings.

References.

* https://en.wikipedia.org/wiki/Category_of_rings
* https://proofwiki.org/wiki/Definition:Category_of_Rings_with_Unity"
`;

exports[`render hlm library: 4.9.11 Category%20theory/Concrete%20categories/left%20modules 1`] = `
"Definition 4.9.11.  Let u ∈ ℕ, 𝐑 be a ring. We define:

  𝐋𝐌𝐨𝐝_u(𝐑) := [𝓛𝓜𝓸𝓭(𝐑), (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓛𝓜𝓸𝓭(𝐑)), (id_𝐂)_(𝐂 ∈ 𝓛𝓜𝓸𝓭(𝐑)), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓛𝓜𝓸𝓭(𝐑))]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of modules.

References.

* https://en.wikipedia.org/wiki/Category_of_modules
* https://proofwiki.org/wiki/Definition:Category_of_Left_Modules
* https://ncatlab.org/nlab/show/Mod
* https://leanprover-community.github.io/mathlib_docs/algebra/category/Module/basic.html#Module.category_theory.category"
`;

exports[`render hlm library: 4.9.12 Category%20theory/Concrete%20categories/right%20modules 1`] = `
"Definition 4.9.12.  Let u ∈ ℕ, 𝐑 be a ring. We define:

  𝐑𝐌𝐨𝐝_u(𝐑) := [𝓡𝓜𝓸𝓭(𝐑), (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓡𝓜𝓸𝓭(𝐑)), (id_𝐂)_(𝐂 ∈ 𝓡𝓜𝓸𝓭(𝐑)), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓡𝓜𝓸𝓭(𝐑))]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of modules.

References.

* https://en.wikipedia.org/wiki/Category_of_modules
* https://proofwiki.org/wiki/Definition:Category_of_Right_Modules
* https://ncatlab.org/nlab/show/Mod"
`;

exports[`render hlm library: 4.9.13 Category%20theory/Concrete%20categories/fields 1`] = `
"Definition 4.9.13.  Let u ∈ ℕ. We define:

  𝐅𝐥𝐝_u := [𝓕𝓵𝓭, (Hom(𝐀, 𝐁))_(𝐀,𝐁 ∈ 𝓕𝓵𝓭), (id_𝐂)_(𝐂 ∈ 𝓕𝓵𝓭), (∘)_(𝐃,𝐄,𝐅 ∈ 𝓕𝓵𝓭)]_u is a/an u-small category

Remarks.

The objects of this category are actually isomorphism classes of fields.

References.

* https://en.wikipedia.org/wiki/Category_of_rings#Category_of_fields
* https://ncatlab.org/nlab/show/field#category"
`;

exports[`render hlm library: 4.9.14 Category%20theory/Concrete%20categories/categories 1`] = `
"Definition 4.9.14.  Let u ∈ ℕ. We define:

  𝐂𝐚𝐭(u) := [𝓒𝓪𝓽_u, (Fun(𝓐, 𝓑))_(𝓐,𝓑 ∈ 𝓒𝓪𝓽_u), (id_𝓒)_(𝓒 ∈ 𝓒𝓪𝓽_u), (∘)_(𝓓,𝓔,𝓕 ∈ 𝓒𝓪𝓽_u)]_(u+1) is a/an (u + 1)-small category

Remarks.

This defines the category of small categories, or, more generally, a category in \`$../../Essentials/Numbers/Natural/sum(m = u, n = $../../Essentials/Numbers/Natural/number(value = 1))\` of all categories in \`u\`.

References.

* https://en.wikipedia.org/wiki/Category_of_small_categories
* https://proofwiki.org/wiki/Definition:Category_of_Categories
* https://ncatlab.org/nlab/show/Cat
* https://leanprover-community.github.io/mathlib_docs/category_theory/category/Cat.html#category_theory.Cat"
`;

exports[`render hlm library: 4.9.15 Category%20theory/Concrete%20categories/functors 1`] = `
"Definition 4.9.15.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝓓 be a/an v-small category. We define:

  𝐅𝐮𝐧(𝓒, 𝓓) := [Fun(𝓒, 𝓓), (Nat(A, B))_(A,B ∈ Fun(𝓒,𝓓)), (id_C)_(C ∈ Fun(𝓒,𝓓)), (∘)_(D,E,F ∈ Fun(𝓒,𝓓))]_(max(u,v)+1) is a/an (max(u, v) + 1)-small category

References.

* https://en.wikipedia.org/wiki/Functor_category
* https://proofwiki.org/wiki/Definition:Functor_Category
* https://ncatlab.org/nlab/show/functor+category
* https://leanprover-community.github.io/mathlib_docs/category_theory/functor_category.html#category_theory.functor.category"
`;

exports[`render hlm library: 4.10.1 Category%20theory/Yoneda/hom-functor 1`] = `
"Definition 4.10.1.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, 𝐀 ∈ 𝓒. We define:

  Hom_v(𝐀, −) :  𝓒 → 𝐒𝐞𝐭_v, 𝐗 ↦ |Hom(𝐀, 𝐗)|, (f : 𝐘 → 𝐙) ↦ (Hom(𝐀, 𝐘) → Hom(𝐀, 𝐙), g ↦ f ∘ g)

References.

* https://en.wikipedia.org/wiki/Hom_functor
* https://proofwiki.org/wiki/Definition:Covariant_Hom_Functor
* https://ncatlab.org/nlab/show/hom-functor"
`;

exports[`render hlm library: 4.10.2 Category%20theory/Yoneda/yoneda%20equivalence 1`] = `
"Definition 4.10.2.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, F : 𝓒 → 𝐒𝐞𝐭_v be a functor, 𝐀 ∈ 𝓒. We define:

  yoneda(F, 𝐀) :  Nat(Hom_v(𝐀, −), F) → (F(𝐀)), η ↦ η_𝐀(id_𝐀)

References.

* https://en.wikipedia.org/wiki/Yoneda_lemma#Formal_statement
* https://proofwiki.org/wiki/Bijection_in_Yoneda_Lemma_for_Covariant_Functors
* https://ncatlab.org/nlab/show/Yoneda+lemma"
`;

exports[`render hlm library: 4.10.3 Category%20theory/Yoneda/Yoneda%20lemma%20bijection 1`] = `
"Theorem 4.10.3.  Let u, v ∈ ℕ, 𝓒 be a/an u-small category, F : 𝓒 → 𝐒𝐞𝐭_v be a functor, 𝐀 ∈ 𝓒. Then:

  yoneda(F, 𝐀) is bijective and (yoneda(F, 𝐀))^-1 = ((F(𝐀)) → Nat(Hom_v(𝐀, −), F), x ↦ (Hom(𝐀, 𝐗) → (F(𝐗)), f ↦ F(f)(x))_(𝐗 ∈ 𝓒))

No proof.

References.

* https://en.wikipedia.org/wiki/Yoneda_lemma#Formal_statement
* https://proofwiki.org/wiki/Bijection_in_Yoneda_Lemma_for_Covariant_Functors
* https://ncatlab.org/nlab/show/Yoneda+lemma
* https://leanprover-community.github.io/mathlib_docs/category_theory/yoneda.html"
`;

exports[`render hlm library: 5.1 Formal%20systems/Variables 1`] = `
"Definition 5.1.  We define:

  𝓥𝓪𝓻 :=: {(n) | n ∈ ℕ}

  (m) = (n)  :⇔  m = n  (m ∈ ℕ, n ∈ ℕ)

We write “let v be a variable” for “let v ∈ 𝓥𝓪𝓻.”

Remarks.

This definition formalizes an infinite supply of variables. Each variable is identified by a natural number, but that number is not used anywhere. In fact, any infinite set would do.

Therefore, variables in the modelled language do not carry a name. Instead, we use bound variables in HLM (i.e. in the meta language) to model variables in the target language, and these bound variables have a name in HLM.

As a consequence, α-equivalent terms are never distinguishable."
`;

exports[`render hlm library: 5.2 Formal%20systems/Fresh%20variables 1`] = `
"Definition 5.2.  Let V ⊆ 𝓥𝓪𝓻 such that V is finite. We define:

  Fresh(V) := 𝓥𝓪𝓻 ∖ V

Remarks.

This is just the subset of variables that do not appear in \`V\`. It should be used whenever a new bound variable is needed."
`;

exports[`render hlm library: 5.3 Formal%20systems/Rewriting%20rules 1`] = `
"Definition 5.3.  Let T be a set. We define:

  𝓡𝓮𝔀𝓻(T) :=: {l → r | l, r ∈ T}

  (l → r) = (l' → r')  :⇔  l = l' and r = r'  (l, r ∈ T, l', r' ∈ T)

For T' ⊆ T, we canonically treat elements of 𝓡𝓮𝔀𝓻(T') as elements of 𝓡𝓮𝔀𝓻(T).

Remarks.

This definition just provides some useful notation for rewriting rules for terms in \`T\`. It is actually equivalent to the Cartesian product of \`T\` with itself."
`;

exports[`render hlm library: 5.4.1 Formal%20systems/Untyped%20lambda%20calculus/Terms 1`] = `
"Definition 5.4.1.  Let V ⊆ 𝓥𝓪𝓻 such that V is finite. We define:

  𝓣_V :=: {(x) | x ∈ V, λx. M_x | M_x ∈ 𝓣_(V ∪ {x}) for each x ∈ Fresh(V), [∀ x, y ∈ Fresh(V) : M_x[x := y] = M_y], M N | M, N ∈ 𝓣_V}

  (x) = (y)  :⇔  x = y  (x ∈ V, y ∈ V)

  λx. M_x = λx. M'_x  :⇔  ∀ x ∈ Fresh(V) : M_x = M'_x  (M_x ∈ 𝓣_(V ∪ {x}) for each x ∈ Fresh(V), M'_x ∈ 𝓣_(V ∪ {x}) for each x ∈ Fresh(V) with suitable conditions)
    ⇔  ∃ x ∈ Fresh(V) : M_x = M'_x

  M N = M' N'  :⇔  M = M' and N = N'  (M, N ∈ 𝓣_V, M', N' ∈ 𝓣_V)

V ⊆: 𝓣_V via
x = (x)

  Well-definedness.  No proof.

Remarks.

This formalization of the untyped lambda calculus is fairly standard except for one aspect: The right side of a lambda abstraction depends on the value of the bound variable used to define it (which is kind of the point of bound variables). To prevent wild pseudo-terms that actually differ in nontrivial ways depending on the variable, there needs to be an additional substitutability constraint. Although substitution is defined later, we can use it in this case because we are applying it to subterms only (i.e. we are employing mutual induction).

References.

* https://en.wikipedia.org/wiki/Lambda_calculus
* https://ncatlab.org/nlab/show/lambda-calculus#https://ncatlab.org/nlab/show/lambda-calculus#pure_lambda_calculus"
`;

exports[`render hlm library: 5.4.2 Formal%20systems/Untyped%20lambda%20calculus/substitution 1`] = `
"Definition 5.4.2.  Let V ⊆ 𝓥𝓪𝓻 such that V is finite, T ∈ 𝓣_V, x ∈ V, R ∈ 𝓣_(V ∖ {x}). We define

  T[x := R]

by:

  (y)[x := R] := {R if x = y, (y) if x ≠ y  (y ∈ V)
  (λy. M_y)[x := R] := λz. M_z[x := R]  (M_y ∈ 𝓣_(V ∪ {y}) for each y ∈ Fresh(V), [∀ y, z ∈ Fresh(V) : M_y[y := z] = M_z])
  (M N)[x := R] := M[x := R] N[x := R]  (M, N ∈ 𝓣_V)

Remarks.

Note that we do not allow \`x\` to appear free in \`R\`. This ensures that \`x\` does not appear free in the result either, which is important for e.g. the definition \`$\\"beta reduction\\"\` of beta reduction.

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Substitution
* https://ncatlab.org/nlab/show/substitution#avoiding+variable+capture"
`;

exports[`render hlm library: 5.4.3 Formal%20systems/Untyped%20lambda%20calculus/rewritable 1`] = `
"Definition 5.4.3.  Let V ⊆ 𝓥𝓪𝓻 such that V is finite, ℜ ⊆ 𝓡𝓮𝔀𝓻(𝓣_V), L, R ∈ 𝓣_V. We define:

  L →_ℜ R  :⇔  (L → R) ∈ ℜ or {false if R = (z) (z ∈ V), [{false if L = (y) (y ∈ V), ∀ v ∈ Fresh(V) : M_v →_ℜ N_v if L = λy. M_y (M_y ∈ 𝓣_(V ∪ {y}) for each y ∈ Fresh(V), [∀ a, b ∈ Fresh(V) : M_a[a := b] = M_b]), false if L = M N (M, N ∈ 𝓣_V)] if R = λz. N_z (N_z ∈ 𝓣_(V ∪ {z}) for each z ∈ Fresh(V), [∀ a, b ∈ Fresh(V) : N_a[a := b] = N_b]), [{false if L = (y) (y ∈ V), false if L = λy. M_y (M_y ∈ 𝓣_(V ∪ {y}) for each y ∈ Fresh(V), [∀ a, b ∈ Fresh(V) : M_a[a := b] = M_b]), [M →_ℜ O and N = P] or [M = O and N →_ℜ P] if L = M N (M, N ∈ 𝓣_V)] if R = O P (O, P ∈ 𝓣_V)

  L ↛_ℜ R  :⇔  not [L →_ℜ R]

Remarks.

This definition checks whether a rewrite rule matches a pair of terms. It considers both the pair itself as well as all subterms. Structural induction on both sides makes the definition a bit complicated."
`;

exports[`render hlm library: 5.4.4 Formal%20systems/Untyped%20lambda%20calculus/beta%20reduction 1`] = `
"Definition 5.4.4 (β reduction).  Let V ⊆ 𝓥𝓪𝓻 such that V is finite. We define:

  β_V := {(λz. M_z) N → M_y[y := N] : M_x ∈ 𝓣_(V ∪ {x}) for each x ∈ Fresh(V), N ∈ 𝓣_V, y ∈ Fresh(V)}

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction
* https://ncatlab.org/nlab/show/beta-reduction"
`;

exports[`render hlm library: 5.4.5 Formal%20systems/Untyped%20lambda%20calculus/eta%20conversion 1`] = `
"Definition 5.4.5 (η conversion).  Let V ⊆ 𝓥𝓪𝓻 such that V is finite. We define:

  η_V := {λz. M z → M : M ∈ 𝓣_V}

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion
* https://ncatlab.org/nlab/show/eta-conversion"
`;

exports[`render hlm library: 5.4.6.1 Formal%20systems/Untyped%20lambda%20calculus/Combinators/identity 1`] = `
"Definition 5.4.6.1.  We define:

  𝗜 := λx. x

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.2 Formal%20systems/Untyped%20lambda%20calculus/Combinators/constant 1`] = `
"Definition 5.4.6.2.  We define:

  𝗞 := λx. λy. x

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.3 Formal%20systems/Untyped%20lambda%20calculus/Combinators/substitution 1`] = `
"Definition 5.4.6.3.  We define:

  𝗦 := λx. λy. λz. (x z) (y z)

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.4 Formal%20systems/Untyped%20lambda%20calculus/Combinators/omega 1`] = `
"Definition 5.4.6.4.  We define:

  𝞈 := λx. x x

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.5 Formal%20systems/Untyped%20lambda%20calculus/Combinators/fixed-point 1`] = `
"Definition 5.4.6.5.  We define:

  𝗬 := λf. (λx. f (x x)) (λx. f (x x))

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms
* https://ncatlab.org/nlab/show/fixed-point+combinator"
`;
