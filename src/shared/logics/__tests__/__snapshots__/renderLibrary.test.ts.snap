// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`render hlm library: 1.1.1 data/libraries/hlm/Essentials/Sets/Empty%20set 1`] = `
"Definition 1.1.1.  We define:

  âˆ…â€…:=â€…{}

Remarks.

This defines the empty set as an enumeration with no elements. Note that sets are a built-in concept in the HLM logic.

References.

* https://en.wikipedia.org/wiki/Empty_set
* http://mathworld.wolfram.com/EmptySet.html
* https://proofwiki.org/wiki/Definition:Empty_Set
* https://ncatlab.org/nlab/show/empty+set"
`;

exports[`render hlm library: 1.1.2 data/libraries/hlm/Essentials/Sets/Empty%20set%20is%20subset%20of%20any%20set 1`] = `
"Proposition 1.1.2.  Let S be a set. Then:

  âˆ…â€…âŠ†â€…S

Proof.  Let xâ€‰âˆˆâ€‰âˆ…. Then xâ€…âˆˆâ€…S:

xâ€…âˆˆâ€…âˆ…

â‡’^def âš¡"
`;

exports[`render hlm library: 1.1.3 data/libraries/hlm/Essentials/Sets/empty 1`] = `
"Definition 1.1.3.  Let S be a set. We define:

  S is empty â€Š:â‡” â€ŠSâ€…=â€…âˆ…
   â€Šâ‡” â€ŠSâ€…âŠ†â€…âˆ…
   â€Šâ‡” â€Šâˆ„â€‰xâ€‰âˆˆâ€‰S

  S is nonempty â€Š:â‡” â€ŠS is not empty

Equivalence.

1â‡’2. Assume Sâ€…=â€…âˆ…. Then Sâ€…âŠ†â€…âˆ…:

Sâ€…=â€…âˆ…

â‡’^def Sâ€…âŠ†â€…âˆ…
2â‡’3. Assume Sâ€…âŠ†â€…âˆ…. Then âˆ„â€‰xâ€‰âˆˆâ€‰S:

Assume âˆƒâ€‰xâ€‰âˆˆâ€‰S.

Sâ€…âŠ†â€…âˆ…

â‡’^def âˆ€â€†sâ€‰âˆˆâ€‰Sâ€‰: sâ€…âˆˆâ€…âˆ…

â‡’ xâ€…âˆˆâ€…âˆ…

â‡’^def âš¡
3â‡’1. Assume âˆ„â€‰xâ€‰âˆˆâ€‰S. Then Sâ€…=â€…âˆ…:

âŠ†. Let aâ€‰âˆˆâ€‰S. Then aâ€…âˆˆâ€…âˆ…:

We have âˆƒâ€‰xâ€‰âˆˆâ€‰S:

Choose xâ€…:=â€…a.
âŠ‡. 1.1.2 â‡’ âˆ…â€…âŠ†â€…S

Remarks.

In HLM, multiple alternative definitions can be given for an operator or predicate, if they can be shown to be equal/equivalent. In proofs, the most convenient alternative can be selected at will, which reduces the number of necessary steps. Sometimes, it also makes sense to prove a property according to one alternative and then use it according to another."
`;

exports[`render hlm library: 1.1.4 data/libraries/hlm/Essentials/Sets/finite 1`] = `
"Definition 1.1.4.  Let S be a set. We define:

  S is finite â€Š:â‡” â€Š|S|â€…âˆˆâ€…â„•
   â€Šâ‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰â„•â€‰: |S|â€…=â€…x
   â€Šâ‡” â€Šâˆƒâ€†yâ€‰âˆˆâ€‰â„•â€‰: |S|â€…â‰¤â€…y
   â€Šâ‡” â€Šâˆƒâ€†zâ€‰âˆˆâ€‰â„•â€‰: |S|â€…<â€…z
   â€Šâ‡” â€Šâˆƒâ€‰kâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰Sâ€‰â†”â€‰â„•_(<k)
   â€Šâ‡” â€Šâˆƒâ€‰lâ€‰âˆˆâ€‰â„•, gâ€‰:â€‰â„•_(<l)â€‰â†”â€‰S
   â€Šâ‡” â€Šâˆƒâ€†mâ€‰âˆˆâ€‰â„•, hâ€‰:â€‰Sâ€‰â†’â€‰â„•_(<m)â€‰: h is injective
   â€Šâ‡” â€Šâˆƒâ€†nâ€‰âˆˆâ€‰â„•, iâ€‰:â€‰Sâ€‰â†’â€‰â„•_(â‰¤n)â€‰: i is injective

  S is infinite â€Š:â‡” â€ŠS is not finite

Equivalence.

1â‡’5. Assume |S|â€…âˆˆâ€…â„•. Then âˆƒâ€‰kâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰Sâ€‰â†”â€‰â„•_(<k):

|S|â€…=â€…|â„•_(<|S|)|

â‡’^def âˆƒâ€‰râ€‰:â€‰Sâ€‰â†”â€‰â„•_(<|S|)

Choose kâ€…:=â€…|S|, fâ€…:=â€…r.
5â‡’6. Assume âˆƒâ€‰kâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰Sâ€‰â†”â€‰â„•_(<k). Then âˆƒâ€‰lâ€‰âˆˆâ€‰â„•, gâ€‰:â€‰â„•_(<l)â€‰â†”â€‰S:

Choose lâ€…:=â€…k, gâ€…:=â€…f^-1.
6â‡’1. Assume âˆƒâ€‰lâ€‰âˆˆâ€‰â„•, gâ€‰:â€‰â„•_(<l)â€‰â†”â€‰S. Then |S|â€…âˆˆâ€…â„•:

We have |â„•_(<l)|â€…=â€…|S|:

We show that âˆƒâ€‰sâ€‰:â€‰Sâ€‰â†”â€‰â„•_(<l):

Choose sâ€…:=â€…g.

â‡’^[lâ€Š=â€Š|â„•_(<l)|] lâ€…=â€…|S|

lâ€…âˆˆâ€…â„•

â‡’^[lâ€Š=â€Š|S|] |S|â€…âˆˆâ€…â„•
5â‡’7. Assume âˆƒâ€‰kâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰Sâ€‰â†”â€‰â„•_(<k). Then âˆƒâ€†mâ€‰âˆˆâ€‰â„•, hâ€‰:â€‰Sâ€‰â†’â€‰â„•_(<m)â€‰: h is injective:

def â‡’ f is injective

Choose mâ€…:=â€…k, hâ€…:=â€…f.
7â‡’8. Assume âˆƒâ€†mâ€‰âˆˆâ€‰â„•, hâ€‰:â€‰Sâ€‰â†’â€‰â„•_(<m)â€‰: h is injective. Then âˆƒâ€†nâ€‰âˆˆâ€‰â„•, iâ€‰:â€‰Sâ€‰â†’â€‰â„•_(â‰¤n)â€‰: i is injective:

â‡’^1.6.1.17.6 â„•_(<m)â€…âŠ†â€…â„•_(â‰¤m)

Choose nâ€…:=â€…m, iâ€…:=â€…hâˆ£_S^(â„•_(â‰¤m)).
8â‡’3. Assume âˆƒâ€†nâ€‰âˆˆâ€‰â„•, iâ€‰:â€‰Sâ€‰â†’â€‰â„•_(â‰¤n)â€‰: i is injective. Then âˆƒâ€†yâ€‰âˆˆâ€‰â„•â€‰: |S|â€…â‰¤â€…y:

iâ€…âˆˆâ€…(Sâ€‰â†’â€‰â„•_(â‰¤n))

â‡’^def iâ€…âˆˆâ€…(Sâ€‰â†’â€‰â„•_(<(n+1)))

Choose yâ€…:=â€…(n+1). We show that |S|â€…â‰¤â€…(n+1):

We show that âˆƒâ€†tâ€‰:â€‰Sâ€‰â†’â€‰â„•_(<(n+1))â€‰: t is injective:

Choose tâ€…:=â€…i.
3â‡’5. Assume âˆƒâ€†yâ€‰âˆˆâ€‰â„•â€‰: |S|â€…â‰¤â€…y. Then âˆƒâ€‰kâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰Sâ€‰â†”â€‰â„•_(<k):

â‡’^def âˆƒâ€†uâ€‰:â€‰Sâ€‰â†’â€‰â„•_(<y)â€‰: u is injective

Let Tâ€‰:=â€‰u(S).

Let oâ€‰:=â€‰|T|_â‰¤y.

Let vâ€‰:â€‰â€Šâ„•_(<o)â€‰â†’â€‰T, zâ€‰â†¦â€‰T[z].

Choose kâ€…:=â€…o, fâ€…:=â€…v^-1â€‰âˆ˜â€‰uâˆ£_S^T.

Remarks.

This definition uses [functions](../Functions/Functions) as well as the [natural](../Numbers/Natural/Natural%20numbers) and [cardinal](../Numbers/Cardinal/Cardinal%20numbers) numbers, all of which are defined in later sections. That is not a problem as long as no circularities exist. In other words, definitions and theorems are ordered by topic instead of by dependency.

Note also that the definition heavily relies on the embedding of the natural numbers into the cardinal numbers, which is completely transparent in HLM.

These are just some example proofs, some equivalences are missing at the moment.

References.

* https://en.wikipedia.org/wiki/Finite_set
* http://mathworld.wolfram.com/FiniteSet.html
* https://proofwiki.org/wiki/Definition:Finite_Set
* https://ncatlab.org/nlab/show/finite+set"
`;

exports[`render hlm library: 1.1.5 data/libraries/hlm/Essentials/Sets/Subsets%20of%20finite%20sets%20are%20finite 1`] = `
"Proposition 1.1.5.  Let S be a finite set, Tâ€‰âŠ†â€‰S. Then:

  T is finite

Proof.  We show that âˆƒâ€†mâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰Tâ€‰â†’â€‰â„•_(<m)â€‰: f is injective:

S is finite

â‡’^def âˆƒâ€†nâ€‰âˆˆâ€‰â„•, gâ€‰:â€‰Sâ€‰â†’â€‰â„•_(<n)â€‰: g is injective

Choose mâ€…:=â€…n, fâ€…:=â€…gâˆ£_T. We show that gâˆ£_T is injective:

1.4.18 â‡’ gâˆ£_T is injective

Remarks.

This is just an example proof. It could be rewritten in a very concise way as a proof about cardinals."
`;

exports[`render hlm library: 1.1.6 data/libraries/hlm/Essentials/Sets/Intersection 1`] = `
"Definition 1.1.6.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. We define:

  Sâ€…âˆ©â€…Tâ€…:=â€…{xâ€‰âˆˆâ€‰Uâ€‰: xâ€…âˆˆâ€…S and xâ€…âˆˆâ€…T}

Remarks.

Due to the type system of HLM, it is impossible to define the intersection of two arbitrary sets. Instead, both sets must be declared as subsets of a common superset _U_, although the intersection is, of course, independent of _U_. Since a suitable value for _U_ can always be inferred automatically, _U_ can be omitted from the notation.

References.

* https://en.wikipedia.org/wiki/Intersection_(set_theory)
* http://mathworld.wolfram.com/Intersection.html
* https://proofwiki.org/wiki/Definition:Set_Intersection"
`;

exports[`render hlm library: 1.1.7 data/libraries/hlm/Essentials/Sets/Intersection%20is%20associative 1`] = `
"Proposition 1.1.7.  Let U be a set, R,â€ŠS,â€ŠTâ€‰âŠ†â€‰U. Then:

  (Râ€…âˆ©â€…S)â€…âˆ©â€…Tâ€…=â€…Râ€…âˆ©â€…(Sâ€…âˆ©â€…T)

No proof.

References.

* https://proofwiki.org/wiki/Intersection_is_Associative"
`;

exports[`render hlm library: 1.1.8 data/libraries/hlm/Essentials/Sets/Intersection%20is%20commutative 1`] = `
"Proposition 1.1.8.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. Then:

  Sâ€…âˆ©â€…Tâ€…=â€…Tâ€…âˆ©â€…S

No proof.

References.

* https://proofwiki.org/wiki/Intersection_is_Commutative"
`;

exports[`render hlm library: 1.1.9 data/libraries/hlm/Essentials/Sets/Intersection%20is%20subset%20of%20argument 1`] = `
"Proposition 1.1.9.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. Then:

  Sâ€…âˆ©â€…Tâ€…âŠ†â€…S

No proof.

References.

* https://proofwiki.org/wiki/Intersection_is_Subset"
`;

exports[`render hlm library: 1.1.10 data/libraries/hlm/Essentials/Sets/Union 1`] = `
"Definition 1.1.10.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. We define:

  Sâ€…âˆªâ€…Tâ€…:=â€…{xâ€‰âˆˆâ€‰Uâ€‰: xâ€…âˆˆâ€…S or xâ€…âˆˆâ€…T}

Remarks.

Due to the type system of HLM, it is impossible to define the union of two arbitrary sets. Instead, both sets must be declared as subsets of a common superset _U_, although the intersection is, of course, independent of _U_. Since a suitable value for _U_ can always be inferred automatically, _U_ can be omitted from the notation.

References.

* https://en.wikipedia.org/wiki/Union_(set_theory)
* http://mathworld.wolfram.com/Union.html
* https://proofwiki.org/wiki/Definition:Set_Union"
`;

exports[`render hlm library: 1.1.11 data/libraries/hlm/Essentials/Sets/Union%20is%20associative 1`] = `
"Proposition 1.1.11.  Let U be a set, R,â€ŠS,â€ŠTâ€‰âŠ†â€‰U. Then:

  (Râ€…âˆªâ€…S)â€…âˆªâ€…Tâ€…=â€…Râ€…âˆªâ€…(Sâ€…âˆªâ€…T)

No proof.

References.

* https://proofwiki.org/wiki/Union_is_Associative"
`;

exports[`render hlm library: 1.1.12 data/libraries/hlm/Essentials/Sets/Union%20is%20commutative 1`] = `
"Proposition 1.1.12.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. Then:

  Sâ€…âˆªâ€…Tâ€…=â€…Tâ€…âˆªâ€…S

No proof.

References.

* https://proofwiki.org/wiki/Union_is_Commutative"
`;

exports[`render hlm library: 1.1.13 data/libraries/hlm/Essentials/Sets/Union%20is%20superset%20of%20argument 1`] = `
"Proposition 1.1.13.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. Then:

  Sâ€…âŠ†â€…Sâ€…âˆªâ€…T

No proof."
`;

exports[`render hlm library: 1.1.14 data/libraries/hlm/Essentials/Sets/Relative%20complement 1`] = `
"Definition 1.1.14.  Let U be a set, S,â€ŠTâ€‰âŠ†â€‰U. We define:

  Sâ€…âˆ–â€…Tâ€…:=â€…{xâ€‰âˆˆâ€‰Uâ€‰: xâ€…âˆˆâ€…S and xâ€…âˆ‰â€…T}
  â€…=â€…{xâ€‰âˆˆâ€‰Sâ€‰: xâ€…âˆ‰â€…T}

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement
* http://mathworld.wolfram.com/SetDifference.html
* https://proofwiki.org/wiki/Definition:Set_Difference"
`;

exports[`render hlm library: 1.1.15 data/libraries/hlm/Essentials/Sets/Disjoint%20union 1`] = `
"Definition 1.1.15.  Let S,â€ŠT be sets. We define:

  Sâ€…âŠŽâ€…Tâ€…:=:â€…{l(s) | sâ€‰âˆˆâ€‰S, r(t) | tâ€‰âˆˆâ€‰T}

  l(s)â€…=â€…l(s') â€Š:â‡” â€Šsâ€…=â€…s'  (s,â€Šs'â€‰âˆˆâ€‰S)

  r(t)â€…=â€…r(t') â€Š:â‡” â€Štâ€…=â€…t'  (t,â€Št'â€‰âˆˆâ€‰T)

For S'â€‰âŠ†â€‰S and T'â€‰âŠ†â€‰T, we canonically treat elements of S'â€…âŠŽâ€…T' as elements of Sâ€…âŠŽâ€…T.

Remarks.

In contrast to the definition of set union, the disjoint union of sets is a â€œconstruction,â€ which is an HLM-specific concept very similar to an inductive definition in type theory. The disjoint union has two â€œconstructors.â€

Note that the set and its constructors are introduced at the same time, hence the non-standard notation â€œ:=:â€. The notation on both sides can be specified freely.

A construction always includes definitions of equality for each constructor. In this case, those definitions are what one might expect. (Different constructors are never considered equal.)

References.

* https://en.wikipedia.org/wiki/Disjoint_union
* http://mathworld.wolfram.com/DisjointUnion.html
* https://proofwiki.org/wiki/Definition:Disjoint_Union_(Set_Theory)"
`;

exports[`render hlm library: 1.1.16 data/libraries/hlm/Essentials/Sets/Cartesian%20product 1`] = `
"Definition 1.1.16.  Let S,â€ŠT be sets. We define:

  Sâ€‰Ã—â€‰Tâ€…:=:â€…{(s,â€Št) | sâ€‰âˆˆâ€‰S, tâ€‰âˆˆâ€‰T}

  (s,â€Št)â€…=â€…(s',â€Št') â€Š:â‡” â€Šsâ€…=â€…s' and tâ€…=â€…t'  (sâ€‰âˆˆâ€‰S, tâ€‰âˆˆâ€‰T, s'â€‰âˆˆâ€‰S, t'â€‰âˆˆâ€‰T)

For S'â€‰âŠ†â€‰S and T'â€‰âŠ†â€‰T, we canonically treat elements of S'â€‰Ã—â€‰T' as elements of Sâ€‰Ã—â€‰T.

Remarks.

The Cartesian product is, again, a â€œconstruction.â€ Note that HLM does not have any built-in notion of â€œtupleâ€ â€“ it is actually defined here as a constructor, with the usual notation.

References.

* https://en.wikipedia.org/wiki/Cartesian_product
* http://mathworld.wolfram.com/CartesianProduct.html
* https://proofwiki.org/wiki/Definition:Cartesian_Product"
`;

exports[`render hlm library: 1.1.17 data/libraries/hlm/Essentials/Sets/Power%20set 1`] = `
"Definition 1.1.17.  Let S be a set. We define:

  ð’«(S)â€…:=:â€…{(T) | Tâ€‰âŠ†â€‰S}

  (T)â€…=â€…(T') â€Š:â‡” â€ŠTâ€…=â€…T'  (T,â€ŠT'â€‰âŠ†â€‰S)

For S'â€‰âŠ†â€‰S, we canonically treat elements of ð’«(S') as elements of ð’«(S).

Remarks.

The power set is another example of a construction. It is slightly nonstandard in that its elements are not actual subsets but terms that are built using the constructor of this construction. To highlight this difference, parentheses are used. There is no significant practical difference, however.

References.

* https://en.wikipedia.org/wiki/Power_set
* http://mathworld.wolfram.com/PowerSet.html
* https://proofwiki.org/wiki/Definition:Power_Set
* https://ncatlab.org/nlab/show/power+set
* https://coq.inria.fr/library/Coq.Sets.Powerset.html"
`;

exports[`render hlm library: 1.1.18 data/libraries/hlm/Essentials/Sets/Generalized%20intersection 1`] = `
"Definition 1.1.18.  Let U,â€ŠI be sets, let S_iâ€‰âŠ†â€‰U for each iâ€‰âˆˆâ€‰I. We define:

  â‹‚_(iâ€Šâˆˆâ€ŠI)â€‰S_iâ€…:=â€…{xâ€‰âˆˆâ€‰Uâ€‰: âˆ€â€†jâ€‰âˆˆâ€‰Iâ€‰: xâ€…âˆˆâ€…S_j}

Remarks.

Similarly to the definition of the intersection of two sets, we have to specify a common superset _U_ for all sets. As a side effect, _I_ is allowed to be empty, in which case the result is simply _U_.

References.

* https://en.wikipedia.org/wiki/Intersection_(set_theory)#Arbitrary_intersections
* https://proofwiki.org/wiki/Definition:Set_Intersection/Family_of_Sets"
`;

exports[`render hlm library: 1.1.19 data/libraries/hlm/Essentials/Sets/Generalized%20intersection%20using%20power%20set 1`] = `
"Definition 1.1.19.  Let U be a set, Sâ€‰âŠ†â€‰ð’«(U). We define:

  â‹‚Sâ€…:=â€…â‹‚_((T)â€Šâˆˆâ€ŠS)â€‰T

References.

* https://en.wikipedia.org/wiki/Intersection_(set_theory)#Arbitrary_intersections"
`;

exports[`render hlm library: 1.1.20 data/libraries/hlm/Essentials/Sets/Generalized%20union 1`] = `
"Definition 1.1.20.  Let U,â€ŠI be sets, let S_iâ€‰âŠ†â€‰U for each iâ€‰âˆˆâ€‰I. We define:

  â‹ƒ_(iâ€Šâˆˆâ€ŠI)â€‰S_iâ€…:=â€…{xâ€‰âˆˆâ€‰Uâ€‰: âˆƒâ€†jâ€‰âˆˆâ€‰Iâ€‰: xâ€…âˆˆâ€…S_j}

References.

* https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions
* https://proofwiki.org/wiki/Definition:Set_Union/Family_of_Sets"
`;

exports[`render hlm library: 1.1.21 data/libraries/hlm/Essentials/Sets/Generalized%20union%20using%20power%20set 1`] = `
"Definition 1.1.21.  Let U be a set, Sâ€‰âŠ†â€‰ð’«(U). We define:

  â‹ƒSâ€…:=â€…â‹ƒ_((T)â€Šâˆˆâ€ŠS)â€‰T

References.

* https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions"
`;

exports[`render hlm library: 1.1.22 data/libraries/hlm/Essentials/Sets/Generalized%20cartesian%20product 1`] = `
"Definition 1.1.22.  Let I be a set, let S_i be a set for each iâ€‰âˆˆâ€‰I. We define:

  âˆ_(iâ€Šâˆˆâ€ŠI)â€‰S_iâ€…:=:â€…{(s_j)_(jâ€Šâˆˆâ€ŠI) | s_jâ€‰âˆˆâ€‰S_j for each jâ€‰âˆˆâ€‰I}

  (s_j)_(jâ€Šâˆˆâ€ŠI)â€…=â€…(s'_j)_(jâ€Šâˆˆâ€ŠI) â€Š:â‡” â€Šâˆ€â€†jâ€‰âˆˆâ€‰Iâ€‰: s_jâ€…=â€…s'_j  (s_jâ€‰âˆˆâ€‰S_j for each jâ€‰âˆˆâ€‰I, s'_jâ€‰âˆˆâ€‰S_j for each jâ€‰âˆˆâ€‰I)

Remarks.

The generalized Cartesian product over an index set can be constructed in HLM via its integrated bound variable concept. It is essentially the same as a set of dependent functions.

References.

* https://en.wikipedia.org/wiki/Cartesian_product#Infinite_Cartesian_products
* https://proofwiki.org/wiki/Definition:Cartesian_Product/Family_of_Sets"
`;

exports[`render hlm library: 1.1.23 data/libraries/hlm/Essentials/Sets/Truth%20values 1`] = `
"Definition 1.1.23.  We define:

  ð“£ð“»ð“¾ð“½ð“±â€…:=:â€…{[p] | p is a proposition}

  [p]â€…=â€…[q] â€Š:â‡” â€Š[p â€Šâ‡” â€Šq]  (p,â€Šq are propositions)

We write â€œlet p be a truth valueâ€ for â€œlet pâ€‰âˆˆâ€‰ð“£ð“»ð“¾ð“½ð“±.â€

Remarks.

This definition captures propositions up to equivalence. Since HLM uses classical logic, it can be proved to contain only two values, true and false. It can therefore be used interchangeably with the set of [binary digits](../Numbers/Natural/Subsets/Binary%20digits).

References.

* https://en.wikipedia.org/wiki/Truth_value
* https://proofwiki.org/wiki/Definition:Truth_Value
* https://ncatlab.org/nlab/show/truth+value"
`;

exports[`render hlm library: 1.1.24.1 data/libraries/hlm/Essentials/Sets/Choice/Choice%20functions 1`] = `
"Definition 1.1.24.1.  Let S be a set. We define:

  ð“’ð“±ð“¸ð“²ð“¬ð“®(S)â€…:=â€…{fâ€‰:â€‰(ð’«(S)â€…âˆ–â€…{(âˆ…)})â€‰â†’â€‰Sâ€‰: âˆ€â€†Tâ€‰âŠ†â€‰S s.t. T is nonemptyâ€‰: f(T)â€…âˆˆâ€…T}

We write â€œlet f be a choice function on Sâ€ for â€œlet fâ€‰âˆˆâ€‰ð“’ð“±ð“¸ð“²ð“¬ð“®(S).â€

References.

* https://en.wikipedia.org/wiki/Axiom_of_choice#Variants"
`;

exports[`render hlm library: 1.1.24.2 data/libraries/hlm/Essentials/Sets/Choice/choice 1`] = `
"Definition 1.1.24.2.  Let S be a set. We define:

  S has a choice function â€Š:â‡” â€Šð“’ð“±ð“¸ð“²ð“¬ð“®(S) is nonempty"
`;

exports[`render hlm library: 1.1.24.3 data/libraries/hlm/Essentials/Sets/Choice/axiom%20of%20choice 1`] = `
"Axiom 1.1.24.3 (Axiom of choice).  We define:

  AC â€Š:â‡” â€Šâˆ€â€†sets Sâ€‰: S has a choice function

Remarks.

This is the simplest formulation of the axiom of choice that can be formalized in HLM. The standard formulation is not directly applicable because an indexed family of arbitrary sets cannot be defined as an object â€“ there is no suitable equality definition.

It is possible to state, as a theorem, that AC implies that the [Cartesian product](../Generalized%20cartesian%20product) of any family of nonempty sets is nonempty. However, whether this is provable in HLM remains to be investigated. The equivalence with Zorn's lemma and the well-ordering theorem is likely to hold.

HLM actually does not have â€œaxiomsâ€ as a concept; an axiom is simply a predicate. Thus, at the moment, every theorem (or definition) that requires the axiom of choice (or a weaker form) must be prefixed accordingly:
* The simplest solution is to add â€œassume ACâ€ as a condition. However, this condition will likely propagate to all dependent results, even if the axiom of choice is not needed in particular cases.
* A preferred method is to replace this with â€œassume _S_ has a choice functionâ€ for a suitable _S_.
* Better yet, build the result explicitly from a given choice function.

Hopefully this will not be too inconvenient. It does have a few advantages:
* In particular cases where the axiom of choice is not needed, this fact becomes clear immediately.
* It is possible to state and prove relationships between the axiom of choice and other statements. (Again, it is preferable to state these equivalences as theorems about particular sets.)

As a last resort, HLM could be extended in two different ways:
* A choice operator could be included in the logic. (This would likely imply global choice, though.)
* The user interface could provide a mode that hides all references to the axiom of choice, and manages them automatically based on dependencies.

References.

* https://en.wikipedia.org/wiki/Axiom_of_choice
* http://mathworld.wolfram.com/AxiomofChoice.html
* https://proofwiki.org/wiki/Axiom:Axiom_of_Choice"
`;

exports[`render hlm library: 1.2.1 data/libraries/hlm/Essentials/Properties/Properties 1`] = `
"Definition 1.2.1.  Let S be a set. We define:

  ð“Ÿð“»ð“¹(S)â€…:=:â€…{[p_s]_(sâ€Šâˆˆâ€ŠS) | p_s is a proposition for each sâ€‰âˆˆâ€‰S}

  [p_s]_(sâ€Šâˆˆâ€ŠS)â€…=â€…[q_s]_(sâ€Šâˆˆâ€ŠS) â€Š:â‡” â€Šâˆ€â€†sâ€‰âˆˆâ€‰Sâ€‰: [p_s â€Šâ‡” â€Šq_s]  (p_s is a proposition for each sâ€‰âˆˆâ€‰S, q_s is a proposition for each sâ€‰âˆˆâ€‰S)

For S'â€‰âŠ†â€‰S, we canonically treat elements of ð“Ÿð“»ð“¹(S') as elements of ð“Ÿð“»ð“¹(S).

We write â€œlet p be a property on Sâ€ for â€œlet pâ€‰âˆˆâ€‰ð“Ÿð“»ð“¹(S).â€

Remarks.

This definition encodes a property (aka unary relation) on _S_ as a proposition depending on an element of _S_ (up to equivalence). Since it is equally possible to encode a unary relation on _S_ as a subset of _S_, this definition is interchangeable with the definition of the [power set](../Sets/Power%20set). The given definition is just more convenient.

References.

* https://en.wikipedia.org/wiki/Property_(mathematics)
* https://proofwiki.org/wiki/Definition:Propositional_Function"
`;

exports[`render hlm library: 1.2.2 data/libraries/hlm/Essentials/Properties/has%20property 1`] = `
"Definition 1.2.2.  Let S be a set, p be a property on S, sâ€‰âˆˆâ€‰S. We define

  s is p

by:

  s is [p_t]_(tâ€Šâˆˆâ€ŠS) â€Š:â‡” â€Šp_s  (p_t is a proposition for each tâ€‰âˆˆâ€‰S)

Remarks.

â€œ_s_ is _p_â€ is shorthand for â€œ_s_ has property _p_.â€"
`;

exports[`render hlm library: 1.2.3 data/libraries/hlm/Essentials/Properties/predicate 1`] = `
"Definition 1.2.3 (Predicate as property).

Remarks.

This is a macro to convert a predicate taking an element of _S_ to a property on _S_."
`;

exports[`render hlm library: 1.3.1 data/libraries/hlm/Essentials/Relations/Relations 1`] = `
"Definition 1.3.1.  Let S,â€ŠT be sets. We define:

  ð“¡ð“®ð“µ(S,â€ŠT)â€…:=:â€…{[p_s,t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠT | p_s,t is a proposition for each sâ€‰âˆˆâ€‰S and tâ€‰âˆˆâ€‰T}

  [p_s,t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠTâ€…=â€…[q_s,t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠT â€Š:â‡” â€Šâˆ€â€†sâ€‰âˆˆâ€‰S, tâ€‰âˆˆâ€‰Tâ€‰: [p_s,t â€Šâ‡” â€Šq_s,t]  (p_s,t is a proposition for each sâ€‰âˆˆâ€‰S and tâ€‰âˆˆâ€‰T, q_s,t is a proposition for each sâ€‰âˆˆâ€‰S and tâ€‰âˆˆâ€‰T)

For S'â€‰âŠ†â€‰S and T'â€‰âŠ†â€‰T, we canonically treat elements of ð“¡ð“®ð“µ(S',â€ŠT') as elements of ð“¡ð“®ð“µ(S,â€ŠT).

We write â€œlet â‰º be a relation from S to Tâ€ for â€œlet â‰ºâ€‰âˆˆâ€‰ð“¡ð“®ð“µ(S,â€ŠT).â€

Remarks.

This definition encodes a relation from _S_ to _T_ as a proposition depending on an element of _S_ and an element of _T_ (up to equivalence). It would be equally possible to encode relations as subsets of the Cartesian product; the given definition is just more convenient.

References.

* https://en.wikipedia.org/wiki/Binary_relation
* http://mathworld.wolfram.com/Relation.html
* https://proofwiki.org/wiki/Definition:Relation
* https://ncatlab.org/nlab/show/relation#binary_relations"
`;

exports[`render hlm library: 1.3.2 data/libraries/hlm/Essentials/Relations/related 1`] = `
"Definition 1.3.2.  Let S,â€ŠT be sets, â‰º be a relation from S to T, sâ€‰âˆˆâ€‰S, tâ€‰âˆˆâ€‰T. We define

  sâ€…â‰ºâ€…t

by:

  sâ€…[p_u,v]_uâ€Šâˆˆâ€ŠS,vâ€Šâˆˆâ€ŠTâ€…t â€Š:â‡” â€Šp_s,t  (p_u,v is a proposition for each uâ€‰âˆˆâ€‰S and vâ€‰âˆˆâ€‰T)"
`;

exports[`render hlm library: 1.3.3 data/libraries/hlm/Essentials/Relations/predicate 1`] = `
"Definition 1.3.3 (Predicate as relation).

Remarks.

This is a macro to convert a predicate taking elements of _S_ and _T_ to a relation from _S_ to _T_."
`;

exports[`render hlm library: 1.3.4 data/libraries/hlm/Essentials/Relations/converse 1`] = `
"Definition 1.3.4.  Let S,â€ŠT be sets, â‰º be a relation from S to T. We define:

  â‰º^Tâ€…:=â€…[sâ€…â‰ºâ€…t]_tâ€Šâˆˆâ€ŠT,sâ€Šâˆˆâ€ŠS

References.

* https://en.wikipedia.org/wiki/Converse_relation
* https://proofwiki.org/wiki/Definition:Inverse_Relation"
`;

exports[`render hlm library: 1.3.5 data/libraries/hlm/Essentials/Relations/implies 1`] = `
"Definition 1.3.5.  Let S,â€ŠT be sets, â‰º,â€ŠâŠ‚ be relations from S to T. We define:

  (â‰º â‡’ âŠ‚) â€Š:â‡” â€Šâˆ€â€†sâ€‰âˆˆâ€‰S, tâ€‰âˆˆâ€‰T s.t. sâ€…â‰ºâ€…tâ€‰: sâ€…âŠ‚â€…t

Remarks.

This definition is equivalent to the first relation being a subset of the second if relations are encoded as subsets."
`;

exports[`render hlm library: 1.3.6 data/libraries/hlm/Essentials/Relations/conjunction 1`] = `
"Definition 1.3.6.  Let S,â€ŠT be sets, â‰º,â€ŠâŠ‚ be relations from S to T. We define:

  â‰º âˆ§ âŠ‚â€…:=â€…[sâ€…â‰ºâ€…t and sâ€…âŠ‚â€…t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠT

Remarks.

This definition is equivalent to the [intersection](../Sets/Intersection) of two relations if relations are encoded as subsets."
`;

exports[`render hlm library: 1.3.7 data/libraries/hlm/Essentials/Relations/disjunction 1`] = `
"Definition 1.3.7.  Let S,â€ŠT be sets, â‰º,â€ŠâŠ‚ be relations from S to T. We define:

  â‰º âˆ¨ âŠ‚â€…:=â€…[sâ€…â‰ºâ€…t or sâ€…âŠ‚â€…t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠT

Remarks.

This definition is equivalent to the [union](../Sets/Union) of two relations if relations are encoded as subsets."
`;

exports[`render hlm library: 1.3.8 data/libraries/hlm/Essentials/Relations/generalized%20conjunction 1`] = `
"Definition 1.3.8.  Let S,â€ŠT be sets, Râ€‰âŠ†â€‰ð“¡ð“®ð“µ(S,â€ŠT). We define:

  â‹€Râ€…:=â€…[âˆ€â€†â‰ºâ€‰âˆˆâ€‰Râ€‰: sâ€…â‰ºâ€…t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠT

Remarks.

This definition is equivalent to the [generalized intersection](../Sets/Generalized%20intersection%20using%20power%20set) of relations if relations are encoded as subsets."
`;

exports[`render hlm library: 1.3.9 data/libraries/hlm/Essentials/Relations/generalized%20disjunction 1`] = `
"Definition 1.3.9.  Let S,â€ŠT be sets, Râ€‰âŠ†â€‰ð“¡ð“®ð“µ(S,â€ŠT). We define:

  â‹Râ€…:=â€…[âˆƒâ€†â‰ºâ€‰âˆˆâ€‰Râ€‰: sâ€…â‰ºâ€…t]_sâ€Šâˆˆâ€ŠS,tâ€Šâˆˆâ€ŠT

Remarks.

This definition is equivalent to the [generalized union](../Sets/Generalized%20union%20using%20power%20set) of relations if relations are encoded as subsets."
`;

exports[`render hlm library: 1.3.10 data/libraries/hlm/Essentials/Relations/mapping 1`] = `
"Definition 1.3.10.  Let S,â€ŠT be sets, â‰º be a relation from S to T. We define:

  â‰º is a mapping â€Š:â‡” â€Šâˆ€â€†sâ€‰âˆˆâ€‰Sâ€‰: âˆƒ!â€†tâ€‰âˆˆâ€‰Tâ€‰: sâ€…â‰ºâ€…t

Remarks.

In this library, â€œmappingâ€ and â€œ[function](../Functions/Functions)â€ are not synonymous but interchangeable, via a [definition](../Functions/mapping%20as%20function) that turns a mapping into a function. The difference is not fundamental but a matter of convenience.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)
* http://mathworld.wolfram.com/Function.html
* https://proofwiki.org/wiki/Definition:Mapping"
`;

exports[`render hlm library: 1.3.11 data/libraries/hlm/Essentials/Relations/mapping%20value 1`] = `
"Definition 1.3.11.  Let S,â€ŠT be sets, â‰º be a mapping from S to T, sâ€‰âˆˆâ€‰S. For tâ€‰âˆˆâ€‰T, we define:

  â‰º(s)â€…=â€…t â€Š:â‡” â€Šsâ€…â‰ºâ€…t

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)#Functional_notation"
`;

exports[`render hlm library: 1.3.12 data/libraries/hlm/Essentials/Relations/Endorelations 1`] = `
"Definition 1.3.12 (Endorelations).  Let S be a set. We define:

  ð“¡ð“®ð“µ(S)â€…:=:â€…{[p_s,t]_(s,tâ€Šâˆˆâ€ŠS) | p_s,t is a proposition for each s,â€Štâ€‰âˆˆâ€‰S}

  [p_s,t]_(s,tâ€Šâˆˆâ€ŠS)â€…=â€…[q_s,t]_(s,tâ€Šâˆˆâ€ŠS) â€Š:â‡” â€Šâˆ€â€†s,â€Štâ€‰âˆˆâ€‰Sâ€‰: [p_s,t â€Šâ‡” â€Šq_s,t]  (p_s,t is a proposition for each s,â€Štâ€‰âˆˆâ€‰S, q_s,t is a proposition for each s,â€Štâ€‰âˆˆâ€‰S)

ð“¡ð“®ð“µ(S,â€ŠS)â€…âŠ†:â€…ð“¡ð“®ð“µ(S) via
â‰ºâ€…=â€…[sâ€…â‰ºâ€…t]_(s,tâ€Šâˆˆâ€ŠS)

Well-definedness.  No proof.

For S'â€‰âŠ†â€‰S, we canonically treat elements of ð“¡ð“®ð“µ(S') as elements of ð“¡ð“®ð“µ(S).

We write â€œlet â‰º be a relation on Sâ€ for â€œlet â‰ºâ€‰âˆˆâ€‰ð“¡ð“®ð“µ(S).â€

Remarks.

Since endorelations are used often, we encode them as a separate construction with an appropriate embedding, mainly to improve rendering.

References.

* https://en.wikipedia.org/wiki/Binary_relation#Relations_over_a_set
* http://mathworld.wolfram.com/Relation.html
* https://proofwiki.org/wiki/Definition:Endorelation"
`;

exports[`render hlm library: 1.3.13 data/libraries/hlm/Essentials/Relations/restriction 1`] = `
"Definition 1.3.13.  Let S be a set, â‰º be a relation on S, Tâ€‰âŠ†â€‰S. We define:

  â‰ºâˆ£_Tâ€…:=â€…[tâ€…â‰ºâ€…u]_(t,uâ€Šâˆˆâ€ŠT)

Remarks.

This definition is not exactly standard but very simple. The main reason to include it is that the result is defined to be a relation on _T_ instead of _S_, which is sometimes needed."
`;

exports[`render hlm library: 1.3.14 data/libraries/hlm/Essentials/Relations/equality 1`] = `
"Definition 1.3.14.  Let S be a set. We define:

  =_Sâ€…:=â€…[sâ€…=â€…t]_(s,tâ€Šâˆˆâ€ŠS)

References.

* https://en.wikipedia.org/wiki/Binary_relation#Particular_binary_relations: identity relation
* https://proofwiki.org/wiki/Definition:Diagonal_Relation"
`;

exports[`render hlm library: 1.3.15 data/libraries/hlm/Essentials/Relations/reflexive 1`] = `
"Definition 1.3.15.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is reflexive â€Š:â‡” â€Šâˆ€â€†sâ€‰âˆˆâ€‰Sâ€‰: sâ€…â‰ºâ€…s

References.

* https://en.wikipedia.org/wiki/Reflexive_relation
* http://mathworld.wolfram.com/Reflexive.html
* https://proofwiki.org/wiki/Definition:Reflexive_Relation
* https://ncatlab.org/nlab/show/reflexive+relation"
`;

exports[`render hlm library: 1.3.16 data/libraries/hlm/Essentials/Relations/connex 1`] = `
"Definition 1.3.16.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is connex â€Š:â‡” â€Šâˆ€â€†s,â€Štâ€‰âˆˆâ€‰Sâ€‰: [sâ€…â‰ºâ€…t or tâ€…â‰ºâ€…s]

References.

* https://en.wikipedia.org/wiki/Connex_relation"
`;

exports[`render hlm library: 1.3.17 data/libraries/hlm/Essentials/Relations/symmetric 1`] = `
"Definition 1.3.17.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is symmetric â€Š:â‡” â€Šâˆ€â€†s,â€Štâ€‰âˆˆâ€‰S s.t. sâ€…â‰ºâ€…tâ€‰: tâ€…â‰ºâ€…s
   â€Šâ‡” â€Šâ‰ºâ€…=â€…â‰º^T

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Symmetric_relation
* http://mathworld.wolfram.com/SymmetricRelation.html
* https://proofwiki.org/wiki/Definition:Symmetric_Relation
* https://ncatlab.org/nlab/show/symmetric+relation"
`;

exports[`render hlm library: 1.3.18 data/libraries/hlm/Essentials/Relations/antisymmetric 1`] = `
"Definition 1.3.18.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is antisymmetric â€Š:â‡” â€Šâˆ€â€†s,â€Štâ€‰âˆˆâ€‰S s.t. sâ€…â‰ºâ€…t and tâ€…â‰ºâ€…sâ€‰: sâ€…=â€…t

References.

* https://en.wikipedia.org/wiki/Antisymmetric_relation
* http://mathworld.wolfram.com/AntisymmetricRelation.html
* https://proofwiki.org/wiki/Definition:Antisymmetric_Relation"
`;

exports[`render hlm library: 1.3.19 data/libraries/hlm/Essentials/Relations/transitive 1`] = `
"Definition 1.3.19.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is transitive â€Š:â‡” â€Šâˆ€â€†s,â€Št,â€Šuâ€‰âˆˆâ€‰S s.t. sâ€…â‰ºâ€…t and tâ€…â‰ºâ€…uâ€‰: sâ€…â‰ºâ€…u

References.

* https://en.wikipedia.org/wiki/Transitive_relation
* https://proofwiki.org/wiki/Definition:Transitive_Relation
* https://ncatlab.org/nlab/show/transitive+relation"
`;

exports[`render hlm library: 1.3.20 data/libraries/hlm/Essentials/Relations/preorder 1`] = `
"Definition 1.3.20.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is a preorder â€Š:â‡” â€Šâ‰º is reflexive and â‰º is transitive

References.

* https://en.wikipedia.org/wiki/Preorder
* http://mathworld.wolfram.com/Preorder.html
* https://proofwiki.org/wiki/Definition:Preordering
* https://ncatlab.org/nlab/show/preorder"
`;

exports[`render hlm library: 1.3.21 data/libraries/hlm/Essentials/Relations/partial%20order 1`] = `
"Definition 1.3.21.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is a partial order â€Š:â‡” â€Šâ‰º is reflexive and â‰º is antisymmetric and â‰º is transitive
   â€Šâ‡” â€Šâ‰º is a preorder and â‰º is antisymmetric

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition"
`;

exports[`render hlm library: 1.3.22 data/libraries/hlm/Essentials/Relations/total%20order 1`] = `
"Definition 1.3.22.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is a total order â€Š:â‡” â€Šâ‰º is connex and â‰º is antisymmetric and â‰º is transitive
   â€Šâ‡” â€Šâ‰º is a partial order and â‰º is connex

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Total_order"
`;

exports[`render hlm library: 1.3.23 data/libraries/hlm/Essentials/Relations/lower%20bound 1`] = `
"Definition 1.3.23.  Let S be a set, â‰º be a relation on S, Tâ€‰âŠ†â€‰S, sâ€‰âˆˆâ€‰S. We define:

  s is a â‰º-lower bound of T â€Š:â‡” â€Šâˆ€â€†tâ€‰âˆˆâ€‰Tâ€‰: sâ€…â‰ºâ€…t"
`;

exports[`render hlm library: 1.3.24 data/libraries/hlm/Essentials/Relations/upper%20bound 1`] = `
"Definition 1.3.24.  Let S be a set, â‰º be a relation on S, Tâ€‰âŠ†â€‰S, sâ€‰âˆˆâ€‰S. We define:

  s is a â‰º-upper bound of T â€Š:â‡” â€Šâˆ€â€†tâ€‰âˆˆâ€‰Tâ€‰: tâ€…â‰ºâ€…s
   â€Šâ‡” â€Šs is a â‰º^T-lower bound of T

Equivalence.  No proof."
`;

exports[`render hlm library: 1.3.25 data/libraries/hlm/Essentials/Relations/least%20element 1`] = `
"Definition 1.3.25.  Let S be a set, â‰º be a relation on S, Tâ€‰âŠ†â€‰S, tâ€‰âˆˆâ€‰T. We define:

  t is a â‰º-least element of T â€Š:â‡” â€Št is a â‰º-lower bound of T

References.

* https://en.wikipedia.org/wiki/Greatest_and_least_elements"
`;

exports[`render hlm library: 1.3.26 data/libraries/hlm/Essentials/Relations/greatest%20element 1`] = `
"Definition 1.3.26.  Let S be a set, â‰º be a relation on S, Tâ€‰âŠ†â€‰S, tâ€‰âˆˆâ€‰T. We define:

  t is a â‰º-greatest element of T â€Š:â‡” â€Št is a â‰º-upper bound of T
   â€Šâ‡” â€Št is a â‰º^T-least element of T

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Greatest_and_least_elements"
`;

exports[`render hlm library: 1.3.27 data/libraries/hlm/Essentials/Relations/well-order 1`] = `
"Definition 1.3.27.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is a well-order â€Š:â‡” â€Šâ‰º is a total order and âˆ€â€†Tâ€‰âŠ†â€‰S s.t. T is nonemptyâ€‰: âˆƒâ€†tâ€‰âˆˆâ€‰Tâ€‰: t is a â‰º-least element of T

References.

* https://en.wikipedia.org/wiki/Well-order"
`;

exports[`render hlm library: 1.3.28 data/libraries/hlm/Essentials/Relations/equivalence 1`] = `
"Definition 1.3.28.  Let S be a set, â‰º be a relation on S. We define:

  â‰º is an equivalence relation â€Š:â‡” â€Šâ‰º is a preorder and â‰º is symmetric

References.

* https://en.wikipedia.org/wiki/Equivalence_relation
* http://mathworld.wolfram.com/EquivalenceRelation.html
* https://proofwiki.org/wiki/Definition:Equivalence_Relation
* https://ncatlab.org/nlab/show/equivalence+relation"
`;

exports[`render hlm library: 1.3.29 data/libraries/hlm/Essentials/Relations/Equivalence%20classes 1`] = `
"Definition 1.3.29 (Equivalence classes).  Let S be a set, âˆ¼ be an equivalence relation on S. We define:

  Sâˆ•âˆ¼â€…:=:â€…{[s]_âˆ¼ | sâ€‰âˆˆâ€‰S}

  [s]_âˆ¼â€…=â€…[t]_âˆ¼ â€Š:â‡” â€Šsâ€…âˆ¼â€…t  (s,â€Štâ€‰âˆˆâ€‰S)

  Reflexivity.  No proof.

  Symmetry.  No proof.

  Transitivity.  No proof.

Remarks.

This definition uses the â€œconstructionâ€ concept to define quotient sets and equivalence classes, which is straightforward because the requirements for an equality definition are precisely the properties of an equivalence relation.

A more traditional definition where equivalence classes are subsets of _S_ is possible as well, of course. Then the set of equivalence classes is a subset of the power set. However, the given definition has the advantage that well-definedness proofs can be stated more easily. On the other hand, there is the drawback that since equivalence classes are not sets, it is not directly possible to ask about their cardinality, etc. Moreover, there should be a general definition of a partition, and a theorem that equivalence classes form a partition; this requires the powerset approach.

In the end, there may need to be two different but interchangeable definitions of equivalence classes.

References.

* https://en.wikipedia.org/wiki/Equivalence_class
* http://mathworld.wolfram.com/EquivalenceClass.html
* https://proofwiki.org/wiki/Definition:Equivalence_Class
* https://ncatlab.org/nlab/show/equivalence+class"
`;

exports[`render hlm library: 1.3.30 data/libraries/hlm/Essentials/Relations/succession 1`] = `
"Definition 1.3.30 (Succession).  Let S,â€ŠT be sets, âª¯ be a partial order on S, âŠ‘ be a partial order on T. We define:

  âª¯â€‰â‰ªâ€‰âŠ‘â€…:=â€…[{{s_aâ€…âª¯â€…s_b if aâ€…=â€…l(s_a) (s_aâ€‰âˆˆâ€‰S), false if aâ€…=â€…r(t_a) (t_aâ€‰âˆˆâ€‰T) if bâ€…=â€…l(s_b) (s_bâ€‰âˆˆâ€‰S), {true if aâ€…=â€…l(s_a) (s_aâ€‰âˆˆâ€‰S), t_aâ€…âŠ‘â€…t_b if aâ€…=â€…r(t_a) (t_aâ€‰âˆˆâ€‰T) if bâ€…=â€…r(t_b) (t_bâ€‰âˆˆâ€‰T)]_(a,bâ€Šâˆˆâ€ŠSâ€ŠâŠŽâ€ŠT)

Remarks.

This definition constructs a partial order on the disjoint union of two sets _S_ and _T_ from partial orders on _S_ and _T_. Elements of _S_ are always considered smaller than elements of _T_. This is used to define [addition of ordinal numbers](../Numbers/Ordinal/sum)."
`;

exports[`render hlm library: 1.3.31 data/libraries/hlm/Essentials/Relations/lexicographical%20order 1`] = `
"Definition 1.3.31 (Lexicographical order).  Let S,â€ŠT be sets, âª¯ be a partial order on S, âŠ‘ be a partial order on T. We define:

  âª¯â€‰âˆ â€‰âŠ‘â€…:=â€…[sâ€…âª¯â€…s' and [sâ€…â‰ â€…s' or tâ€…âŠ‘â€…t']]_((s,t),(s',t')â€Šâˆˆâ€ŠSÃ—T)

Remarks.

This definition constructs a partial order on the Cartesian product of two sets _S_ and _T_ from partial orders on _S_ and _T_, combining the two partial orders lexicographically. It is used to define [multiplication of ordinal numbers](../Numbers/Ordinal/product)."
`;

exports[`render hlm library: 1.3.32.1 data/libraries/hlm/Essentials/Relations/Closures/closure 1`] = `
"Definition 1.3.32.1.  Let S be a set, â‰º be a relation on S, p be a property on ð“¡ð“®ð“µ(S). We define:

  cl_p(â‰º)â€…:=â€…â‹€{âŠ‚â€‰âˆˆâ€‰ð“¡ð“®ð“µ(S)â€‰: [â‰º â‡’ âŠ‚] and âŠ‚ is p}

Remarks.

This is an attempt at a general definition of the closure of a relation with respect to a property, i.e. the smallest relation that contains the original relation and satisfies the property. Note that it only works for properties that are closed under generalized conjunctions aka intersections, which should probably be included as a requirement.

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures"
`;

exports[`render hlm library: 1.3.32.2 data/libraries/hlm/Essentials/Relations/Closures/reflexive%20closure 1`] = `
"Definition 1.3.32.2.  Let S be a set, â‰º be a relation on S. We define:

  â‰º^=â€…:=â€…cl_reflexive(â‰º)
  â€…=â€…â‰º âˆ¨ =_S

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Reflexive_closure
* http://mathworld.wolfram.com/ReflexiveClosure.html
* https://proofwiki.org/wiki/Definition:Reflexive_Closure"
`;

exports[`render hlm library: 1.3.32.3 data/libraries/hlm/Essentials/Relations/Closures/symmetric%20closure 1`] = `
"Definition 1.3.32.3.  Let S be a set, â‰º be a relation on S. We define:

  â‰º^â†”â€…:=â€…cl_symmetric(â‰º)
  â€…=â€…â‰º âˆ¨ â‰º^T

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Symmetric_closure
* https://proofwiki.org/wiki/Definition:Symmetric_Closure"
`;

exports[`render hlm library: 1.3.32.4 data/libraries/hlm/Essentials/Relations/Closures/reflexive%20symmetric%20closure 1`] = `
"Definition 1.3.32.4.  Let S be a set, â‰º be a relation on S. We define:

  â‰º^â‡”â€…:=â€…cl_([âŠ‚ is reflexive and âŠ‚ is symmetric]_(âŠ‚âˆˆð“¡ð“®ð“µ(S)))(â‰º)
  â€…=â€…(â‰º^=)^â†”
  â€…=â€…(â‰º^â†”)^=

Equality.  No proof."
`;

exports[`render hlm library: 1.3.32.5 data/libraries/hlm/Essentials/Relations/Closures/transitive%20closure 1`] = `
"Definition 1.3.32.5.  Let S be a set, â‰º be a relation on S. We define:

  â‰º^+â€…:=â€…cl_transitive(â‰º)

References.

* https://en.wikipedia.org/wiki/Transitive_closure
* http://mathworld.wolfram.com/TransitiveClosure.html
* https://proofwiki.org/wiki/Definition:Transitive_Closure_(Relation_Theory)"
`;

exports[`render hlm library: 1.3.32.6 data/libraries/hlm/Essentials/Relations/Closures/reflexive%20transitive%20closure 1`] = `
"Definition 1.3.32.6.  Let S be a set, â‰º be a relation on S. We define:

  â‰º^âˆ—â€…:=â€…cl_preorder(â‰º)
  â€…=â€…(â‰º^+)^=
  â€…=â€…(â‰º^=)^+

Equality.  No proof.

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures: reflexive transitive closure
* https://proofwiki.org/wiki/Definition:Reflexive_Transitive_Closure"
`;

exports[`render hlm library: 1.3.32.7 data/libraries/hlm/Essentials/Relations/Closures/reflexive%20symmetric%20transitive%20closure 1`] = `
"Definition 1.3.32.7.  Let S be a set, â‰º be a relation on S. We define:

  â‰º^â‰¡â€…:=â€…cl_equivalence relation(â‰º)

References.

* https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures: reflexive transitive symmetric closure"
`;

exports[`render hlm library: 1.4.1 data/libraries/hlm/Essentials/Functions/Functions 1`] = `
"Definition 1.4.1.  Let X,â€ŠY be sets. We define:

  (Xâ€‰â†’â€‰Y)â€…:=:â€…{(Xâ€‰â†’â€‰Y, xâ€‰â†¦â€‰y_x) | y_xâ€‰âˆˆâ€‰Y for each xâ€‰âˆˆâ€‰X}

  (Xâ€‰â†’â€‰Y, xâ€‰â†¦â€‰y_x)â€…=â€…(Xâ€‰â†’â€‰Y, xâ€‰â†¦â€‰y'_x) â€Š:â‡” â€Šâˆ€â€†xâ€‰âˆˆâ€‰Xâ€‰: y_xâ€…=â€…y'_x  (y_xâ€‰âˆˆâ€‰Y for each xâ€‰âˆˆâ€‰X, y'_xâ€‰âˆˆâ€‰Y for each xâ€‰âˆˆâ€‰X)

We write â€œlet fâ€‰:â€‰Xâ€‰â†’â€‰Y be a functionâ€ for â€œlet fâ€‰âˆˆâ€‰(Xâ€‰â†’â€‰Y).â€

We write â€œlet fâ€‰:â€‰â€ŠXâ€‰â†’â€‰Y, xâ€‰â†¦â€‰y_xâ€ for â€œlet fâ€‰:=â€‰(Xâ€‰â†’â€‰Y, xâ€‰â†¦â€‰y_x).â€

Remarks.

This definition uses a feature of the HLM logic called â€œbindings.â€ It is [equivalent](mapping%20as%function) to the usual set-theoretic definition, which is called â€œ[mapping](../Relations/mapping)â€ in this library to distinguish the two definitions.

The major advantage of the definition using bindings is that given an explicitly defined function, determining the value at a specific input is simply a matter of resolving definitions.

Function [extensionality](https://en.wikipedia.org/wiki/Extensionality) is a consequence of the requirement to specify an equality definition for the constructor.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)
* http://mathworld.wolfram.com/Function.html
* https://proofwiki.org/wiki/Definition:Mapping
* https://ncatlab.org/nlab/show/function"
`;

exports[`render hlm library: 1.4.2 data/libraries/hlm/Essentials/Functions/value 1`] = `
"Definition 1.4.2.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function, xâ€‰âˆˆâ€‰X. We define

  f(x)

by:

  (Xâ€‰â†’â€‰Y, zâ€‰â†¦â€‰y_z)(x)â€…:=â€…y_x  (y_zâ€‰âˆˆâ€‰Y for each zâ€‰âˆˆâ€‰X)

Remarks.

This definition works due to the special way that functions are defined. The [corresponding definition](../Relations/mapping%20value) for mappings is an implicit definition.

References.

* https://en.wikipedia.org/wiki/Function_(mathematics)#Functional_notation"
`;

exports[`render hlm library: 1.4.3 data/libraries/hlm/Essentials/Functions/operator 1`] = `
"Definition 1.4.3 (Operator as function).

Remarks.

This is a macro to convert an operator taking an element of _X_ and returning an element of _Y_ to a function from _X_ to _Y_."
`;

exports[`render hlm library: 1.4.4 data/libraries/hlm/Essentials/Functions/Image 1`] = `
"Definition 1.4.4.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function, Sâ€‰âŠ†â€‰X. We define:

  f(S)â€…:=â€…{f(x)â€‰: xâ€‰âˆˆâ€‰S}

References.

* https://en.wikipedia.org/wiki/Image_(mathematics)
* https://proofwiki.org/wiki/Definition:Image_(Set_Theory)/Mapping/Subset"
`;

exports[`render hlm library: 1.4.5 data/libraries/hlm/Essentials/Functions/Preimage 1`] = `
"Definition 1.4.5.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function, Sâ€‰âŠ†â€‰Y. We define:

  f^-1(S)â€…:=â€…{xâ€‰âˆˆâ€‰Xâ€‰: f(x)â€…âˆˆâ€…S}

References.

* https://en.wikipedia.org/wiki/Preimage"
`;

exports[`render hlm library: 1.4.6 data/libraries/hlm/Essentials/Functions/mapping%20as%20function 1`] = `
"Definition 1.4.6.  Let S,â€ŠT be sets, â‰º be a mapping from S to T. We define:

  (â‰º)â€‰:â€‰â€ŠSâ€‰â†’â€‰T, sâ€‰â†¦â€‰â‰º(s)

Remarks.

This definition shows that mappings and functions, as defined in this library, are interchangeable. (The other direction is straightforward as well.)"
`;

exports[`render hlm library: 1.4.7 data/libraries/hlm/Essentials/Functions/identity 1`] = `
"Definition 1.4.7.  Let X be a set. We define:

  id_Xâ€‰:â€‰â€ŠXâ€‰â†’â€‰X, xâ€‰â†¦â€‰x

References.

* https://en.wikipedia.org/wiki/Identity_function
* https://proofwiki.org/wiki/Definition:Identity_Mapping"
`;

exports[`render hlm library: 1.4.8 data/libraries/hlm/Essentials/Functions/generalized%20restriction 1`] = `
"Definition 1.4.8.  Let X be a set, Aâ€‰âŠ†â€‰X, B be a set, Yâ€‰âŠ†â€‰B, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function. We define:

  fâˆ£_A^Bâ€‰:â€‰â€ŠAâ€‰â†’â€‰B, xâ€‰â†¦â€‰f(x)

Remarks.

This definition slightly extends the notion of [function restriction](restriction) in that it simultaneously extends the codomain to a superset _B_ of _Y_.

It might seem tempting to remove the need for this definition by implicitly treating a function to _Y_ as a function to a superset _B_ of _Y_, without explicitly specifying _B_. However, this might lead to confusion as the resulting function may not be surjective even though the original function is."
`;

exports[`render hlm library: 1.4.9 data/libraries/hlm/Essentials/Functions/codomain%20restriction 1`] = `
"Definition 1.4.9.  Let X be a set, Aâ€‰âŠ†â€‰X, Y be a set, Bâ€‰âŠ†â€‰Y, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function such that f(A)â€…âŠ†â€…B. We define:

  fâˆ£_A^Bâ€‰:â€‰â€ŠAâ€‰â†’â€‰B, xâ€‰â†¦â€‰f(x)

Remarks.

This definition slightly extends the notion of [function restriction](restriction) in that it simultaneously restricts the codomain to a subset _B_ of _Y_, under the condition that the range is contained in this subset. It is compatible with the previous definition."
`;

exports[`render hlm library: 1.4.10 data/libraries/hlm/Essentials/Functions/restriction 1`] = `
"Definition 1.4.10.  Let X be a set, Aâ€‰âŠ†â€‰X, Y be a set, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function. We define:

  fâˆ£_Aâ€…:=â€…fâˆ£_A^Y

References.

* https://en.wikipedia.org/wiki/Restriction_(mathematics)"
`;

exports[`render hlm library: 1.4.11 data/libraries/hlm/Essentials/Functions/composition 1`] = `
"Definition 1.4.11.  Let X,â€ŠY,â€ŠZ be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y, gâ€‰:â€‰Yâ€‰â†’â€‰Z be functions. We define:

  gâ€‰âˆ˜â€‰fâ€‰:â€‰â€ŠXâ€‰â†’â€‰Z, xâ€‰â†¦â€‰g(f(x))

References.

* https://en.wikipedia.org/wiki/Function_composition
* http://mathworld.wolfram.com/Composition.html
* https://proofwiki.org/wiki/Definition:Composition_of_Mappings"
`;

exports[`render hlm library: 1.4.12 data/libraries/hlm/Essentials/Functions/Composition%20is%20associative 1`] = `
"Proposition 1.4.12.  Let W,â€ŠX,â€ŠY,â€ŠZ be sets, fâ€‰:â€‰Wâ€‰â†’â€‰X, gâ€‰:â€‰Xâ€‰â†’â€‰Y, hâ€‰:â€‰Yâ€‰â†’â€‰Z be functions. Then:

  (hâ€‰âˆ˜â€‰g)â€‰âˆ˜â€‰fâ€…=â€…hâ€‰âˆ˜â€‰(gâ€‰âˆ˜â€‰f)

No proof.

References.

* https://en.wikipedia.org/wiki/Function_composition#Properties
* http://mathworld.wolfram.com/Composition.html
* https://proofwiki.org/wiki/Composition_of_Mappings_is_Associative"
`;

exports[`render hlm library: 1.4.13 data/libraries/hlm/Essentials/Functions/cartesian%20product 1`] = `
"Definition 1.4.13.  Let V,â€ŠW,â€ŠX,â€ŠY be sets, fâ€‰:â€‰Vâ€‰â†’â€‰W, gâ€‰:â€‰Xâ€‰â†’â€‰Y be functions. We define:

  fâ€‰Ã—â€‰gâ€‰:â€‰â€ŠVâ€‰Ã—â€‰Xâ€‰â†’â€‰Wâ€‰Ã—â€‰Y, (v,â€Šx)â€‰â†¦â€‰(f(v),â€Šg(x))

Remarks.

This definition is not standard in mathematics but convenient in some cases."
`;

exports[`render hlm library: 1.4.14 data/libraries/hlm/Essentials/Functions/injective 1`] = `
"Definition 1.4.14.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function. We define:

  f is injective â€Š:â‡” â€Šâˆ€â€†a,â€Šbâ€‰âˆˆâ€‰X s.t. f(a)â€…=â€…f(b)â€‰: aâ€…=â€…b
   â€Šâ‡” â€Šâˆ€â€†câ€‰âˆˆâ€‰Y, d,â€Šeâ€‰âˆˆâ€‰f^-1({c})â€‰: dâ€…=â€…e
   â€Šâ‡” â€Šâˆ€â€†yâ€‰âˆˆâ€‰f(X)â€‰: âˆƒ!â€†xâ€‰âˆˆâ€‰Xâ€‰: f(x)â€…=â€…y
   â€Šâ‡” â€ŠX is empty or âˆƒâ€†gâ€‰:â€‰Yâ€‰â†’â€‰Xâ€‰: gâ€‰âˆ˜â€‰fâ€…=â€…id_X

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Injective_function
* http://mathworld.wolfram.com/Injection.html
* https://proofwiki.org/wiki/Definition:Injection"
`;

exports[`render hlm library: 1.4.15 data/libraries/hlm/Essentials/Functions/surjective 1`] = `
"Definition 1.4.15.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function. We define:

  f is surjective â€Š:â‡” â€Šâˆ€â€†yâ€‰âˆˆâ€‰Yâ€‰: âˆƒâ€†xâ€‰âˆˆâ€‰Xâ€‰: f(x)â€…=â€…y
   â€Šâ‡” â€ŠYâ€…âŠ†â€…f(X)
   â€Šâ‡” â€Šf(X)â€…=â€…Y

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Surjective_function
* http://mathworld.wolfram.com/Surjection.html
* https://proofwiki.org/wiki/Definition:Surjection"
`;

exports[`render hlm library: 1.4.16 data/libraries/hlm/Essentials/Functions/bijective 1`] = `
"Definition 1.4.16.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function. We define:

  f is bijective â€Š:â‡” â€Šf is injective and f is surjective
   â€Šâ‡” â€Šâˆ€â€†yâ€‰âˆˆâ€‰Yâ€‰: âˆƒ!â€†xâ€‰âˆˆâ€‰Xâ€‰: f(x)â€…=â€…y
   â€Šâ‡” â€Šâˆƒâ€†gâ€‰:â€‰Yâ€‰â†’â€‰Xâ€‰: [gâ€‰âˆ˜â€‰fâ€…=â€…id_X and fâ€‰âˆ˜â€‰gâ€…=â€…id_Y]
   â€Šâ‡” â€Šâˆƒ!â€†hâ€‰:â€‰Yâ€‰â†’â€‰Xâ€‰: [hâ€‰âˆ˜â€‰fâ€…=â€…id_X and fâ€‰âˆ˜â€‰hâ€…=â€…id_Y]

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Bijective_function
* http://mathworld.wolfram.com/Bijection.html
* https://proofwiki.org/wiki/Definition:Bijection
* https://proofwiki.org/wiki/Bijection_iff_Left_and_Right_Inverse"
`;

exports[`render hlm library: 1.4.17 data/libraries/hlm/Essentials/Functions/Generalized%20restriction%20preserves%20injectivity 1`] = `
"Proposition 1.4.17.  Let X be a set, Aâ€‰âŠ†â€‰X, B be a set, Yâ€‰âŠ†â€‰B, fâ€‰:â€‰Xâ€‰â†’â€‰Y be an injective function. Then:

  fâˆ£_A^B is injective

No proof."
`;

exports[`render hlm library: 1.4.18 data/libraries/hlm/Essentials/Functions/Restriction%20preserves%20injectivity 1`] = `
"Corollary 1.4.18.  Let X be a set, Aâ€‰âŠ†â€‰X, Y be a set, fâ€‰:â€‰Xâ€‰â†’â€‰Y be an injective function. Then:

  fâˆ£_A is injective

No proof."
`;

exports[`render hlm library: 1.4.19 data/libraries/hlm/Essentials/Functions/Generalized%20extension%20preserves%20surjectivity 1`] = `
"Proposition 1.4.19.  Let X be a set, Aâ€‰âŠ†â€‰X, B be a set, Yâ€‰âŠ†â€‰B, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function such that fâˆ£_A^B is surjective. Then:

  f is surjective

No proof."
`;

exports[`render hlm library: 1.4.20 data/libraries/hlm/Essentials/Functions/Extension%20preserves%20surjectivity 1`] = `
"Corollary 1.4.20.  Let X be a set, Aâ€‰âŠ†â€‰X, Y be a set, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function such that fâˆ£_A is surjective. Then:

  f is surjective

No proof."
`;

exports[`render hlm library: 1.4.21 data/libraries/hlm/Essentials/Functions/Surjectivity%20by%20codomain%20restriction 1`] = `
"Proposition 1.4.21.  Let X be a set, Aâ€‰âŠ†â€‰X, Y be a set, fâ€‰:â€‰Xâ€‰â†’â€‰Y be a function. Then:

  fâˆ£_A^(f(A)) is surjective

No proof."
`;

exports[`render hlm library: 1.4.22 data/libraries/hlm/Essentials/Functions/Bijections 1`] = `
"Definition 1.4.22.  Let X,â€ŠY be sets. We define:

  (Xâ€‰â†”â€‰Y)â€…:=â€…{fâ€‰:â€‰Xâ€‰â†’â€‰Yâ€‰: f is bijective}

We write â€œlet fâ€‰:â€‰Xâ€‰â†”â€‰Y be a bijectionâ€ for â€œlet fâ€‰âˆˆâ€‰(Xâ€‰â†”â€‰Y).â€

Remarks.

Bijections are important enough to warrant their own notation. A bidirectional arrow seems appropriate, even though it does not appear to be standard.

References.

* https://en.wikipedia.org/wiki/Bijective_function
* http://mathworld.wolfram.com/Bijection.html
* https://proofwiki.org/wiki/Definition:Bijection"
`;

exports[`render hlm library: 1.4.23 data/libraries/hlm/Essentials/Functions/inverse 1`] = `
"Definition 1.4.23.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†”â€‰Y be a bijection. For gâ€‰:â€‰Yâ€‰â†”â€‰X, we define:

  f^-1â€…=â€…g â€Š:â‡” â€Šgâ€‰âˆ˜â€‰fâ€…=â€…id_X
   â€Šâ‡” â€Šfâ€‰âˆ˜â€‰gâ€…=â€…id_Y

Equivalence.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Inverse_function
* http://mathworld.wolfram.com/InverseFunction.html
* https://proofwiki.org/wiki/Definition:Inverse_Mapping"
`;

exports[`render hlm library: 1.4.24 data/libraries/hlm/Essentials/Functions/Inverse%20of%20inverse%20yields%20original 1`] = `
"Proposition 1.4.24.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†”â€‰Y be a bijection. Then:

  (f^-1)^-1â€…=â€…f

No proof."
`;

exports[`render hlm library: 1.4.25 data/libraries/hlm/Essentials/Functions/Application%20of%20function%20and%20inverse%20is%20neutral 1`] = `
"Corollary 1.4.25.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†”â€‰Y be a bijection, xâ€‰âˆˆâ€‰X. Then:

  f^-1(f(x))â€…=â€…x

No proof."
`;

exports[`render hlm library: 1.4.26 data/libraries/hlm/Essentials/Functions/Application%20of%20function%20after%20inverse%20is%20neutral 1`] = `
"Corollary 1.4.26.  Let X,â€ŠY be sets, fâ€‰:â€‰Xâ€‰â†”â€‰Y be a bijection, yâ€‰âˆˆâ€‰Y. Then:

  f(f^-1(y))â€…=â€…y

No proof."
`;

exports[`render hlm library: 1.4.27.1 data/libraries/hlm/Essentials/Functions/Operations/Operations 1`] = `
"Definition 1.4.27.1.  Let X,â€ŠY,â€ŠZ be sets. We define:

  ð“žð“¹(X,â€ŠY,â€ŠZ)â€…:=â€…(Xâ€‰Ã—â€‰Yâ€‰â†’â€‰Z)

We write â€œlet âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Yâ€‰â†’â€‰Z be an operationâ€ for â€œlet âˆ—â€‰âˆˆâ€‰ð“žð“¹(X,â€ŠY,â€ŠZ).â€

References.

* https://proofwiki.org/wiki/Definition:Operation/Binary_Operation"
`;

exports[`render hlm library: 1.4.27.2 data/libraries/hlm/Essentials/Functions/Operations/value 1`] = `
"Definition 1.4.27.2.  Let X,â€ŠY,â€ŠZ be sets, âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Yâ€‰â†’â€‰Z be an operation, xâ€‰âˆˆâ€‰X, yâ€‰âˆˆâ€‰Y. We define:

  xâ€‰âˆ—â€‰yâ€…:=â€…âˆ—(x,â€Šy)"
`;

exports[`render hlm library: 1.4.27.3 data/libraries/hlm/Essentials/Functions/Operations/operator 1`] = `
"Definition 1.4.27.3 (Operator as operation).

Remarks.

This is a macro to convert an operator taking elements of _X_ and _Y_ and returning an element of _Z_ to an operation from _X_ and _Y_ to _Z_."
`;

exports[`render hlm library: 1.4.27.4 data/libraries/hlm/Essentials/Functions/Operations/Inner%20operations 1`] = `
"Definition 1.4.27.4 (Inner operations).  Let X be a set. We define:

  ð“žð“¹(X)â€…:=â€…ð“žð“¹(X,â€ŠX,â€ŠX)

We write â€œlet âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Xâ€‰â†’â€‰X be an operation on Xâ€ for â€œlet âˆ—â€‰âˆˆâ€‰ð“žð“¹(X).â€

References.

* https://en.wikipedia.org/wiki/Binary_operation
* http://mathworld.wolfram.com/BinaryOperation.html
* https://proofwiki.org/wiki/Definition:Operation/Binary_Operation"
`;

exports[`render hlm library: 1.4.27.5 data/libraries/hlm/Essentials/Functions/Operations/associative 1`] = `
"Definition 1.4.27.5.  Let X be a set, âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Xâ€‰â†’â€‰X be an operation on X. We define:

  âˆ— is associative â€Š:â‡” â€Šâˆ€â€†x,â€Šy,â€Šzâ€‰âˆˆâ€‰Xâ€‰: (xâ€‰âˆ—â€‰y)â€‰âˆ—â€‰zâ€…=â€…xâ€‰âˆ—â€‰(yâ€‰âˆ—â€‰z)"
`;

exports[`render hlm library: 1.4.27.6 data/libraries/hlm/Essentials/Functions/Operations/commutative 1`] = `
"Definition 1.4.27.6.  Let X,â€ŠZ be sets, âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Xâ€‰â†’â€‰Z be an operation. We define:

  âˆ— is commutative â€Š:â‡” â€Šâˆ€â€†x,â€Šyâ€‰âˆˆâ€‰Xâ€‰: xâ€‰âˆ—â€‰yâ€…=â€…yâ€‰âˆ—â€‰x"
`;

exports[`render hlm library: 1.4.27.7 data/libraries/hlm/Essentials/Functions/Operations/inner%20operation%20restriction 1`] = `
"Definition 1.4.27.7.  Let X be a set, Aâ€‰âŠ†â€‰X, âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Xâ€‰â†’â€‰X be an operation on X such that âˆ€â€†x,â€Šyâ€‰âˆˆâ€‰Aâ€‰: xâ€‰âˆ—â€‰yâ€…âˆˆâ€…A. We define:

  âˆ—âˆ£_Aâ€…:=â€…âˆ—âˆ£_(AÃ—A)^A"
`;

exports[`render hlm library: 1.5.1 data/libraries/hlm/Essentials/Sequences/Finite%20sequences 1`] = `
"Definition 1.5.1.  Let S be a set. We define:

  S^âˆ—â€…:=:â€…{(a_k)_(kâ€Š<â€Šn) | nâ€‰âˆˆâ€‰â„•, a_kâ€‰âˆˆâ€‰S for each kâ€‰âˆˆâ€‰â„•_(<n)}

  (a_k)_(kâ€Š<â€Šn)â€…=â€…(a'_k)_(kâ€Š<â€Šn') â€Š:â‡” â€Šnâ€…=â€…n' and âˆ€â€†kâ€‰âˆˆâ€‰â„•_(<n)â€‰: a_kâ€…=â€…a'_k  (nâ€‰âˆˆâ€‰â„•, a_kâ€‰âˆˆâ€‰S for each kâ€‰âˆˆâ€‰â„•_(<n), n'â€‰âˆˆâ€‰â„•, a'_kâ€‰âˆˆâ€‰S for each kâ€‰âˆˆâ€‰â„•_(<n'))

We write â€œlet a be a finite sequence on Sâ€ for â€œlet aâ€‰âˆˆâ€‰S^âˆ—.â€

Remarks.

Finite sequences could alternatively be defined inductively (i.e. as lists). However, the given definition is closer to the definition of [infinite sequences](Infinite%20sequences), and often more useful in mathematical contexts.

References.

* https://en.wikipedia.org/wiki/Sequence
* http://mathworld.wolfram.com/Sequence.html
* https://proofwiki.org/wiki/Definition:Finite_Sequence
* https://ncatlab.org/nlab/show/free+monoid
* https://coq.inria.fr/library/Coq.Lists.List.html"
`;

exports[`render hlm library: 1.5.2 data/libraries/hlm/Essentials/Sequences/Infinite%20sequences 1`] = `
"Definition 1.5.2.  Let S be a set. We define:

  S^Ï‰â€…:=:â€…{(a_n)_(nâ€Šâˆˆâ€Šâ„•) | a_nâ€‰âˆˆâ€‰S for each nâ€‰âˆˆâ€‰â„•}

  (a_n)_(nâ€Šâˆˆâ€Šâ„•)â€…=â€…(a'_n)_(nâ€Šâˆˆâ€Šâ„•) â€Š:â‡” â€Šâˆ€â€†nâ€‰âˆˆâ€‰â„•â€‰: a_nâ€…=â€…a'_n  (a_nâ€‰âˆˆâ€‰S for each nâ€‰âˆˆâ€‰â„•, a'_nâ€‰âˆˆâ€‰S for each nâ€‰âˆˆâ€‰â„•)

We write â€œlet a be a sequence on Sâ€ for â€œlet aâ€‰âˆˆâ€‰S^Ï‰.â€

Remarks.

We omit the word â€œinfiniteâ€ because infinite sequences are used much more frequently than finite ones.

We could define infinite sequences simply as functions, but a custom construction has several advantages, including the ability to easily deconstruct a sequence into its elements and the ability to omit _S_ from the constructor.

Sequences of particular sets are treated in appropriate subsections concerning those sets.

References.

* https://en.wikipedia.org/wiki/Sequence
* http://mathworld.wolfram.com/Sequence.html
* https://proofwiki.org/wiki/Definition:Sequence/Infinite_Sequence
* https://ncatlab.org/nlab/show/sequence"
`;

exports[`render hlm library: 1.6.1.1 data/libraries/hlm/Essentials/Numbers/Natural/Natural%20numbers 1`] = `
"Definition 1.6.1.1.  We define:

  â„•â€…:=:â€…{(0), (n+1) | nâ€‰âˆˆâ€‰â„•}

  (m+1)â€…=â€…(n+1) â€Š:â‡” â€Šmâ€…=â€…n  (m,â€Šnâ€‰âˆˆâ€‰â„•)

Remarks.

The set of natural numbers is defined as a construction with two constructors, which, in this case, exactly matches the corresponding definition of an [inductive data type](https://en.wikipedia.org/wiki/Recursive_data_type). We merely use a custom notation for the â€œsuccessorâ€ constructor, but we could just as well write â€œS(_n_)â€. The notation is justified by an appropriate [proposition](Addition%20of%20one%20yields%20successor).

In this library, the natural numbers start at 0, which is known to be far more convenient than starting at 1.

References.

* https://en.wikipedia.org/wiki/Natural_number
* http://mathworld.wolfram.com/NonnegativeInteger.html
* https://proofwiki.org/wiki/Definition:Natural_Numbers
* https://ncatlab.org/nlab/show/natural+number
* https://coq.inria.fr/library/Coq.Init.Nat.html
* https://coq.inria.fr/library/Coq.NArith.BinNat.html
* http://oeis.org/A001477"
`;

exports[`render hlm library: 1.6.1.2 data/libraries/hlm/Essentials/Numbers/Natural/number 1`] = `
"Definition 1.6.1.2 (Positional notation).

Remarks.

Positional notation is implemented as a macro, i.e. using additional code that is injected into the proof checker. Therefore, no definition is given here.

References.

* https://en.wikipedia.org/wiki/Positional_notation
* https://coq.inria.fr/library/Coq.Init.Nat.html#of_uint_acc"
`;

exports[`render hlm library: 1.6.1.3 data/libraries/hlm/Essentials/Numbers/Natural/sum 1`] = `
"Definition 1.6.1.3.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. We define

  mâ€‰+â€‰n

by:

  mâ€‰+â€‰(0)â€…:=â€…m
  mâ€‰+â€‰(x+1)â€…:=â€…((mâ€‰+â€‰x)+1)  (xâ€‰âˆˆâ€‰â„•)

Remarks.

Such recursive definitions are possible due to the definition of natural numbers as a construction (i.e. inductive data type). Note that some of the â€œ+â€ symbols appearing in this definition are part of the notation of the successor constructor.

References.

* https://en.wikipedia.org/wiki/Natural_number#Addition
* https://proofwiki.org/wiki/Definition:Addition/Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#add
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.add"
`;

exports[`render hlm library: 1.6.1.4 data/libraries/hlm/Essentials/Numbers/Natural/Addition%20of%20one%20yields%20successor 1`] = `
"Proposition 1.6.1.4.  Let nâ€‰âˆˆâ€‰â„•. Then:

  (n+1)â€…=â€…nâ€‰+â€‰1

No proof.

Remarks.

This proposition justifies the notation for the successor constructor."
`;

exports[`render hlm library: 1.6.1.5 data/libraries/hlm/Essentials/Numbers/Natural/Sum%20is%20associative 1`] = `
"Proposition 1.6.1.5.

  + is associative

No proof.

References.

* https://en.wikipedia.org/wiki/Proofs_involving_the_addition_of_natural_numbers#Proof_of_associativity
* https://proofwiki.org/wiki/Natural_Number_Addition_is_Associative"
`;

exports[`render hlm library: 1.6.1.6 data/libraries/hlm/Essentials/Numbers/Natural/Left-addition%20of%20zero%20is%20neutral 1`] = `
"Lemma 1.6.1.6.  Let nâ€‰âˆˆâ€‰â„•. Then:

  0â€‰+â€‰nâ€…=â€…n

Proof.  We show that {0 if nâ€…=â€…(0), ((0â€‰+â€‰x)+1) if nâ€…=â€…(x+1) (xâ€‰âˆˆâ€‰â„•)â€…=â€…n:

1. We show that 0â€…=â€…0: Trivial.
2. Let xâ€‰âˆˆâ€‰â„•. Then ((0â€‰+â€‰x)+1)â€…=â€…(x+1):

1.6.1.6 â‡’ 0â€‰+â€‰xâ€…=â€…x

â‡’ ((0â€‰+â€‰x)+1)â€…=â€…(x+1)

References.

* https://en.wikipedia.org/wiki/Proofs_involving_the_addition_of_natural_numbers#Proof_of_identity_element
* https://proofwiki.org/wiki/Identity_Element_of_Natural_Number_Addition_is_Zero
* https://proofwiki.org/wiki/Natural_Number_Addition_Commutes_with_Zero
* https://coq.inria.fr/library/Coq.Arith.PeanoNat.html#Nat.add_0_l
* https://coq.inria.fr/library/Coq.NArith.BinNat.html#N.add_0_l"
`;

exports[`render hlm library: 1.6.1.7 data/libraries/hlm/Essentials/Numbers/Natural/Successor%20can%20be%20pulled%20over%20addition 1`] = `
"Lemma 1.6.1.7.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. Then:

  (m+1)â€‰+â€‰nâ€…=â€…((mâ€‰+â€‰n)+1)

Proof.  We show that {(m+1) if nâ€…=â€…(0), (((m+1)â€‰+â€‰x)+1) if nâ€…=â€…(x+1) (xâ€‰âˆˆâ€‰â„•)â€…=â€…((mâ€‰+â€‰n)+1):

1. We show that (m+1)â€…=â€…(m+1): Trivial.
2. Let xâ€‰âˆˆâ€‰â„•. Then (((m+1)â€‰+â€‰x)+1)â€…=â€…(((mâ€‰+â€‰x)+1)+1):

1.6.1.7 â‡’ (m+1)â€‰+â€‰xâ€…=â€…((mâ€‰+â€‰x)+1)

â‡’ (((m+1)â€‰+â€‰x)+1)â€…=â€…(((mâ€‰+â€‰x)+1)+1)

References.

* https://coq.inria.fr/library/Coq.Arith.PeanoNat.html#Nat.add_succ_l
* https://coq.inria.fr/library/Coq.NArith.BinNat.html#N.add_succ_l"
`;

exports[`render hlm library: 1.6.1.8 data/libraries/hlm/Essentials/Numbers/Natural/Sum%20is%20commutative 1`] = `
"Proposition 1.6.1.8.

  + is commutative

No proof.

References.

* https://en.wikipedia.org/wiki/Proofs_involving_the_addition_of_natural_numbers#Proof_of_commutativity
* https://proofwiki.org/wiki/Natural_Number_Addition_is_Commutative"
`;

exports[`render hlm library: 1.6.1.9 data/libraries/hlm/Essentials/Numbers/Natural/less%20or%20equal 1`] = `
"Definition 1.6.1.9.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. We define:

  mâ€…â‰¤â€…n â€Š:â‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰â„•â€‰: mâ€‰+â€‰xâ€…=â€…n
   â€Šâ‡” â€Š{true if mâ€…=â€…0, yâ€…â‰¤â€…n and yâ€…â‰ â€…n if mâ€…=â€…yâ€‰+â€‰1 (yâ€‰âˆˆâ€‰â„•)
   â€Šâ‡” â€Šmâ€…=â€…n or {false if nâ€…=â€…0, mâ€…â‰¤â€…z if nâ€…=â€…zâ€‰+â€‰1 (zâ€‰âˆˆâ€‰â„•)

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Natural_number#Order
* https://proofwiki.org/wiki/Definition:Ordering_on_Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#leb
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.leb"
`;

exports[`render hlm library: 1.6.1.10 data/libraries/hlm/Essentials/Numbers/Natural/less 1`] = `
"Definition 1.6.1.10.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. We define:

  mâ€…<â€…n â€Š:â‡” â€Šmâ€…â‰±â€…n
   â€Šâ‡” â€Šmâ€‰+â€‰1â€…â‰¤â€…n
   â€Šâ‡” â€Šmâ€…â‰¤â€…n and mâ€…â‰ â€…n
   â€Šâ‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰â„•_+â€‰: mâ€‰+â€‰xâ€…=â€…n
   â€Šâ‡” â€Šmâ€…â‰ â€…n and {true if mâ€…=â€…0, yâ€…<â€…n if mâ€…=â€…yâ€‰+â€‰1 (yâ€‰âˆˆâ€‰â„•)
   â€Šâ‡” â€Š{false if nâ€…=â€…0, mâ€…<â€…z or mâ€…=â€…z if nâ€…=â€…zâ€‰+â€‰1 (zâ€‰âˆˆâ€‰â„•)

Equivalence.  No proof.

References.

* https://coq.inria.fr/library/Coq.Init.Nat.html#ltb
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.ltb"
`;

exports[`render hlm library: 1.6.1.11 data/libraries/hlm/Essentials/Numbers/Natural/Less%20or%20equal%20is%20a%20total%20order 1`] = `
"Proposition 1.6.1.11.

  â‰¤ is a total order

No proof."
`;

exports[`render hlm library: 1.6.1.12 data/libraries/hlm/Essentials/Numbers/Natural/Less%20and%20less%20or%20equal%20combine%20to%20less 1`] = `
"Proposition 1.6.1.12.  Let a,â€Šb,â€Šcâ€‰âˆˆâ€‰â„• such that aâ€…<â€…b and bâ€…â‰¤â€…c. Then:

  aâ€…<â€…c

No proof."
`;

exports[`render hlm library: 1.6.1.13 data/libraries/hlm/Essentials/Numbers/Natural/Less%20or%20equal%20and%20less%20combine%20to%20less 1`] = `
"Proposition 1.6.1.13.  Let a,â€Šb,â€Šcâ€‰âˆˆâ€‰â„• such that aâ€…â‰¤â€…b and bâ€…<â€…c. Then:

  aâ€…<â€…c

No proof."
`;

exports[`render hlm library: 1.6.1.14 data/libraries/hlm/Essentials/Numbers/Natural/Zero%20is%20the%20smallest%20number 1`] = `
"Proposition 1.6.1.14.  Let nâ€‰âˆˆâ€‰â„•. Then:

  nâ€…â‰¥â€…0

No proof."
`;

exports[`render hlm library: 1.6.1.15 data/libraries/hlm/Essentials/Numbers/Natural/Zero%20is%20the%20only%20number%20less%20than%20or%20equal%20to%20zero 1`] = `
"Proposition 1.6.1.15.  Let nâ€‰âˆˆâ€‰â„• such that nâ€…â‰¤â€…0. Then:

  nâ€…=â€…0

No proof."
`;

exports[`render hlm library: 1.6.1.16 data/libraries/hlm/Essentials/Numbers/Natural/Successor%20is%20always%20greater 1`] = `
"Proposition 1.6.1.16.  Let nâ€‰âˆˆâ€‰â„•. Then:

  nâ€‰+â€‰1â€…>â€…n

No proof."
`;

exports[`render hlm library: 1.6.1.17.1 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Segment%20(less) 1`] = `
"Definition 1.6.1.17.1.  Let nâ€‰âˆˆâ€‰â„•. We define:

  â„•_(<n)â€…:=â€…{mâ€‰âˆˆâ€‰â„•â€‰: mâ€…<â€…n}

References.

* http://mathworld.wolfram.com/InitialSegment.html
* https://proofwiki.org/wiki/Definition:Initial_Segment_of_Natural_Numbers/Zero-Based"
`;

exports[`render hlm library: 1.6.1.17.2 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.6.1.17.2.  Let nâ€‰âˆˆâ€‰â„•. We define:

  â„•_(â‰¤n)â€…:=â€…{mâ€‰âˆˆâ€‰â„•â€‰: mâ€…â‰¤â€…n}
  â€…=â€…â„•_(<(n+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.6.1.17.3 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.6.1.17.3.  Let nâ€‰âˆˆâ€‰â„•. We define:

  â„•_(â‰¥n)â€…:=â€…{mâ€‰âˆˆâ€‰â„•â€‰: mâ€…â‰¥â€…n}
  â€…=â€…â„•â€…âˆ–â€…â„•_(<n)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.1.17.4 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Segment%20(greater) 1`] = `
"Definition 1.6.1.17.4.  Let nâ€‰âˆˆâ€‰â„•. We define:

  â„•_(>n)â€…:=â€…{mâ€‰âˆˆâ€‰â„•â€‰: mâ€…>â€…n}
  â€…=â€…â„•â€…âˆ–â€…â„•_(â‰¤n)
  â€…=â€…â„•_(â‰¥(n+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.6.1.17.5 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Positive%20numbers 1`] = `
"Definition 1.6.1.17.5.  We define:

  â„•_+â€…:=â€…â„•_(>0)
  â€…=â€…{mâ€‰âˆˆâ€‰â„•â€‰: mâ€…>â€…0}
  â€…=â€…{nâ€‰âˆˆâ€‰â„•â€‰: nâ€…â‰ â€…0}
  â€…=â€…â„•â€…âˆ–â€…{0}
  â€…=â€…{aâ€‰âˆˆâ€‰â„•â€‰: âˆƒâ€†bâ€‰âˆˆâ€‰â„•â€‰: bâ€‰+â€‰1â€…=â€…a}
  â€…=â€…{câ€‰âˆˆâ€‰â„•â€‰: âˆƒ!â€†dâ€‰âˆˆâ€‰â„•â€‰: dâ€‰+â€‰1â€…=â€…c}

Equality.  No proof.

References.

* https://proofwiki.org/wiki/Axiom:Axiomatization_of_1-Based_Natural_Numbers
* http://oeis.org/A000027"
`;

exports[`render hlm library: 1.6.1.17.6 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Exclusive%20initial%20segment%20is%20subset%20of%20inclusive%20segment 1`] = `
"Proposition 1.6.1.17.6.  Let nâ€‰âˆˆâ€‰â„•. Then:

  â„•_(<n)â€…âŠ†â€…â„•_(â‰¤n)

No proof."
`;

exports[`render hlm library: 1.6.1.17.7 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Initial%20segments%20are%20finite 1`] = `
"Proposition 1.6.1.17.7.  Let nâ€‰âˆˆâ€‰â„•. Then:

  â„•_(<n) is finite

No proof."
`;

exports[`render hlm library: 1.6.1.17.8 data/libraries/hlm/Essentials/Numbers/Natural/Subsets/Binary%20digits 1`] = `
"Definition 1.6.1.17.8.  We define:

  Bitâ€…:=â€…â„•_(â‰¤1)
  â€…=â€…{0,â€Š1}

Equality.  No proof.

Remarks.

There are, of course, many equivalent definitions of binary digits. The simplest definition would be a construction with two constructors. However, we also want the sets to be embedded in the natural numbers, and (currently) this requires everything to be mapped to a single constructor of the target set. So we simply define binary digits as a subset of the natural numbers.

In some cases, the set of [truth values](../../../Sets/Truth%20values) may be more convenient to use.

References.

* https://en.wikipedia.org/wiki/Bit
* http://mathworld.wolfram.com/Bit.html"
`;

exports[`render hlm library: 1.6.1.18 data/libraries/hlm/Essentials/Numbers/Natural/Finiteness%20criterion%20lemma 1`] = `
"Lemma 1.6.1.18.  Let Mâ€‰âŠ†â€‰â„•, kâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰â„•_(â‰¤k)â€‰â†”â€‰M be a bijection. Then:

  âˆƒâ€†mâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†nâ€‰âˆˆâ€‰Mâ€‰: nâ€…â‰¤â€…m

Proof.  We have {âˆƒâ€†aâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†bâ€‰âˆˆâ€‰Mâ€‰: bâ€…â‰¤â€…a if kâ€…=â€…0, âˆƒâ€†câ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†dâ€‰âˆˆâ€‰Mâ€‰: dâ€…â‰¤â€…c if kâ€…=â€…xâ€‰+â€‰1 (xâ€‰âˆˆâ€‰â„•):

1. Assume kâ€…=â€…0. Then âˆƒâ€†aâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†bâ€‰âˆˆâ€‰Mâ€‰: bâ€…â‰¤â€…a:

Choose aâ€…:=â€…f(0).
2. Let xâ€‰âˆˆâ€‰â„• such that kâ€…=â€…xâ€‰+â€‰1. Then âˆƒâ€†câ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†dâ€‰âˆˆâ€‰Mâ€‰: dâ€…â‰¤â€…c:

Let Sâ€‰:=â€‰â„•_(â‰¤x).

1.6.1.18 â‡’ âˆƒâ€†iâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†jâ€‰âˆˆâ€‰f(S)â€‰: jâ€…â‰¤â€…i

Choose câ€…:=â€…{f(k) if f(k)â€…>â€…i, i if f(k)â€…â‰¤â€…i.

Remarks.

This lemma is necessary to prove the following theorem. _k_ and _f_ do not appear in the result, but they enable a proof via structural induction on _k_."
`;

exports[`render hlm library: 1.6.1.19 data/libraries/hlm/Essentials/Numbers/Natural/Finiteness%20criterion 1`] = `
"Proposition 1.6.1.19.  Let Mâ€‰âŠ†â€‰â„•. Then the following are equivalent:

  1. M is finite
  2. M is empty or âˆƒâ€†mâ€‰âˆˆâ€‰Mâ€‰: m is a â‰¤-greatest element of M
  3. âˆƒâ€†aâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(â‰¤a)
  4. âˆƒâ€†bâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(<b)

Proof.

1â‡’2. Assume M is finite. Then M is empty or âˆƒâ€†mâ€‰âˆˆâ€‰Mâ€‰: m is a â‰¤-greatest element of M:

â‡’^def âˆƒâ€‰lâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰â„•_(<l)â€‰â†”â€‰M

We have {M is empty if lâ€…=â€…0, âˆƒâ€†iâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†jâ€‰âˆˆâ€‰Mâ€‰: jâ€…â‰¤â€…i if lâ€…=â€…kâ€‰+â€‰1 (kâ€‰âˆˆâ€‰â„•):

1. Assume lâ€…=â€…0. Then M is empty:

We show that âˆ„â€‰câ€‰âˆˆâ€‰M:

Assume âˆƒâ€‰câ€‰âˆˆâ€‰M.

fâ€…âˆˆâ€…(â„•_(<l)â€‰â†”â€‰M)

â‡’^def f is bijective

â‡’^def f is surjective

â‡’^def âˆ€â€†tâ€‰âˆˆâ€‰Mâ€‰: âˆƒâ€†sâ€‰âˆˆâ€‰â„•_(<0)â€‰: f(s)â€…=â€…t

â‡’ âˆƒâ€†sâ€‰âˆˆâ€‰â„•_(<0)â€‰: f(s)â€…=â€…c

sâ€…âˆˆâ€…â„•_(<0)

â‡’^def sâ€…<â€…0

â‡’^1.6.1.14 sâ€…â‰¥â€…0
2. Let kâ€‰âˆˆâ€‰â„• such that lâ€…=â€…kâ€‰+â€‰1. Then âˆƒâ€†iâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†jâ€‰âˆˆâ€‰Mâ€‰: jâ€…â‰¤â€…i:

â‡’^1.6.1.18 âˆƒâ€†yâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†zâ€‰âˆˆâ€‰Mâ€‰: zâ€…â‰¤â€…y
2â‡’3. Assume M is empty or âˆƒâ€†mâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†nâ€‰âˆˆâ€‰Mâ€‰: nâ€…â‰¤â€…m. Then âˆƒâ€†aâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(â‰¤a):

1. Assume M is empty.

â‡’^def Mâ€…=â€…âˆ…

Choose aâ€…:=â€…0. We show that Mâ€…âŠ†â€…â„•_(â‰¤0):

1.1.2 â‡’ âˆ…â€…âŠ†â€…â„•_(â‰¤0)

â‡’^[Mâ€Š=â€Šâˆ…] Mâ€…âŠ†â€…â„•_(â‰¤0)
2. Assume âˆƒâ€†mâ€‰âˆˆâ€‰Mâ€‰: âˆ€â€†nâ€‰âˆˆâ€‰Mâ€‰: nâ€…â‰¤â€…m.

Choose aâ€…:=â€…m. We show that Mâ€…âŠ†â€…â„•_(â‰¤m):

Let xâ€‰âˆˆâ€‰M. Then xâ€…âˆˆâ€…â„•_(â‰¤m):

We show that xâ€…â‰¤â€…m:

âˆ€â€†nâ€‰âˆˆâ€‰Mâ€‰: nâ€…â‰¤â€…m

â‡’ xâ€…â‰¤â€…m
3â‡’4. Assume âˆƒâ€†aâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(â‰¤a). Then âˆƒâ€†bâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(<b):

âˆƒâ€†aâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(â‰¤a)

â‡’^def Mâ€…âŠ†â€…â„•_(<(a+1))

Choose bâ€…:=â€…(a+1).
4â‡’1. Assume âˆƒâ€†bâ€‰âˆˆâ€‰â„•â€‰: Mâ€…âŠ†â€…â„•_(<b). Then M is finite:

â‡’^1.6.1.17.7 â„•_(<b) is finite

â‡’^1.1.5 M is finite"
`;

exports[`render hlm library: 1.6.1.20 data/libraries/hlm/Essentials/Numbers/Natural/Addition%20of%20a%20fixed%20number%20is%20injective 1`] = `
"Proposition 1.6.1.20.  Let a,â€Šb,â€Šcâ€‰âˆˆâ€‰â„• such that aâ€‰+â€‰câ€…=â€…bâ€‰+â€‰c. Then:

  aâ€…=â€…b

No proof."
`;

exports[`render hlm library: 1.6.1.21 data/libraries/hlm/Essentials/Numbers/Natural/Multiplication%20by%20a%20positive%20number%20is%20injective 1`] = `
"Proposition 1.6.1.21.  Let a,â€Šbâ€‰âˆˆâ€‰â„•, câ€‰âˆˆâ€‰â„•_+ such that aâ€Šâ‹…â€Šcâ€…=â€…bâ€Šâ‹…â€Šc. Then:

  aâ€…=â€…b

No proof."
`;

exports[`render hlm library: 1.6.1.22 data/libraries/hlm/Essentials/Numbers/Natural/difference 1`] = `
"Definition 1.6.1.22.  Let nâ€‰âˆˆâ€‰â„•, mâ€‰âˆˆâ€‰â„•_(â‰¤n). For xâ€‰âˆˆâ€‰â„•_(â‰¤n), we define:

  nâ€‰âˆ’â€‰mâ€…=â€…x â€Š:â‡” â€Šnâ€…=â€…xâ€‰+â€‰m

Well-definedness.  No proof.

References.

* https://proofwiki.org/wiki/Definition:Subtraction/Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#sub (truncated subtraction, thus incompatible with integer subtraction)
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.sub (ditto)"
`;

exports[`render hlm library: 1.6.1.23 data/libraries/hlm/Essentials/Numbers/Natural/product 1`] = `
"Definition 1.6.1.23.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. We define

  mâ€Šâ‹…â€Šn

by:

  mâ€Šâ‹…â€Š0â€…:=â€…0
  mâ€Šâ‹…â€Š(xâ€‰+â€‰1)â€…:=â€…mâ€Šâ‹…â€Šxâ€‰+â€‰m  (xâ€‰âˆˆâ€‰â„•)

References.

* https://en.wikipedia.org/wiki/Natural_number#Multiplication
* https://proofwiki.org/wiki/Definition:Multiplication/Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#mul
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.mul"
`;

exports[`render hlm library: 1.6.1.24 data/libraries/hlm/Essentials/Numbers/Natural/Multiplication%20by%20one%20is%20neutral 1`] = `
"Proposition 1.6.1.24.  Let nâ€‰âˆˆâ€‰â„•. Then:

  nâ€Šâ‹…â€Š1â€…=â€…n

No proof."
`;

exports[`render hlm library: 1.6.1.25 data/libraries/hlm/Essentials/Numbers/Natural/Product%20is%20associative 1`] = `
"Proposition 1.6.1.25.

  â‹… is associative

No proof."
`;

exports[`render hlm library: 1.6.1.26 data/libraries/hlm/Essentials/Numbers/Natural/Product%20is%20commutative 1`] = `
"Proposition 1.6.1.26.

  â‹… is commutative

No proof."
`;

exports[`render hlm library: 1.6.1.27 data/libraries/hlm/Essentials/Numbers/Natural/divisible 1`] = `
"Definition 1.6.1.27.  Let mâ€‰âˆˆâ€‰â„•_+, nâ€‰âˆˆâ€‰â„•. We define:

  mâ€…âˆ£â€…n â€Š:â‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰â„•â€‰: mâ€Šâ‹…â€Šxâ€…=â€…n

Remarks.

The constraint that _m_ is nonzero is not really necessary but added for consistency with the definition of the [set of divisors](Divisors).

References.

* https://en.wikipedia.org/wiki/Divisor
* http://mathworld.wolfram.com/Divisor.html
* https://proofwiki.org/wiki/Definition:Divisor_(Algebra)/Natural_Numbers"
`;

exports[`render hlm library: 1.6.1.28 data/libraries/hlm/Essentials/Numbers/Natural/Divisors 1`] = `
"Definition 1.6.1.28.  Let nâ€‰âˆˆâ€‰â„•. We define:

  Div_â„•(n)â€…:=â€…{mâ€‰âˆˆâ€‰â„•_+â€‰: mâ€…âˆ£â€…n}

Remarks.

We specifically exclude 0 from the list of its own divisors in order to simplify the definition of [division](quotient).

References.

* http://oeis.org/A027750"
`;

exports[`render hlm library: 1.6.1.29 data/libraries/hlm/Essentials/Numbers/Natural/Divisors%20are%20less%20or%20equal 1`] = `
"Proposition 1.6.1.29.  Let m,â€Šnâ€‰âˆˆâ€‰â„•_+ such that mâ€…âˆ£â€…n. Then:

  mâ€…â‰¤â€…n

No proof."
`;

exports[`render hlm library: 1.6.1.30 data/libraries/hlm/Essentials/Numbers/Natural/Divisibility%20criterion 1`] = `
"Proposition 1.6.1.30.  Let aâ€‰âˆˆâ€‰â„•_+, bâ€‰âˆˆâ€‰â„• such that aâ€…âˆ£â€…b, câ€‰âˆˆâ€‰â„•. Then the following are equivalent:

  1. aâ€…âˆ£â€…c
  2. aâ€…âˆ£â€…(bâ€‰+â€‰c)

No proof."
`;

exports[`render hlm library: 1.6.1.31 data/libraries/hlm/Essentials/Numbers/Natural/even 1`] = `
"Definition 1.6.1.31.  Let nâ€‰âˆˆâ€‰â„•. We define:

  n is even â€Š:â‡” â€Š{true if nâ€…=â€…0, x is odd if nâ€…=â€…xâ€‰+â€‰1 (xâ€‰âˆˆâ€‰â„•)
   â€Šâ‡” â€Š2â€…âˆ£â€…n

  n is odd â€Š:â‡” â€Šn is not even

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Parity_(mathematics)
* http://mathworld.wolfram.com/EvenNumber.html
* https://coq.inria.fr/library/Coq.Init.Nat.html#even
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.even
* http://oeis.org/A005843"
`;

exports[`render hlm library: 1.6.1.32 data/libraries/hlm/Essentials/Numbers/Natural/quotient 1`] = `
"Definition 1.6.1.32.  Let nâ€‰âˆˆâ€‰â„•, mâ€‰âˆˆâ€‰Div_â„•(n). For xâ€‰âˆˆâ€‰â„•, we define:

  n/mâ€…=â€…x â€Š:â‡” â€Šnâ€…=â€…xâ€Šâ‹…â€Šm

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Quotient
* https://coq.inria.fr/library/Coq.Init.Nat.html#div (truncated division, thus incompatible with division of rational numbers)
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.div (ditto)"
`;

exports[`render hlm library: 1.6.1.33 data/libraries/hlm/Essentials/Numbers/Natural/power 1`] = `
"Definition 1.6.1.33.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. We define

  m^n

by:

  m^0â€…:=â€…1
  m^(x+1)â€…:=â€…m^xâ€Šâ‹…â€Šm  (xâ€‰âˆˆâ€‰â„•)

References.

* https://en.wikipedia.org/wiki/Exponentiation#Integer_exponents
* https://proofwiki.org/wiki/Definition:Power_(Algebra)#Natural_Numbers
* https://coq.inria.fr/library/Coq.Init.Nat.html#pow
* https://coq.inria.fr/library/Coq.NArith.BinNatDef.html#N.pow"
`;

exports[`render hlm library: 1.6.1.34 data/libraries/hlm/Essentials/Numbers/Natural/inductive 1`] = `
"Definition 1.6.1.34.  Let Mâ€‰âŠ†â€‰â„•. We define:

  M is inductive â€Š:â‡” â€Š0â€…âˆˆâ€…M and âˆ€â€†mâ€‰âˆˆâ€‰Mâ€‰: mâ€‰+â€‰1â€…âˆˆâ€…M

Remarks.

This definition should be considered part of the [induction principle](Induction%20principle).

References.

* https://en.wikipedia.org/wiki/Inductive_set (but uses a 1-based definition)
* http://mathworld.wolfram.com/InductiveSet.html
* https://proofwiki.org/wiki/Definition:Inductive_Set (also uses a 1-based definition)"
`;

exports[`render hlm library: 1.6.1.35 data/libraries/hlm/Essentials/Numbers/Natural/Induction%20lemma 1`] = `
"Lemma 1.6.1.35.  Let Mâ€‰âŠ†â€‰â„• such that M is inductive, nâ€‰âˆˆâ€‰â„•. Then:

  nâ€…âˆˆâ€…M

Proof.  We have {nâ€…âˆˆâ€…M if nâ€…=â€…0, nâ€…âˆˆâ€…M if nâ€…=â€…xâ€‰+â€‰1 (xâ€‰âˆˆâ€‰â„•):

1. We show that 0â€…âˆˆâ€…M:

M is inductive

â‡’^def 0â€…âˆˆâ€…M
2. Let xâ€‰âˆˆâ€‰â„•. Then xâ€‰+â€‰1â€…âˆˆâ€…M:

1.6.1.35 â‡’ xâ€…âˆˆâ€…M

M is inductive

â‡’^def âˆ€â€†mâ€‰âˆˆâ€‰Mâ€‰: mâ€‰+â€‰1â€…âˆˆâ€…M

â‡’ xâ€‰+â€‰1â€…âˆˆâ€…M"
`;

exports[`render hlm library: 1.6.1.36 data/libraries/hlm/Essentials/Numbers/Natural/Induction%20principle 1`] = `
"Theorem 1.6.1.36 (Induction principle).  Let Mâ€‰âŠ†â€‰â„•. Then the following are equivalent:

  1. M is inductive
  2. Mâ€…=â€…â„•

Proof.

1â‡’2. âŠ†. Trivial.
âŠ‡. Let nâ€‰âˆˆâ€‰â„•. Then nâ€…âˆˆâ€…M:

1.6.1.35 â‡’ nâ€…âˆˆâ€…M

Remarks.

Structural induction on the natural numbers is a direct consequence of their definition as a construction. This set-theoretic form of the induction principle is provable from it.

References.

* https://proofwiki.org/wiki/Principle_of_Mathematical_Induction/Set"
`;

exports[`render hlm library: 1.6.1.37 data/libraries/hlm/Essentials/Numbers/Natural/Induction%20principle%20of%20property 1`] = `
"Corollary 1.6.1.37 (Induction principle (property-based)).  Let p be a property on â„• such that 0 is p and âˆ€â€†mâ€‰âˆˆâ€‰â„• s.t. m is pâ€‰: mâ€‰+â€‰1 is p. Then:

  âˆ€â€†nâ€‰âˆˆâ€‰â„•â€‰: n is p

No proof.

Remarks.

This is just a slight reformulation based on the definition of a [property](../../Properties/Properties).

References.

* https://en.wikipedia.org/wiki/Mathematical_induction
* http://mathworld.wolfram.com/PrincipleofMathematicalInduction.html
* https://proofwiki.org/wiki/Principle_of_Mathematical_Induction/Predicate"
`;

exports[`render hlm library: 1.6.1.38 data/libraries/hlm/Essentials/Numbers/Natural/Well-ordering%20principle 1`] = `
"Theorem 1.6.1.38 (Well-ordering principle).

  â‰¤ is a well-order

No proof.

References.

* https://en.wikipedia.org/wiki/Well-ordering_principle
* http://mathworld.wolfram.com/WellOrderingPrinciple.html
* https://proofwiki.org/wiki/Well-Ordering_Principle"
`;

exports[`render hlm library: 1.6.1.39 data/libraries/hlm/Essentials/Numbers/Natural/minimum 1`] = `
"Definition 1.6.1.39.  Let Mâ€‰âŠ†â€‰â„• such that M is nonempty. For mâ€‰âˆˆâ€‰M, we define:

  min(M)â€…=â€…m â€Š:â‡” â€Šâˆ€â€†nâ€‰âˆˆâ€‰Mâ€‰: mâ€…â‰¤â€…n
   â€Šâ‡” â€Šâˆ€â€†lâ€‰âˆˆâ€‰M s.t. lâ€…â‰¤â€…mâ€‰: lâ€…=â€…m
   â€Šâ‡” â€Šâˆ„â€†kâ€‰âˆˆâ€‰Mâ€‰: kâ€…<â€…m

Equivalence.  No proof.

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.1.40 data/libraries/hlm/Essentials/Numbers/Natural/factorial 1`] = `
"Definition 1.6.1.40.  Let nâ€‰âˆˆâ€‰â„•. We define

  n!

by:

  0!â€…:=â€…1
  (xâ€‰+â€‰1)!â€…:=â€…x!â€Šâ‹…â€Šn  (xâ€‰âˆˆâ€‰â„•)

References.

* https://en.wikipedia.org/wiki/Factorial
* http://mathworld.wolfram.com/Factorial.html
* https://proofwiki.org/wiki/Definition:Factorial
* https://coq.inria.fr/library/Coq.Arith.Factorial.html#fact"
`;

exports[`render hlm library: 1.6.1.41 data/libraries/hlm/Essentials/Numbers/Natural/binomial%20coefficient 1`] = `
"Definition 1.6.1.41.  Let n,â€Škâ€‰âˆˆâ€‰â„•. We define

  (n, k)

by:

  (n, 0)â€…:=â€…1
  (0, xâ€‰+â€‰1)â€…:=â€…0  (xâ€‰âˆˆâ€‰â„•)
  (mâ€‰+â€‰1, xâ€‰+â€‰1)â€…:=â€…(m, x)â€‰+â€‰(m, xâ€‰+â€‰1)  (mâ€‰âˆˆâ€‰â„•, xâ€‰âˆˆâ€‰â„•)

Remarks.

We use this definition of the binomial coefficient because it does not need any well-definedness proof. It can then easily be proved to be equal to the standard definition.

References.

* https://en.wikipedia.org/wiki/Pascal%27s_rule"
`;

exports[`render hlm library: 1.6.1.42 data/libraries/hlm/Essentials/Numbers/Natural/Binomial%20coefficient%20equality 1`] = `
"Proposition 1.6.1.42.  Let nâ€‰âˆˆâ€‰â„•, kâ€‰âˆˆâ€‰â„•_(â‰¤n). Then:

  (n, k)â€…=â€…(n!)/(k!â€Šâ‹…â€Š(nâ€‰âˆ’â€‰k)!)

No proof.

References.

* https://en.wikipedia.org/wiki/Binomial_coefficient
* http://mathworld.wolfram.com/BinomialCoefficient.html
* https://proofwiki.org/wiki/Definition:Binomial_Coefficient
* https://coq.inria.fr/library/Coq.Reals.Binomial.html#C"
`;

exports[`render hlm library: 1.6.1.43.1 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/inductive%20sum%20(exclusive) 1`] = `
"Definition 1.6.1.43.1.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n). We define

  âˆ‘_(iâ€Š<â€Šn)â€‰a_i

by:

  âˆ‘_(iâ€Š<â€Š0)â€‰a_iâ€…:=â€…0
  âˆ‘_(iâ€Š<â€Šm+1)â€‰a_iâ€…:=â€…(âˆ‘_(jâ€Š<â€Šm)â€‰a_j)â€‰+â€‰a_m  (mâ€‰âˆˆâ€‰â„•)

References.

* https://en.wikipedia.org/wiki/Summation
* http://mathworld.wolfram.com/Sum.html
* https://proofwiki.org/wiki/Definition:Summation"
`;

exports[`render hlm library: 1.6.1.43.2 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20sum%20is%20distributive%20over%20sum 1`] = `
"Proposition 1.6.1.43.2.  Let nâ€‰âˆˆâ€‰â„•, let a_i,â€Šb_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n). Then:

  âˆ‘_(jâ€Š<â€Šn)â€‰(a_jâ€‰+â€‰b_j)â€…=â€…(âˆ‘_(kâ€Š<â€Šn)â€‰a_k)â€‰+â€‰(âˆ‘_(lâ€Š<â€Šn)â€‰b_l)

No proof."
`;

exports[`render hlm library: 1.6.1.43.3 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20sum%20grows 1`] = `
"Proposition 1.6.1.43.3.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n), let mâ€‰âˆˆâ€‰â„•_(â‰¤n). Then:

  âˆ‘_(jâ€Š<â€Šm)â€‰a_jâ€…â‰¤â€…âˆ‘_(kâ€Š<â€Šn)â€‰a_k

No proof."
`;

exports[`render hlm library: 1.6.1.43.4 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20sum%20is%20greater%20or%20equal%20to%20each%20element 1`] = `
"Proposition 1.6.1.43.4.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n), let jâ€‰âˆˆâ€‰â„•_(<n). Then:

  a_jâ€…â‰¤â€…âˆ‘_(kâ€Š<â€Šn)â€‰a_k

No proof."
`;

exports[`render hlm library: 1.6.1.43.5 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Sum%20over%20constant 1`] = `
"Proposition 1.6.1.43.5.  Let n,â€Šaâ€‰âˆˆâ€‰â„•. Then:

  âˆ‘_(iâ€Š<â€Šn)â€‰aâ€…=â€…nâ€Šâ‹…â€Ša

No proof."
`;

exports[`render hlm library: 1.6.1.43.6 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Sum%20over%20variable 1`] = `
"Proposition 1.6.1.43.6.  Let nâ€‰âˆˆâ€‰â„•. Then:

  âˆ‘_(iâ€Š<â€Šn)â€‰iâ€…=â€…(n, 2)

No proof."
`;

exports[`render hlm library: 1.6.1.43.7 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/inductive%20product%20(exclusive) 1`] = `
"Definition 1.6.1.43.7.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n). We define

  âˆ_(iâ€Š<â€Šn)â€‰a_i

by:

  âˆ_(iâ€Š<â€Š0)â€‰a_iâ€…:=â€…1
  âˆ_(iâ€Š<â€Šm+1)â€‰a_iâ€…:=â€…(âˆ_(jâ€Š<â€Šm)â€‰a_j)â€Šâ‹…â€Ša_m  (mâ€‰âˆˆâ€‰â„•)

References.

* https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation
* http://mathworld.wolfram.com/Product.html
* https://proofwiki.org/wiki/Definition:Product_Notation_(Algebra)"
`;

exports[`render hlm library: 1.6.1.43.8 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20product%20is%20distributive%20over%20product 1`] = `
"Proposition 1.6.1.43.8.  Let nâ€‰âˆˆâ€‰â„•, let a_i,â€Šb_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n). Then:

  âˆ_(jâ€Š<â€Šn)â€‰(a_jâ€Šâ‹…â€Šb_j)â€…=â€…(âˆ_(kâ€Š<â€Šn)â€‰a_k)â€Šâ‹…â€Š(âˆ_(lâ€Š<â€Šn)â€‰b_l)

No proof."
`;

exports[`render hlm library: 1.6.1.43.9 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20product%20multiplies 1`] = `
"Proposition 1.6.1.43.9.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n), let mâ€‰âˆˆâ€‰â„•_(â‰¤n). Then:

  âˆ_(jâ€Š<â€Šm)â€‰a_jâ€…âˆ£â€…âˆ_(kâ€Š<â€Šn)â€‰a_k

No proof."
`;

exports[`render hlm library: 1.6.1.43.10 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20product%20of%20positive%20numbers%20grows 1`] = `
"Proposition 1.6.1.43.10.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„•_+ for each iâ€‰âˆˆâ€‰â„•_(<n), let mâ€‰âˆˆâ€‰â„•_(â‰¤n). Then:

  âˆ_(jâ€Š<â€Šm)â€‰a_jâ€…â‰¤â€…âˆ_(kâ€Š<â€Šn)â€‰a_k

No proof."
`;

exports[`render hlm library: 1.6.1.43.11 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20product%20is%20a%20multiple%20of%20each%20element 1`] = `
"Proposition 1.6.1.43.11.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„• for each iâ€‰âˆˆâ€‰â„•_(<n), let jâ€‰âˆˆâ€‰â„•_(<n). Then:

  a_jâ€…âˆ£â€…âˆ_(kâ€Š<â€Šn)â€‰a_k

No proof."
`;

exports[`render hlm library: 1.6.1.43.12 data/libraries/hlm/Essentials/Numbers/Natural/Generalized%20sums%20and%20products/Inductive%20product%20of%20positive%20numbers%20is%20greater%20or%20equal%20to%20each%20element 1`] = `
"Proposition 1.6.1.43.12.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„•_+ for each iâ€‰âˆˆâ€‰â„•_(<n), let jâ€‰âˆˆâ€‰â„•_(<n). Then:

  a_jâ€…â‰¤â€…âˆ_(kâ€Š<â€Šn)â€‰a_k

No proof."
`;

exports[`render hlm library: 1.6.1.44.1 data/libraries/hlm/Essentials/Numbers/Natural/Prime/prime 1`] = `
"Definition 1.6.1.44.1.  Let nâ€‰âˆˆâ€‰â„•_(>1). We define:

  n is prime â€Š:â‡” â€Šâˆ€â€†mâ€‰âˆˆâ€‰â„•_+ s.t. mâ€…âˆ£â€…nâ€‰: [mâ€…=â€…1 or mâ€…=â€…n]
   â€Šâ‡” â€Šâˆ€â€†lâ€‰âˆˆâ€‰â„•_(>1) s.t. lâ€…âˆ£â€…nâ€‰: lâ€…=â€…n
   â€Šâ‡” â€ŠDiv_â„•(n)â€…âŠ†â€…{1,â€Šn}
   â€Šâ‡” â€ŠDiv_â„•(n)â€…=â€…{1,â€Šn}
   â€Šâ‡” â€Š|Div_â„•(n)|â€…=â€…2
   â€Šâ‡” â€Šâˆ€â€†a,â€Šbâ€‰âˆˆâ€‰â„• s.t. nâ€…=â€…aâ€Šâ‹…â€Šbâ€‰: [[aâ€…=â€…1 and bâ€…=â€…n] or [aâ€…=â€…n and bâ€…=â€…1]]
   â€Šâ‡” â€Šâˆ„â€†c,â€Šdâ€‰âˆˆâ€‰â„•_(<n)â€‰: nâ€…=â€…câ€Šâ‹…â€Šd
   â€Šâ‡” â€Šâˆ€â€†e,â€Šfâ€‰âˆˆâ€‰â„• s.t. nâ€…âˆ£â€…eâ€Šâ‹…â€Šfâ€‰: [nâ€…âˆ£â€…e or nâ€…âˆ£â€…f]

  n is composite â€Š:â‡” â€Šn is not prime

Equivalence.  No proof.

Remarks.

Note that this definition presupposes that _n_ is greater than 1. Otherwise, not all equivalences would hold.

In particular, this makes it impossible to ask whether 1 is prime. However, it is rarely necessary to ask whether a given number is prime without knowing that it is greater than 1. For definitions and theorems involving the [set of prime numbers](Prime%20numbers), no such explicit exclusion of 1 is necessary.

References.

* https://en.wikipedia.org/wiki/Prime_number
* https://en.wikipedia.org/wiki/Euclid%27s_lemma
* http://mathworld.wolfram.com/PrimeNumber.html
* https://proofwiki.org/wiki/Definition:Prime_Number
* https://ncatlab.org/nlab/show/prime+number
* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#prime"
`;

exports[`render hlm library: 1.6.1.44.2 data/libraries/hlm/Essentials/Numbers/Natural/Prime/Two%20is%20prime 1`] = `
"Example 1.6.1.44.2.

  2 is prime

No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#prime_2"
`;

exports[`render hlm library: 1.6.1.44.3 data/libraries/hlm/Essentials/Numbers/Natural/Prime/Prime%20numbers 1`] = `
"Definition 1.6.1.44.3.  We define:

  â„™â€…:=â€…{nâ€‰âˆˆâ€‰â„•_(>1)â€‰: n is prime}

References.

* https://en.wikipedia.org/wiki/Prime_number
* http://mathworld.wolfram.com/PrimeNumber.html
* https://proofwiki.org/wiki/Definition:Prime_Number#Notation
* http://oeis.org/A000040"
`;

exports[`render hlm library: 1.6.1.44.4 data/libraries/hlm/Essentials/Numbers/Natural/Prime/Every%20number%20greater%20than%20one%20has%20a%20prime%20factor 1`] = `
"Proposition 1.6.1.44.4.  Let nâ€‰âˆˆâ€‰â„•_(>1). Then:

  âˆƒâ€†pâ€‰âˆˆâ€‰â„™â€‰: pâ€…âˆ£â€…n

No proof."
`;

exports[`render hlm library: 1.6.1.44.5 data/libraries/hlm/Essentials/Numbers/Natural/Prime/Euclids%20theorem 1`] = `
"Theorem 1.6.1.44.5 (Euclid's theorem).

  â„™ is infinite

Proof.  Assume â„™ is finite.

â‡’^def âˆƒâ€‰nâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰â„•_(<n)â€‰â†”â€‰â„™

Let aâ€‰:=â€‰âˆ_(iâ€Š<â€Šn)â€‰f(i).

1.6.1.43.10 â‡’ 1â€…â‰¤â€…a

Let bâ€‰:=â€‰aâ€‰+â€‰1.

1.6.1.16 â‡’ bâ€…>â€…a

â‡’^1.6.1.13 bâ€…>â€…1

â‡’^1.6.1.44.4 âˆƒâ€†pâ€‰âˆˆâ€‰â„™â€‰: pâ€…âˆ£â€…b

â‡’^def pâ€…âˆ£â€…(aâ€‰+â€‰1)

â‡’^1.6.1.43.11 f(f^-1(p))â€…âˆ£â€…a

â‡’^1.4.26 pâ€…âˆ£â€…a

â‡’^1.6.1.30 pâ€…âˆ£â€…1

â‡’^1.6.1.29 pâ€…â‰¤â€…1

pâ€…âˆˆâ€…â„™

â‡’^def pâ€…>â€…1

References.

* https://en.wikipedia.org/wiki/Euclid%27s_theorem
* http://mathworld.wolfram.com/EuclidsTheorems.html
* https://proofwiki.org/wiki/Euclid%27s_Theorem"
`;

exports[`render hlm library: 1.6.1.44.6 data/libraries/hlm/Essentials/Numbers/Natural/Prime/Prime%20and%20power%20divisibility%20criterion 1`] = `
"Proposition 1.6.1.44.6.  Let pâ€‰âˆˆâ€‰â„™, mâ€‰âˆˆâ€‰â„•, nâ€‰âˆˆâ€‰â„•_+. Then the following are equivalent:

  1. pâ€…âˆ£â€…m
  2. pâ€…âˆ£â€…m^n
  3. p^nâ€…âˆ£â€…m^n

No proof."
`;

exports[`render hlm library: 1.6.1.45 data/libraries/hlm/Essentials/Numbers/Natural/coprime 1`] = `
"Definition 1.6.1.45.  Let m,â€Šnâ€‰âˆˆâ€‰â„•. We define:

  m and n are coprime â€Š:â‡” â€Šâˆ€â€†aâ€‰âˆˆâ€‰â„•_+ s.t. aâ€…âˆ£â€…m and aâ€…âˆ£â€…nâ€‰: aâ€…=â€…1
   â€Šâ‡” â€Šâˆ„â€†bâ€‰âˆˆâ€‰â„•_(>1)â€‰: [bâ€…âˆ£â€…m and bâ€…âˆ£â€…n]
   â€Šâ‡” â€ŠDiv_â„•(m)â€…âˆ©â€…Div_â„•(n)â€…âŠ†â€…{1}
   â€Šâ‡” â€ŠDiv_â„•(m)â€…âˆ©â€…Div_â„•(n)â€…=â€…{1}
   â€Šâ‡” â€Šâˆ„â€†pâ€‰âˆˆâ€‰â„™â€‰: [pâ€…âˆ£â€…m and pâ€…âˆ£â€…n]

Equivalence.  No proof.

Remarks.

Note that in addition to this definition for natural numbers, there is a compatible [definition for integers](../Integer/coprime).

References.

* https://en.wikipedia.org/wiki/Coprime_integers
* http://mathworld.wolfram.com/RelativelyPrime.html
* https://proofwiki.org/wiki/Definition:Coprime/Integers
* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#rel_prime (for integers)"
`;

exports[`render hlm library: 1.6.1.46 data/libraries/hlm/Essentials/Numbers/Natural/Coprime%20test 1`] = `
"Proposition 1.6.1.46.  Let m,â€Šnâ€‰âˆˆâ€‰â„•_(>1). Then:

  m and mâ€Šâ‹…â€Šn are not coprime

No proof."
`;

exports[`render hlm library: 1.6.1.47.1 data/libraries/hlm/Essentials/Numbers/Natural/Technical%20definitions/indexed%20element 1`] = `
"Definition 1.6.1.47.1.  Let Mâ€‰âŠ†â€‰â„•, nâ€‰âˆˆâ€‰â„• such that nâ€…<â€…|M|, mâ€‰:=â€‰min(M). We define

  M[n]

by:

  M[0]â€…:=â€…m
  M[xâ€‰+â€‰1]â€…:=â€…(Mâ€…âˆ–â€…{m})[x]  (xâ€‰âˆˆâ€‰â„•)

Remarks.

This definition is used to prove the equivalence of alternative definitions of [finiteness](../../../Sets/finite), and to provide a [way](../Sequences/finite%20sequence) of obtaining a sequence from a finite set of natural numbers."
`;

exports[`render hlm library: 1.6.1.47.2 data/libraries/hlm/Essentials/Numbers/Natural/Technical%20definitions/bounded%20cardinality 1`] = `
"Definition 1.6.1.47.2.  Let Mâ€‰âŠ†â€‰â„•, nâ€‰âˆˆâ€‰â„•. We define

  |M|_â‰¤n

by:

  |M|_â‰¤0â€…:=â€…0
  |M|_â‰¤x+1â€…:=â€…{|Mâ€…âˆ–â€…{min(M)}|_â‰¤xâ€‰+â€‰1 if M is nonempty, 0 if M is empty  (xâ€‰âˆˆâ€‰â„•)

Remarks.

This definition is used to prove the equivalence of alternative definitions of [finiteness](../../../Sets/finite). It yields a natural number that is a lower bound for the cardinality of a subset of natural numbers."
`;

exports[`render hlm library: 1.6.1.48.1 data/libraries/hlm/Essentials/Numbers/Natural/Sequences/finite%20sequence 1`] = `
"Definition 1.6.1.48.1.  Let Mâ€‰âŠ†â€‰â„• such that M is finite. We define:

  seq_fin(M)â€…:=â€…(M[n])_(nâ€Š<â€Š|M|)

Remarks.

This definition produces a sorted finite sequence from a finite subset of natural numbers."
`;

exports[`render hlm library: 1.6.1.48.2 data/libraries/hlm/Essentials/Numbers/Natural/Sequences/infinite%20sequence 1`] = `
"Definition 1.6.1.48.2.  Let Mâ€‰âŠ†â€‰â„• such that M is infinite. We define:

  seq_inf(M)â€…:=â€…(M[n])_(nâ€Šâˆˆâ€Šâ„•)

Remarks.

This definition produces a sorted infinite sequence from an infinite subset of natural numbers."
`;

exports[`render hlm library: 1.6.2.1 data/libraries/hlm/Essentials/Numbers/Cardinal/Natural%20cardinality%20lemma 1`] = `
"Lemma 1.6.2.1.  Let m,â€Šnâ€‰âˆˆâ€‰â„•, fâ€‰:â€‰â„•_(<m)â€‰â†”â€‰â„•_(<n) be a bijection. Then:

  mâ€…=â€…n

No proof.

Remarks.

This lemma is part of the well-definedness proof of the embedding of the natural numbers into the cardinal numbers."
`;

exports[`render hlm library: 1.6.2.2 data/libraries/hlm/Essentials/Numbers/Cardinal/Cardinal%20numbers 1`] = `
"Definition 1.6.2.2.  We define:

  ð“’ð“»ð“­â€…:=:â€…{|S| | S is a set}

  |S|â€…=â€…|T| â€Š:â‡” â€Šâˆƒâ€‰fâ€‰:â€‰Sâ€‰â†”â€‰T  (S,â€ŠT are sets)

â„•â€…âŠ†:â€…ð“’ð“»ð“­ via
nâ€…=â€…|â„•_(<n)|

Well-definedness.  Let m,â€Šnâ€‰âˆˆâ€‰â„• such that |â„•_(<m)|â€…=â€…|â„•_(<n)|. Then mâ€…=â€…n:

|â„•_(<m)|â€…=â€…|â„•_(<n)|

â‡’^def âˆƒâ€‰fâ€‰:â€‰â„•_(<m)â€‰â†”â€‰â„•_(<n)

1.6.2.1 â‡’ mâ€…=â€…n

Remarks.

In HLM, cardinal numbers have a very simple definition as a construction with one constructor, which can be conveniently equipped with a notation that matches mathematical practice.

Given that two arbitrary sets cannot be compared element-wise due to the type system, the equality definition for cardinal numbers is the most general definition possible: No other valid equality definition can possibly distinguish two equipollent sets. This implies that definitions involving the â€œdeconstructionâ€ of cardinal numbers into sets are automatically well-defined.

HLM does not distinguish between sets and proper classes; instead there are rules preventing certain circularities. Thus, the set of cardinals can be treated like any other set in most situations.

When defining a construction, an embedding from another set into the newly defined set can be specified, subject to a suitable well-definedness condition. Embedding the natural numbers in the cardinal numbers simplifies a lot of definitions, including e.g. the definition of [finiteness](../../Sets/finite).

In a way, the definition of cardinal numbers in HLM is very similar to the definition of algebraic structures such as [magmas](../../../Algebra/Magmas/Magmas). This is especially visible in the use of this definition in the [category of sets](../../../Category%20theory/Individual%20categories/cardinals).

References.

* https://en.wikipedia.org/wiki/Cardinal_number
* http://mathworld.wolfram.com/CardinalNumber.html
* https://proofwiki.org/wiki/Definition:Cardinal
* https://ncatlab.org/nlab/show/cardinal+number"
`;

exports[`render hlm library: 1.6.2.3 data/libraries/hlm/Essentials/Numbers/Cardinal/Carrier 1`] = `
"Definition 1.6.2.3.  Let ð±â€‰âˆˆâ€‰ð“’ð“»ð“­. We define

  Carrier(ð±)

by:

  Carrier(|S|)â€…:=â€…S  (S is a set)

We write â€œlet aâ€‰âˆˆâ€‰ð±â€ for â€œlet aâ€‰âˆˆâ€‰Carrier(ð±).â€

Remarks.

This definition retrieves a representative set from a cardinal number, and enables typical abuse of notation."
`;

exports[`render hlm library: 1.6.2.4 data/libraries/hlm/Essentials/Numbers/Cardinal/Homomorphisms 1`] = `
"Definition 1.6.2.4.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define:

  Hom(ð±,â€Šð²)â€…:=â€…(Carrier(ð±)â€‰â†’â€‰Carrier(ð²))

We write â€œlet Ï†â€‰:â€‰ð±â€‰â†’â€‰ð² be a homomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Hom(ð±,â€Šð²).â€

Remarks.

The definition of cardinal numbers in HLM is very similar to the definition of algebraic structures such as magmas. Thus it makes sense to define a homomorphism between cardinal numbers as a function between representative sets.

Although these sets are not unique, the type system prevents the ambiguities that could arise, as long as the equality definition of the structure does not define any non-isomorphic elements as equal."
`;

exports[`render hlm library: 1.6.2.5 data/libraries/hlm/Essentials/Numbers/Cardinal/Isomorphisms 1`] = `
"Definition 1.6.2.5.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define:

  Iso(ð±,â€Šð²)â€…:=â€…{Ï†â€‰:â€‰ð±â€‰â†’â€‰ð²â€‰: Ï† is bijective}
  â€…=â€…(Carrier(ð±)â€‰â†”â€‰Carrier(ð²))

We write â€œlet Ï†â€‰:â€‰ð±â€‰â†”â€‰ð² be an isomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Iso(ð±,â€Šð²).â€

Equality.  No proof."
`;

exports[`render hlm library: 1.6.2.6 data/libraries/hlm/Essentials/Numbers/Cardinal/identity 1`] = `
"Definition 1.6.2.6.  Let ð±â€‰âˆˆâ€‰ð“’ð“»ð“­. We define:

  id_ð±â€…:=â€…id_(Carrier(ð±))"
`;

exports[`render hlm library: 1.6.2.7 data/libraries/hlm/Essentials/Numbers/Cardinal/less%20or%20equal 1`] = `
"Definition 1.6.2.7.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define:

  ð±â€…â‰¤â€…ð² â€Š:â‡” â€Šâˆƒâ€†Ï†â€‰:â€‰ð±â€‰â†’â€‰ð²â€‰: Ï† is injective
   â€Šâ‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð²)â€‰: |S|â€…=â€…ð±

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Cardinal_number"
`;

exports[`render hlm library: 1.6.2.8 data/libraries/hlm/Essentials/Numbers/Cardinal/less 1`] = `
"Definition 1.6.2.8.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define:

  ð±â€…<â€…ð² â€Š:â‡” â€Šð±â€…â‰¤â€…ð² and ð±â€…â‰ â€…ð²

Remarks.

Note that without the axiom of choice, this is not equivalent to the negation of â€œgreater or equalâ€."
`;

exports[`render hlm library: 1.6.2.9 data/libraries/hlm/Essentials/Numbers/Cardinal/Less%20or%20equal%20is%20a%20partial%20order 1`] = `
"Proposition 1.6.2.9.

  â‰¤ is a partial order

No proof."
`;

exports[`render hlm library: 1.6.2.10 data/libraries/hlm/Essentials/Numbers/Cardinal/AC%20is%20equivalent%20to%20total%20order 1`] = `
"Proposition 1.6.2.10.  The following are equivalent:

  1. AC
  2. â‰¤ is a total order

No proof.

Remarks.

The non-circularity requirements of HLM have a subtle effect on this proposition: Even though the axiom of choice, by itself, does not exclude the set of cardinal numbers, this proposition cannot be used to conclude that the cardinal numbers have a choice function if the order on cardinal numbers is total."
`;

exports[`render hlm library: 1.6.2.11 data/libraries/hlm/Essentials/Numbers/Cardinal/Equality%20criterion 1`] = `
"Proposition 1.6.2.11.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. Then the following are equivalent:

  1. ð±â€…â‰¤â€…ð² and ð²â€…â‰¤â€…ð±
  2. Iso(ð±,â€Šð²) is nonempty
  3. ð±â€…=â€…ð²

No proof.

References.

* [https://en.wikipedia.org/wiki/SchrÃ¶der-Bernstein_theorem](https://en.wikipedia.org/wiki/Schr%C3%B6der-Bernstein_theorem)
* http://mathworld.wolfram.com/Schroeder-BernsteinTheorem.html
* [https://proofwiki.org/wiki/Cantor-Bernstein-SchrÃ¶der_Theorem](https://proofwiki.org/wiki/Cantor-Bernstein-Schr%C3%B6der_Theorem)"
`;

exports[`render hlm library: 1.6.2.12 data/libraries/hlm/Essentials/Numbers/Cardinal/sum 1`] = `
"Definition 1.6.2.12.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define

  ð±â€‰+â€‰ð²

by:

  |X|â€‰+â€‰|Y|â€…:=â€…|Xâ€…âŠŽâ€…Y|  (X,â€ŠY are sets)

References.

* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_addition
* http://mathworld.wolfram.com/CardinalAddition.html
* https://proofwiki.org/wiki/Definition:Sum_of_Cardinals"
`;

exports[`render hlm library: 1.6.2.13 data/libraries/hlm/Essentials/Numbers/Cardinal/product 1`] = `
"Definition 1.6.2.13.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define

  ð±â€Šâ‹…â€Šð²

by:

  |X|â€Šâ‹…â€Š|Y|â€…:=â€…|Xâ€‰Ã—â€‰Y|  (X,â€ŠY are sets)

References.

* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_multiplication
* http://mathworld.wolfram.com/CardinalMultiplication.html
* https://proofwiki.org/wiki/Definition:Product_of_Cardinals"
`;

exports[`render hlm library: 1.6.2.14 data/libraries/hlm/Essentials/Numbers/Cardinal/power 1`] = `
"Definition 1.6.2.14.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“’ð“»ð“­. We define

  ð±^ð²

by:

  |X|^|Y|â€…:=â€…|Yâ€‰â†’â€‰X|  (X,â€ŠY are sets)

References.

* http://mathworld.wolfram.com/CardinalExponentiation.html
* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_exponentiation
* https://proofwiki.org/wiki/Definition:Exponentiation_of_Cardinals"
`;

exports[`render hlm library: 1.6.2.15 data/libraries/hlm/Essentials/Numbers/Cardinal/Cardinality%20of%20power%20set 1`] = `
"Proposition 1.6.2.15.  Let S be a set. Then:

  |ð’«(S)|â€…=â€…2^|S|

No proof.

References.

* https://en.wikipedia.org/wiki/Cardinal_number#Cardinal_exponentiation
* http://mathworld.wolfram.com/CardinalExponentiation.html"
`;

exports[`render hlm library: 1.6.3.1 data/libraries/hlm/Essentials/Numbers/Ordinal/Ordinal%20numbers 1`] = `
"Definition 1.6.3.1.  We define:

  ð“žð“»ð“­â€…:=:â€…{[S,â€Šâª¯] | S is a set, âª¯ is a well-order on S}

  [S,â€Šâª¯]â€…=â€…[T,â€ŠâŠ‘] â€Š:â‡” â€Š  âˆƒâ€†Ï†â€‰:â€‰Sâ€‰â†”â€‰Tâ€‰: Ï†[âª¯]â€…=â€…âŠ‘  (S is a set, âª¯ is a relation on S, T is a set, âŠ‘ is a relation on T with suitable conditions)

â„•â€…âŠ†:â€…ð“žð“»ð“­ via
nâ€…=â€…[â„•_(<n),â€Šâ‰¤âˆ£_(â„•_(<n))]

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.3.2 data/libraries/hlm/Essentials/Numbers/Ordinal/Carrier 1`] = `
"Definition 1.6.3.2.  Let ð±â€‰âˆˆâ€‰ð“žð“»ð“­. We define

  Carrier(ð±)

by:

  Carrier([S,â€Šâª¯])â€…:=â€…S  (S is a set, âª¯ is a relation on S with suitable conditions)

We write â€œlet aâ€‰âˆˆâ€‰ð±â€ for â€œlet aâ€‰âˆˆâ€‰Carrier(ð±).â€

Remarks.

This definition retrieves a representative set from an ordinal number, and enables typical abuse of notation."
`;

exports[`render hlm library: 1.6.3.3 data/libraries/hlm/Essentials/Numbers/Ordinal/before 1`] = `
"Definition 1.6.3.3.  Let ð±â€‰âˆˆâ€‰ð“žð“»ð“­, a,â€Šbâ€‰âˆˆâ€‰ð±. We define:

  aâ€…â‰¤â€…b â€Š:â‡” â€Š{aâ€…âª¯â€…b if ð±â€…=â€…[X,â€Šâª¯] (X is a set, âª¯ is a relation on X with suitable conditions)"
`;

exports[`render hlm library: 1.6.3.4 data/libraries/hlm/Essentials/Numbers/Ordinal/Homomorphisms 1`] = `
"Definition 1.6.3.4.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. We define:

  Hom(ð±,â€Šð²)â€…:=â€…{fâ€‰:â€‰Carrier(ð±)â€‰â†’â€‰Carrier(ð²)â€‰: âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ð± s.t. aâ€…â‰¤â€…bâ€‰: f(a)â€…â‰¤â€…f(b)}

We write â€œlet Ï†â€‰:â€‰ð±â€‰â†’â€‰ð² be a homomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Hom(ð±,â€Šð²).â€"
`;

exports[`render hlm library: 1.6.3.5 data/libraries/hlm/Essentials/Numbers/Ordinal/Isomorphisms 1`] = `
"Definition 1.6.3.5.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. We define:

  Iso(ð±,â€Šð²)â€…:=â€…{homomorphisms Ï†â€‰:â€‰ð±â€‰â†’â€‰ð²â€‰: Ï† is bijective}
  â€…=â€…{fâ€‰:â€‰Carrier(ð±)â€‰â†”â€‰Carrier(ð²)â€‰: âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ð± s.t. aâ€…â‰¤â€…bâ€‰: f(a)â€…â‰¤â€…f(b)}

We write â€œlet Ï†â€‰:â€‰ð±â€‰â†”â€‰ð² be an isomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Iso(ð±,â€Šð²).â€

Equality.  No proof."
`;

exports[`render hlm library: 1.6.3.6 data/libraries/hlm/Essentials/Numbers/Ordinal/identity 1`] = `
"Definition 1.6.3.6.  Let ð±â€‰âˆˆâ€‰ð“žð“»ð“­. We define:

  id_ð±â€…:=â€…id_(Carrier(ð±))"
`;

exports[`render hlm library: 1.6.3.7 data/libraries/hlm/Essentials/Numbers/Ordinal/ordered%20subset 1`] = `
"Definition 1.6.3.7.  Let ð±â€‰âˆˆâ€‰ð“žð“»ð“­, Sâ€‰âŠ†â€‰Carrier(ð±). We define

  S is an ordered subset of ð±

by:

  S is an ordered subset of [X,â€Šâª¯] â€Š:â‡” â€Šâª¯âˆ£_S is a well-order  (X is a set, âª¯ is a relation on X with suitable conditions)"
`;

exports[`render hlm library: 1.6.3.8 data/libraries/hlm/Essentials/Numbers/Ordinal/subset%20ordinal 1`] = `
"Definition 1.6.3.8.  Let ð±â€‰âˆˆâ€‰ð“žð“»ð“­, Sâ€‰âŠ†â€‰Carrier(ð±) such that S is an ordered subset of ð±. We define:

  [S]â€…:=â€…{[S,â€Šâª¯âˆ£_S] if ð±â€…=â€…[X,â€Šâª¯] (X is a set, âª¯ is a relation on X with suitable conditions)"
`;

exports[`render hlm library: 1.6.3.9 data/libraries/hlm/Essentials/Numbers/Ordinal/less%20or%20equal 1`] = `
"Definition 1.6.3.9.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. We define:

  ð±â€…â‰¤â€…ð² â€Š:â‡” â€Šâˆƒâ€†homomorphism Ï†â€‰:â€‰ð±â€‰â†’â€‰ð²â€‰: Ï† is injective
   â€Šâ‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð²)â€‰: [S is an ordered subset of ð² and ð±â€…=â€…[S]]

Equivalence.  No proof."
`;

exports[`render hlm library: 1.6.3.10 data/libraries/hlm/Essentials/Numbers/Ordinal/less 1`] = `
"Definition 1.6.3.10.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. We define:

  ð±â€…<â€…ð² â€Š:â‡” â€Šð±â€…â‰¤â€…ð² and ð±â€…â‰ â€…ð²"
`;

exports[`render hlm library: 1.6.3.11 data/libraries/hlm/Essentials/Numbers/Ordinal/Less%20or%20equal%20is%20a%20well-order 1`] = `
"Proposition 1.6.3.11.

  â‰¤ is a well-order

No proof."
`;

exports[`render hlm library: 1.6.3.12 data/libraries/hlm/Essentials/Numbers/Ordinal/Equality%20criterion 1`] = `
"Proposition 1.6.3.12.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. Then the following are equivalent:

  1. ð±â€…â‰¤â€…ð² and ð²â€…â‰¤â€…ð±
  2. Iso(ð±,â€Šð²) is nonempty
  3. ð±â€…=â€…ð²

No proof."
`;

exports[`render hlm library: 1.6.3.13 data/libraries/hlm/Essentials/Numbers/Ordinal/sum 1`] = `
"Definition 1.6.3.13.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. We define

  ð±â€‰+â€‰ð²

by:

  [X,â€Šâª¯]â€‰+â€‰[Y,â€ŠâŠ‘]â€…:=â€…[Xâ€…âŠŽâ€…Y,â€Šâª¯â€‰â‰ªâ€‰âŠ‘]  (X is a set, âª¯ is a relation on X, Y is a set, âŠ‘ is a relation on Y with suitable conditions)"
`;

exports[`render hlm library: 1.6.3.14 data/libraries/hlm/Essentials/Numbers/Ordinal/product 1`] = `
"Definition 1.6.3.14.  Let ð±,â€Šð²â€‰âˆˆâ€‰ð“žð“»ð“­. We define

  ð±â€Šâ‹…â€Šð²

by:

  [X,â€Šâª¯]â€Šâ‹…â€Š[Y,â€ŠâŠ‘]â€…:=â€…[Xâ€‰Ã—â€‰Y,â€Šâª¯â€‰âˆ â€‰âŠ‘]  (X is a set, âª¯ is a relation on X, Y is a set, âŠ‘ is a relation on Y with suitable conditions)"
`;

exports[`render hlm library: 1.6.4.1 data/libraries/hlm/Essentials/Numbers/Integer/Integers 1`] = `
"Definition 1.6.4.1.  We define:

  â„¤â€…:=:â€…{(n-m) | n,â€Šmâ€‰âˆˆâ€‰â„•}

  (n-m)â€…=â€…(n'-m') â€Š:â‡” â€Šnâ€‰+â€‰m'â€…=â€…n'â€‰+â€‰m  (n,â€Šm,â€Šn',â€Šm'â€‰âˆˆâ€‰â„•)

  Reflexivity.  No proof.

  Symmetry.  No proof.

  Transitivity.  No proof.

â„•â€…âŠ†:â€…â„¤ via
xâ€…=â€…(x-0)

Well-definedness.  Let x,â€Šyâ€‰âˆˆâ€‰â„• such that (x-0)â€…=â€…(y-0). Then xâ€…=â€…y:

(x-0)â€…=â€…(y-0)

â‡’^def xâ€‰+â€‰0â€…=â€…yâ€‰+â€‰0

â‡’^def xâ€…=â€…y

Remarks.

This is essentially the standard definition of integers as equivalence classes of pairs of natural numbers. We just use a notation that highlights the role of the two numbers in each pair. This notation is later justified by a [proposition](Actual%20difference%20equals%20formal%20difference).

Since an equality definition for each constructor is always part of a construction, we do not need to build the equivalence classes explicitly, they are implicit in the choice of the equality definition.

When defining a construction, another set can be embedded in the newly defined set, so in this case, we embed the natural numbers. Note that they are also embedded in the cardinal numbers.

References.

* https://en.wikipedia.org/wiki/Integer
* http://mathworld.wolfram.com/Integer.html
* https://proofwiki.org/wiki/Definition:Integer
* https://ncatlab.org/nlab/show/integer
* https://coq.inria.fr/library/Coq.ZArith.BinInt.html (but uses a different encoding as an inductive data type with three constructors)"
`;

exports[`render hlm library: 1.6.4.2 data/libraries/hlm/Essentials/Numbers/Integer/sum 1`] = `
"Definition 1.6.4.2.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤. We define

  aâ€‰+â€‰b

by:

  (n_a-m_a)â€‰+â€‰(n_b-m_b)â€…:=â€…((n_aâ€‰+â€‰n_b)-(m_aâ€‰+â€‰m_b))  (n_a,â€Šm_aâ€‰âˆˆâ€‰â„•, n_b,â€Šm_bâ€‰âˆˆâ€‰â„•)

Well-definedness.  No proof.

Remarks.

Note that the sums on the right are sums of natural numbers.

References.

* https://en.wikipedia.org/wiki/Integer#Construction
* https://proofwiki.org/wiki/Definition:Addition/Integers
* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.add (but uses a different encoding)"
`;

exports[`render hlm library: 1.6.4.3 data/libraries/hlm/Essentials/Numbers/Integer/Sum%20is%20associative 1`] = `
"Proposition 1.6.4.3.

  + is associative

No proof."
`;

exports[`render hlm library: 1.6.4.4 data/libraries/hlm/Essentials/Numbers/Integer/Sum%20is%20commutative 1`] = `
"Proposition 1.6.4.4.

  + is commutative

No proof."
`;

exports[`render hlm library: 1.6.4.5 data/libraries/hlm/Essentials/Numbers/Integer/inverse 1`] = `
"Definition 1.6.4.5.  Let aâ€‰âˆˆâ€‰â„¤. We define

  âˆ’a

by:

  âˆ’(n_a-m_a)â€…:=â€…(m_a-n_a)  (n_a,â€Šm_aâ€‰âˆˆâ€‰â„•)

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.opp (but uses a different encoding)"
`;

exports[`render hlm library: 1.6.4.6 data/libraries/hlm/Essentials/Numbers/Integer/difference 1`] = `
"Definition 1.6.4.6.  Let b,â€Šaâ€‰âˆˆâ€‰â„¤. We define

  bâ€‰âˆ’â€‰a

by:

  (n_b-m_b)â€‰âˆ’â€‰(n_a-m_a)â€…:=â€…((n_bâ€‰+â€‰m_a)-(m_bâ€‰+â€‰n_a))  (n_b,â€Šm_bâ€‰âˆˆâ€‰â„•, n_a,â€Šm_aâ€‰âˆˆâ€‰â„•)
  â€…=â€…bâ€‰+â€‰(âˆ’a)

Equality.  No proof.

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.sub (but uses a different encoding)"
`;

exports[`render hlm library: 1.6.4.7 data/libraries/hlm/Essentials/Numbers/Integer/Actual%20difference%20equals%20formal%20difference 1`] = `
"Proposition 1.6.4.7.  Let n,â€Šmâ€‰âˆˆâ€‰â„•. Then:

  (n-m)â€…=â€…nâ€‰âˆ’â€‰m

No proof.

Remarks.

This proposition justifies the notation used for the constructor. Note that the subtraction on the right is subtraction on integers, i.e. on the embedding of the natural numbers _m_ and _n_ into the integers."
`;

exports[`render hlm library: 1.6.4.8 data/libraries/hlm/Essentials/Numbers/Integer/less%20or%20equal 1`] = `
"Definition 1.6.4.8.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤. We define

  aâ€…â‰¤â€…b

by:

  (n_a-m_a)â€…â‰¤â€…(n_b-m_b) â€Š:â‡” â€Šn_aâ€‰+â€‰m_bâ€…â‰¤â€…n_bâ€‰+â€‰m_a  (n_a,â€Šm_aâ€‰âˆˆâ€‰â„•, n_b,â€Šm_bâ€‰âˆˆâ€‰â„•)
   â€Šâ‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰â„•â€‰: aâ€‰+â€‰xâ€…=â€…b

Equivalence.  No proof.

Well-definedness.  No proof.

Remarks.

Note that the comparison on the right is comparison on natural numbers.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.leb (but uses a different encoding)"
`;

exports[`render hlm library: 1.6.4.9 data/libraries/hlm/Essentials/Numbers/Integer/less 1`] = `
"Definition 1.6.4.9.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤. We define:

  aâ€…<â€…b â€Š:â‡” â€Šaâ€…â‰±â€…b
   â€Šâ‡” â€Šaâ€‰+â€‰1â€…â‰¤â€…b
   â€Šâ‡” â€Šaâ€…â‰¤â€…b and aâ€…â‰ â€…b

Equivalence.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.ltb (but uses a different encoding)"
`;

exports[`render hlm library: 1.6.4.10.1 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Segment%20(less) 1`] = `
"Definition 1.6.4.10.1.  Let aâ€‰âˆˆâ€‰â„¤. We define:

  â„¤_(<a)â€…:=â€…{bâ€‰âˆˆâ€‰â„¤â€‰: bâ€…<â€…a}"
`;

exports[`render hlm library: 1.6.4.10.2 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.6.4.10.2.  Let aâ€‰âˆˆâ€‰â„¤. We define:

  â„¤_(â‰¤a)â€…:=â€…{bâ€‰âˆˆâ€‰â„¤â€‰: bâ€…â‰¤â€…a}
  â€…=â€…â„¤_(<(a+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.10.3 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.6.4.10.3.  Let aâ€‰âˆˆâ€‰â„¤. We define:

  â„¤_(â‰¥a)â€…:=â€…{bâ€‰âˆˆâ€‰â„¤â€‰: bâ€…â‰¥â€…a}
  â€…=â€…â„¤â€…âˆ–â€…â„¤_(<a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.10.4 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Segment%20(greater) 1`] = `
"Definition 1.6.4.10.4.  Let aâ€‰âˆˆâ€‰â„¤. We define:

  â„¤_(>a)â€…:=â€…{bâ€‰âˆˆâ€‰â„¤â€‰: bâ€…>â€…a}
  â€…=â€…â„¤â€…âˆ–â€…â„¤_(â‰¤a)
  â€…=â€…â„¤_(â‰¥(a+1))

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.10.5 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Hole 1`] = `
"Definition 1.6.4.10.5.  Let aâ€‰âˆˆâ€‰â„¤. We define:

  â„¤_(â‰ a)â€…:=â€…{bâ€‰âˆˆâ€‰â„¤â€‰: bâ€…â‰ â€…a}
  â€…=â€…â„¤_(<a)â€…âˆªâ€…â„¤_(>a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.10.6 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Negative%20numbers 1`] = `
"Definition 1.6.4.10.6.  We define:

  â„¤_âˆ’â€…:=â€…â„¤_(<0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„¤â€‰: aâ€…<â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.10.7 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Nonpositive%20numbers 1`] = `
"Definition 1.6.4.10.7.  We define:

  â„¤_0^âˆ’â€…:=â€…â„¤_(â‰¤0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„¤â€‰: aâ€…â‰¤â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.10.8 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Nonnegative%20numbers 1`] = `
"Definition 1.6.4.10.8.  We define:

  â„¤_0^+â€…:=â€…â„¤_(â‰¥0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„¤â€‰: aâ€…â‰¥â€…0}
  â€…=â€…â„•

Equality.  No proof.

Remarks.

Due to the embedding of natural numbers into integers, this is just an alias for the set of natural numbers."
`;

exports[`render hlm library: 1.6.4.10.9 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Positive%20numbers 1`] = `
"Definition 1.6.4.10.9.  We define:

  â„¤_+â€…:=â€…â„¤_(>0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„¤â€‰: aâ€…>â€…0}
  â€…=â€…â„•_+

Equality.  No proof.

Remarks.

Due to the embedding of natural numbers into integers, this is just an alias for the set of positive natural numbers."
`;

exports[`render hlm library: 1.6.4.10.10 data/libraries/hlm/Essentials/Numbers/Integer/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.6.4.10.10.  We define:

  â„¤_Â±â€…:=â€…â„¤_(â‰ 0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„¤â€‰: aâ€…â‰ â€…0}
  â€…=â€…â„¤_âˆ’â€…âˆªâ€…â„¤_+

Equality.  No proof."
`;

exports[`render hlm library: 1.6.4.11 data/libraries/hlm/Essentials/Numbers/Integer/absolute 1`] = `
"Definition 1.6.4.11.  Let aâ€‰âˆˆâ€‰â„¤. We define:

  |a|â€…:=â€…{a if aâ€…â‰¥â€…0, âˆ’a if aâ€…<â€…0

References.

* https://en.wikipedia.org/wiki/Absolute_value
* http://mathworld.wolfram.com/AbsoluteValue.html
* https://proofwiki.org/wiki/Definition:Absolute_Value
* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.abs"
`;

exports[`render hlm library: 1.6.4.12 data/libraries/hlm/Essentials/Numbers/Integer/product 1`] = `
"Definition 1.6.4.12.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤. We define

  aâ€Šâ‹…â€Šb

by:

  (n_a-m_a)â€Šâ‹…â€Š(n_b-m_b)â€…:=â€…((n_aâ€Šâ‹…â€Šn_bâ€‰+â€‰m_aâ€Šâ‹…â€Šm_b)-(n_aâ€Šâ‹…â€Šm_bâ€‰+â€‰m_aâ€Šâ‹…â€Šn_b))  (n_a,â€Šm_aâ€‰âˆˆâ€‰â„•, n_b,â€Šm_bâ€‰âˆˆâ€‰â„•)

Well-definedness.  No proof.

Remarks.

Note that the sums and products on the right are operations on natural numbers.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.mul (but uses a different encoding)"
`;

exports[`render hlm library: 1.6.4.13 data/libraries/hlm/Essentials/Numbers/Integer/Product%20is%20associative 1`] = `
"Proposition 1.6.4.13.

  â‹… is associative

No proof."
`;

exports[`render hlm library: 1.6.4.14 data/libraries/hlm/Essentials/Numbers/Integer/Product%20is%20commutative 1`] = `
"Proposition 1.6.4.14.

  â‹… is commutative

No proof."
`;

exports[`render hlm library: 1.6.4.15 data/libraries/hlm/Essentials/Numbers/Integer/divisible 1`] = `
"Definition 1.6.4.15.  Let aâ€‰âˆˆâ€‰â„¤_Â±, bâ€‰âˆˆâ€‰â„¤. We define:

  aâ€…âˆ£â€…b â€Š:â‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰â„¤â€‰: aâ€Šâ‹…â€Šxâ€…=â€…b
   â€Šâ‡” â€Š|a|â€…âˆ£â€…|b|

Equivalence.  No proof."
`;

exports[`render hlm library: 1.6.4.16 data/libraries/hlm/Essentials/Numbers/Integer/Divisors 1`] = `
"Definition 1.6.4.16.  Let bâ€‰âˆˆâ€‰â„¤. We define:

  Div_â„¤(b)â€…:=â€…{aâ€‰âˆˆâ€‰â„¤_Â±â€‰: aâ€…âˆ£â€…b}"
`;

exports[`render hlm library: 1.6.4.17 data/libraries/hlm/Essentials/Numbers/Integer/quotient 1`] = `
"Definition 1.6.4.17.  Let bâ€‰âˆˆâ€‰â„¤, aâ€‰âˆˆâ€‰Div_â„¤(b). For xâ€‰âˆˆâ€‰â„¤, we define:

  b/aâ€…=â€…x â€Š:â‡” â€Šbâ€…=â€…xâ€Šâ‹…â€Ša

Well-definedness.  No proof.

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.div (truncated division, thus incompatible with division of rational numbers)"
`;

exports[`render hlm library: 1.6.4.18 data/libraries/hlm/Essentials/Numbers/Integer/power 1`] = `
"Definition 1.6.4.18.  Let aâ€‰âˆˆâ€‰â„¤, nâ€‰âˆˆâ€‰â„•. We define

  a^n

by:

  a^0â€…:=â€…1
  a^(x+1)â€…:=â€…a^xâ€Šâ‹…â€Ša  (xâ€‰âˆˆâ€‰â„•)

References.

* https://coq.inria.fr/library/Coq.ZArith.BinIntDef.html#Z.pow"
`;

exports[`render hlm library: 1.6.4.19 data/libraries/hlm/Essentials/Numbers/Integer/Addition%20of%20a%20fixed%20number%20is%20injective 1`] = `
"Proposition 1.6.4.19.  Let a,â€Šb,â€Šcâ€‰âˆˆâ€‰â„¤ such that aâ€‰+â€‰câ€…=â€…bâ€‰+â€‰c. Then:

  aâ€…=â€…b

No proof."
`;

exports[`render hlm library: 1.6.4.20 data/libraries/hlm/Essentials/Numbers/Integer/Multiplication%20of%20a%20nonzero%20number%20is%20injective 1`] = `
"Proposition 1.6.4.20.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤, câ€‰âˆˆâ€‰â„¤_Â± such that aâ€Šâ‹…â€Šcâ€…=â€…bâ€Šâ‹…â€Šc. Then:

  aâ€…=â€…b

No proof."
`;

exports[`render hlm library: 1.6.4.21 data/libraries/hlm/Essentials/Numbers/Integer/Power%20base%20product%20law 1`] = `
"Proposition 1.6.4.21.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤, nâ€‰âˆˆâ€‰â„•. Then:

  (aâ€Šâ‹…â€Šb)^nâ€…=â€…a^nâ€Šâ‹…â€Šb^n

No proof."
`;

exports[`render hlm library: 1.6.4.22.1 data/libraries/hlm/Essentials/Numbers/Integer/Prime/Prime%20and%20power%20divisibility%20criterion 1`] = `
"Proposition 1.6.4.22.1.  Let pâ€‰âˆˆâ€‰â„™, aâ€‰âˆˆâ€‰â„¤, nâ€‰âˆˆâ€‰â„•_+. Then the following are equivalent:

  1. pâ€…âˆ£â€…a
  2. pâ€…âˆ£â€…a^n
  3. p^nâ€…âˆ£â€…a^n

No proof."
`;

exports[`render hlm library: 1.6.4.23 data/libraries/hlm/Essentials/Numbers/Integer/coprime 1`] = `
"Definition 1.6.4.23.  Let a,â€Šbâ€‰âˆˆâ€‰â„¤. We define:

  a and b are coprime â€Š:â‡” â€Šâˆ€â€†câ€‰âˆˆâ€‰â„¤_+ s.t. câ€…âˆ£â€…a and câ€…âˆ£â€…bâ€‰: câ€…=â€…1
   â€Šâ‡” â€Šâˆ„â€†dâ€‰âˆˆâ€‰â„¤_(>1)â€‰: [dâ€…âˆ£â€…a and dâ€…âˆ£â€…b]
   â€Šâ‡” â€Šâˆ€â€†eâ€‰âˆˆâ€‰â„¤_Â± s.t. eâ€…âˆ£â€…a and eâ€…âˆ£â€…bâ€‰: |e|â€…=â€…1
   â€Šâ‡” â€ŠDiv_â„¤(a)â€…âˆ©â€…Div_â„¤(b)â€…âŠ†â€…{1,â€Šâˆ’1}
   â€Šâ‡” â€ŠDiv_â„¤(a)â€…âˆ©â€…Div_â„¤(b)â€…=â€…{1,â€Šâˆ’1}
   â€Šâ‡” â€Šâˆ„â€†pâ€‰âˆˆâ€‰â„™â€‰: [pâ€…âˆ£â€…a and pâ€…âˆ£â€…b]

Equivalence.  No proof.

References.

* https://en.wikipedia.org/wiki/Coprime_integers
* http://mathworld.wolfram.com/RelativelyPrime.html
* https://proofwiki.org/wiki/Definition:Coprime/Integers
* https://coq.inria.fr/library/Coq.ZArith.Znumtheory.html#rel_prime"
`;

exports[`render hlm library: 1.6.5.1 data/libraries/hlm/Essentials/Numbers/Rational/Rational%20numbers 1`] = `
"Definition 1.6.5.1.  We define:

  â„šâ€…:=:â€…{(n/d) | nâ€‰âˆˆâ€‰â„¤, dâ€‰âˆˆâ€‰â„•_+}

  (n/d)â€…=â€…(n'/d') â€Š:â‡” â€Šnâ€Šâ‹…â€Šd'â€…=â€…n'â€Šâ‹…â€Šd  (nâ€‰âˆˆâ€‰â„¤, dâ€‰âˆˆâ€‰â„•_+, n'â€‰âˆˆâ€‰â„¤, d'â€‰âˆˆâ€‰â„•_+)

  Reflexivity.  No proof.

  Symmetry.  No proof.

  Transitivity.  No proof.

â„¤â€…âŠ†:â€…â„š via
xâ€…=â€…(x/1)

Well-definedness.  No proof.

Remarks.

This definition is rather similar to the definition of [integers](../Integer/Integers). Again, the constructor notation is later justified by a [proposition](Actual%20quotient%20equals%20formal%20quotient).

Note that in the constructor, we force the denominator to be positive. This is not required at this point, since the given equality definition would also work for negative numbers. However, if the denominator was allowed to be negative, the definition of [comparison](less%20or%20equal) would probably need to be split into several cases.

References.

* https://en.wikipedia.org/wiki/Rational_number
* http://mathworld.wolfram.com/RationalNumber.html
* https://proofwiki.org/wiki/Definition:Rational_Number
* https://ncatlab.org/nlab/show/rational+number
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html"
`;

exports[`render hlm library: 1.6.5.2 data/libraries/hlm/Essentials/Numbers/Rational/sum 1`] = `
"Definition 1.6.5.2.  Let a,â€Šbâ€‰âˆˆâ€‰â„š. We define

  aâ€‰+â€‰b

by:

  (n_a/d_a)â€‰+â€‰(n_b/d_b)â€…:=â€…((n_aâ€Šâ‹…â€Šd_bâ€‰+â€‰n_bâ€Šâ‹…â€Šd_a)/(d_aâ€Šâ‹…â€Šd_b))  (n_aâ€‰âˆˆâ€‰â„¤, d_aâ€‰âˆˆâ€‰â„•_+, n_bâ€‰âˆˆâ€‰â„¤, d_bâ€‰âˆˆâ€‰â„•_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Addition
* https://proofwiki.org/wiki/Definition:Addition/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qplus"
`;

exports[`render hlm library: 1.6.5.3 data/libraries/hlm/Essentials/Numbers/Rational/inverse 1`] = `
"Definition 1.6.5.3.  Let aâ€‰âˆˆâ€‰â„š. We define

  âˆ’a

by:

  âˆ’(n_a/d_a)â€…:=â€…((âˆ’n_a)/d_a)  (n_aâ€‰âˆˆâ€‰â„¤, d_aâ€‰âˆˆâ€‰â„•_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Inverse
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qopp"
`;

exports[`render hlm library: 1.6.5.4 data/libraries/hlm/Essentials/Numbers/Rational/difference 1`] = `
"Definition 1.6.5.4.  Let b,â€Šaâ€‰âˆˆâ€‰â„š. We define

  bâ€‰âˆ’â€‰a

by:

  (n_b/d_b)â€‰âˆ’â€‰(n_a/d_a)â€…:=â€…((n_bâ€Šâ‹…â€Šd_aâ€‰âˆ’â€‰n_aâ€Šâ‹…â€Šd_b)/(d_bâ€Šâ‹…â€Šd_a))  (n_bâ€‰âˆˆâ€‰â„¤, d_bâ€‰âˆˆâ€‰â„•_+, n_aâ€‰âˆˆâ€‰â„¤, d_aâ€‰âˆˆâ€‰â„•_+)
  â€…=â€…bâ€‰+â€‰(âˆ’a)

Equality.  No proof.

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Subtraction
* https://proofwiki.org/wiki/Definition:Subtraction/Rational_Numbers"
`;

exports[`render hlm library: 1.6.5.5 data/libraries/hlm/Essentials/Numbers/Rational/less%20or%20equal 1`] = `
"Definition 1.6.5.5.  Let a,â€Šbâ€‰âˆˆâ€‰â„š. We define

  aâ€…â‰¤â€…b

by:

  (n_a/d_a)â€…â‰¤â€…(n_b/d_b) â€Š:â‡” â€Šn_aâ€Šâ‹…â€Šd_bâ€…â‰¤â€…n_bâ€Šâ‹…â€Šd_a  (n_aâ€‰âˆˆâ€‰â„¤, d_aâ€‰âˆˆâ€‰â„•_+, n_bâ€‰âˆˆâ€‰â„¤, d_bâ€‰âˆˆâ€‰â„•_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Ordering"
`;

exports[`render hlm library: 1.6.5.6 data/libraries/hlm/Essentials/Numbers/Rational/less 1`] = `
"Definition 1.6.5.6.  Let a,â€Šbâ€‰âˆˆâ€‰â„š. We define:

  aâ€…<â€…b â€Š:â‡” â€Šaâ€…â‰±â€…b
   â€Šâ‡” â€Šaâ€…â‰¤â€…b and aâ€…â‰ â€…b

Equivalence.  No proof."
`;

exports[`render hlm library: 1.6.5.7.1 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Segment%20(less) 1`] = `
"Definition 1.6.5.7.1.  Let aâ€‰âˆˆâ€‰â„š. We define:

  â„š_(<a)â€…:=â€…{bâ€‰âˆˆâ€‰â„šâ€‰: bâ€…<â€…a}"
`;

exports[`render hlm library: 1.6.5.7.2 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.6.5.7.2.  Let aâ€‰âˆˆâ€‰â„š. We define:

  â„š_(â‰¤a)â€…:=â€…{bâ€‰âˆˆâ€‰â„šâ€‰: bâ€…â‰¤â€…a}"
`;

exports[`render hlm library: 1.6.5.7.3 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.6.5.7.3.  Let aâ€‰âˆˆâ€‰â„š. We define:

  â„š_(â‰¥a)â€…:=â€…{bâ€‰âˆˆâ€‰â„šâ€‰: bâ€…â‰¥â€…a}
  â€…=â€…â„šâ€…âˆ–â€…â„š_(<a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.7.4 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Segment%20(greater) 1`] = `
"Definition 1.6.5.7.4.  Let aâ€‰âˆˆâ€‰â„š. We define:

  â„š_(>a)â€…:=â€…{bâ€‰âˆˆâ€‰â„šâ€‰: bâ€…>â€…a}
  â€…=â€…â„šâ€…âˆ–â€…â„š_(â‰¤a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.7.5 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Hole 1`] = `
"Definition 1.6.5.7.5.  Let aâ€‰âˆˆâ€‰â„š. We define:

  â„š_(â‰ a)â€…:=â€…{bâ€‰âˆˆâ€‰â„šâ€‰: bâ€…â‰ â€…a}
  â€…=â€…â„š_(<a)â€…âˆªâ€…â„š_(>a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.7.6 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Negative%20numbers 1`] = `
"Definition 1.6.5.7.6.  We define:

  â„š_âˆ’â€…:=â€…â„š_(<0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„šâ€‰: aâ€…<â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.7.7 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Nonpositive%20numbers 1`] = `
"Definition 1.6.5.7.7.  We define:

  â„š_0^âˆ’â€…:=â€…â„š_(â‰¤0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„šâ€‰: aâ€…â‰¤â€…0}

Equality.  No proof.

References.

* https://proofwiki.org/wiki/Definition:Negative/Rational_Number"
`;

exports[`render hlm library: 1.6.5.7.8 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Nonnegative%20numbers 1`] = `
"Definition 1.6.5.7.8.  We define:

  â„š_0^+â€…:=â€…â„š_(â‰¥0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„šâ€‰: aâ€…â‰¥â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.7.9 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Positive%20numbers 1`] = `
"Definition 1.6.5.7.9.  We define:

  â„š_+â€…:=â€…â„š_(>0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„šâ€‰: aâ€…>â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.7.10 data/libraries/hlm/Essentials/Numbers/Rational/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.6.5.7.10.  We define:

  â„š_Â±â€…:=â€…â„š_(â‰ 0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„šâ€‰: aâ€…â‰ â€…0}
  â€…=â€…â„š_âˆ’â€…âˆªâ€…â„š_+

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.8 data/libraries/hlm/Essentials/Numbers/Rational/absolute 1`] = `
"Definition 1.6.5.8.  Let aâ€‰âˆˆâ€‰â„š. We define:

  |a|â€…:=â€…{a if aâ€…â‰¥â€…0, âˆ’a if aâ€…<â€…0

References.

* https://en.wikipedia.org/wiki/Absolute_value
* http://mathworld.wolfram.com/AbsoluteValue.html
* https://proofwiki.org/wiki/Definition:Absolute_Value
* https://coq.inria.fr/library/Coq.QArith.Qabs.html"
`;

exports[`render hlm library: 1.6.5.9 data/libraries/hlm/Essentials/Numbers/Rational/product 1`] = `
"Definition 1.6.5.9.  Let a,â€Šbâ€‰âˆˆâ€‰â„š. We define

  aâ€Šâ‹…â€Šb

by:

  (n_a/d_a)â€Šâ‹…â€Š(n_b/d_b)â€…:=â€…((n_aâ€Šâ‹…â€Šn_b)/(d_aâ€Šâ‹…â€Šd_b))  (n_aâ€‰âˆˆâ€‰â„¤, d_aâ€‰âˆˆâ€‰â„•_+, n_bâ€‰âˆˆâ€‰â„¤, d_bâ€‰âˆˆâ€‰â„•_+)

Well-definedness.  No proof.

References.

* https://en.wikipedia.org/wiki/Rational_number#Multiplication
* https://proofwiki.org/wiki/Definition:Multiplication/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qmult"
`;

exports[`render hlm library: 1.6.5.10 data/libraries/hlm/Essentials/Numbers/Rational/quotient 1`] = `
"Definition 1.6.5.10.  Let bâ€‰âˆˆâ€‰â„š, aâ€‰âˆˆâ€‰â„š_Â±. For xâ€‰âˆˆâ€‰â„š, we define:

  b/aâ€…=â€…x â€Š:â‡” â€Šbâ€…=â€…xâ€Šâ‹…â€Ša

Well-definedness.  No proof.

Remarks.

Although it is possible to specify an explicit definition for the division of rational numbers, that definition is not quite as straightforward as one would like because in our definition of rational numbers as pairs of a numerator and a denominator, we force the denominator to be positive.

References.

* https://en.wikipedia.org/wiki/Rational_number#Division
* https://proofwiki.org/wiki/Definition:Division/Rational_Numbers
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qdiv"
`;

exports[`render hlm library: 1.6.5.11 data/libraries/hlm/Essentials/Numbers/Rational/Actual%20quotient%20equals%20formal%20quotient 1`] = `
"Proposition 1.6.5.11.  Let nâ€‰âˆˆâ€‰â„¤, dâ€‰âˆˆâ€‰â„•_+. Then:

  (n/d)â€…=â€…n/d

No proof.

Remarks.

This proposition justifies the notation used for the constructor. Note that the division on the right is division on rational numbers, i.e. on the embedding of the integers _b_ and _a_ into the rational numbers."
`;

exports[`render hlm library: 1.6.5.12 data/libraries/hlm/Essentials/Numbers/Rational/power 1`] = `
"Definition 1.6.5.12.  Let aâ€‰âˆˆâ€‰â„š, nâ€‰âˆˆâ€‰â„•. We define

  a^n

by:

  a^0â€…:=â€…1
  a^(x+1)â€…:=â€…a^xâ€Šâ‹…â€Ša  (xâ€‰âˆˆâ€‰â„•)

References.

* https://en.wikipedia.org/wiki/Rational_number#Exponentiation_to_integer_power
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qpower_positive"
`;

exports[`render hlm library: 1.6.5.13 data/libraries/hlm/Essentials/Numbers/Rational/power%20to%20integer 1`] = `
"Definition 1.6.5.13.  Let aâ€‰âˆˆâ€‰â„š, bâ€‰âˆˆâ€‰â„¤ such that aâ€…â‰ â€…0 or bâ€…â‰¥â€…0. We define:

  a^bâ€…:=â€…{a^b if bâ€…â‰¥â€…0, 1/(a^(âˆ’b)) if bâ€…<â€…0

Remarks.

The exponentiation on the right uses the previous definition, which is possible because the exponents are nonnegative.

References.

* https://en.wikipedia.org/wiki/Rational_number#Exponentiation_to_integer_power
* https://coq.inria.fr/library/Coq.QArith.QArith_base.html#Qpower"
`;

exports[`render hlm library: 1.6.5.14.1 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/converges 1`] = `
"Definition 1.6.5.14.1.  Let ðš be a sequence on â„š, lâ€‰âˆˆâ€‰â„š. We define

  ðš converges to l

by:

  (a_n)_(nâ€Šâˆˆâ€Šâ„•) converges to l â€Š:â‡” â€Šâˆ€â€†Îµâ€‰âˆˆâ€‰â„š_+â€‰: âˆƒâ€†nâ€‰âˆˆâ€‰â„•â€‰: âˆ€â€†mâ€‰âˆˆâ€‰â„•_(â‰¥n)â€‰: |a_mâ€‰âˆ’â€‰l|â€…<â€…Îµ  (a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.5.14.2 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/convergent 1`] = `
"Definition 1.6.5.14.2.  Let ðš be a sequence on â„š. We define:

  ðš is convergent â€Š:â‡” â€Šâˆƒâ€†lâ€‰âˆˆâ€‰â„šâ€‰: ðš converges to l

  ðš is divergent â€Š:â‡” â€Šðš is not convergent"
`;

exports[`render hlm library: 1.6.5.14.3 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/limit 1`] = `
"Definition 1.6.5.14.3.  Let a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•, let ðšâ€‰:=â€‰(a_m)_(mâ€Šâˆˆâ€Šâ„•), assume ðš is convergent. For lâ€‰âˆˆâ€‰â„š, we define:

  lim_(nâ€Šâ†’â€Šâˆž)â€‰a_nâ€…=â€…l â€Š:â‡” â€Šðš converges to l

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.5.14.4 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/cauchy 1`] = `
"Definition 1.6.5.14.4.  Let ðš be a sequence on â„š. We define

  ðš is Cauchy

by:

  (a_n)_(nâ€Šâˆˆâ€Šâ„•) is Cauchy â€Š:â‡” â€Šâˆ€â€†Îµâ€‰âˆˆâ€‰â„š_+â€‰: âˆƒâ€†nâ€‰âˆˆâ€‰â„•â€‰: âˆ€â€†l,â€Šmâ€‰âˆˆâ€‰â„•_(â‰¥n)â€‰: |a_lâ€‰âˆ’â€‰a_m|â€…<â€…Îµ  (a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.5.14.5 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/sequence%20sum 1`] = `
"Definition 1.6.5.14.5.  Let ðš,â€Šð› be sequences on â„š. We define

  ðšâ€‰+â€‰ð›

by:

  (a_n)_(nâ€Šâˆˆâ€Šâ„•)â€‰+â€‰(b_n)_(nâ€Šâˆˆâ€Šâ„•)â€…:=â€…(a_nâ€‰+â€‰b_n)_(nâ€Šâˆˆâ€Šâ„•)  (a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•, b_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.5.14.6 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/sequence%20inverse 1`] = `
"Definition 1.6.5.14.6.  Let ðš be a sequence on â„š. We define

  âˆ’ðš

by:

  âˆ’(a_n)_(nâ€Šâˆˆâ€Šâ„•)â€…:=â€…(âˆ’a_n)_(nâ€Šâˆˆâ€Šâ„•)  (a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.5.14.7 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/sequence%20difference 1`] = `
"Definition 1.6.5.14.7.  Let ð›,â€Šðš be sequences on â„š. We define

  ð›â€‰âˆ’â€‰ðš

by:

  (b_n)_(nâ€Šâˆˆâ€Šâ„•)â€‰âˆ’â€‰(a_n)_(nâ€Šâˆˆâ€Šâ„•)â€…:=â€…(b_nâ€‰âˆ’â€‰a_n)_(nâ€Šâˆˆâ€Šâ„•)  (b_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•, a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•)
  â€…=â€…ð›â€‰+â€‰(âˆ’ðš)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.5.14.8 data/libraries/hlm/Essentials/Numbers/Rational/Sequences/sequence%20product 1`] = `
"Definition 1.6.5.14.8.  Let ðš,â€Šð› be sequences on â„š. We define

  ðšâ€Šâ‹…â€Šð›

by:

  (a_n)_(nâ€Šâˆˆâ€Šâ„•)â€Šâ‹…â€Š(b_n)_(nâ€Šâˆˆâ€Šâ„•)â€…:=â€…(a_nâ€Šâ‹…â€Šb_n)_(nâ€Šâˆˆâ€Šâ„•)  (a_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•, b_nâ€‰âˆˆâ€‰â„š for each nâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.6.1 data/libraries/hlm/Essentials/Numbers/Real/Real%20numbers 1`] = `
"Definition 1.6.6.1.  We define:

  â„â€…:=:â€…{[r] | r is a Cauchy sequence on â„š}

  [r]â€…=â€…[r'] â€Š:â‡” â€Šrâ€‰âˆ’â€‰r' converges to 0  (r is a sequence on â„š, r' is a sequence on â„š with suitable conditions)

  Reflexivity.  No proof.

  Symmetry.  No proof.

  Transitivity.  No proof.

â„šâ€…âŠ†:â€…â„ via
xâ€…=â€…[(x)_(kâ€Šâˆˆâ€Šâ„•)]

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.2 data/libraries/hlm/Essentials/Numbers/Real/sum 1`] = `
"Definition 1.6.6.2.  Let a,â€Šbâ€‰âˆˆâ€‰â„. We define

  aâ€‰+â€‰b

by:

  [r_a]â€‰+â€‰[r_b]â€…:=â€…[r_aâ€‰+â€‰r_b]  (r_a is a sequence on â„š, r_b is a sequence on â„š with suitable conditions)

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.3 data/libraries/hlm/Essentials/Numbers/Real/inverse 1`] = `
"Definition 1.6.6.3.  Let aâ€‰âˆˆâ€‰â„. We define

  âˆ’a

by:

  âˆ’[r_a]â€…:=â€…[âˆ’r_a]  (r_a is a sequence on â„š with suitable conditions)

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.4 data/libraries/hlm/Essentials/Numbers/Real/difference 1`] = `
"Definition 1.6.6.4.  Let b,â€Šaâ€‰âˆˆâ€‰â„. We define

  bâ€‰âˆ’â€‰a

by:

  [r_b]â€‰âˆ’â€‰[r_a]â€…:=â€…[r_bâ€‰âˆ’â€‰r_a]  (r_b is a sequence on â„š, r_a is a sequence on â„š with suitable conditions)
  â€…=â€…bâ€‰+â€‰(âˆ’a)

Equality.  No proof.

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.5 data/libraries/hlm/Essentials/Numbers/Real/less%20or%20equal 1`] = `
"Definition 1.6.6.5.  Let a,â€Šbâ€‰âˆˆâ€‰â„. We define

  aâ€…â‰¤â€…b

by:

  [(x_n)_(nâ€Šâˆˆâ€Šâ„•)]â€…â‰¤â€…[(y_n)_(nâ€Šâˆˆâ€Šâ„•)] â€Š:â‡” â€Šâˆ€â€†Îµâ€‰âˆˆâ€‰â„š_+â€‰: âˆƒâ€†nâ€‰âˆˆâ€‰â„•â€‰: âˆ€â€†mâ€‰âˆˆâ€‰â„•_(â‰¥n)â€‰: x_mâ€…â‰¤â€…y_mâ€‰+â€‰Îµ  ((x_n)_(nâ€Šâˆˆâ€Šâ„•) is a sequence on â„š, (y_n)_(nâ€Šâˆˆâ€Šâ„•) is a sequence on â„š with suitable conditions)

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.6 data/libraries/hlm/Essentials/Numbers/Real/less 1`] = `
"Definition 1.6.6.6.  Let a,â€Šbâ€‰âˆˆâ€‰â„. We define:

  aâ€…<â€…b â€Š:â‡” â€Šaâ€…â‰±â€…b
   â€Šâ‡” â€Šaâ€…â‰¤â€…b and aâ€…â‰ â€…b

Equivalence.  No proof."
`;

exports[`render hlm library: 1.6.6.7.1 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Segment%20(less) 1`] = `
"Definition 1.6.6.7.1.  Let aâ€‰âˆˆâ€‰â„. We define:

  â„_(<a)â€…:=â€…{bâ€‰âˆˆâ€‰â„â€‰: bâ€…<â€…a}"
`;

exports[`render hlm library: 1.6.6.7.2 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Segment%20(less%20or%20equal) 1`] = `
"Definition 1.6.6.7.2.  Let aâ€‰âˆˆâ€‰â„. We define:

  â„_(â‰¤a)â€…:=â€…{bâ€‰âˆˆâ€‰â„â€‰: bâ€…â‰¤â€…a}"
`;

exports[`render hlm library: 1.6.6.7.3 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Segment%20(greater%20or%20equal) 1`] = `
"Definition 1.6.6.7.3.  Let aâ€‰âˆˆâ€‰â„. We define:

  â„_(â‰¥a)â€…:=â€…{bâ€‰âˆˆâ€‰â„â€‰: bâ€…â‰¥â€…a}
  â€…=â€…â„â€…âˆ–â€…â„_(<a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.4 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Segment%20(greater) 1`] = `
"Definition 1.6.6.7.4.  Let aâ€‰âˆˆâ€‰â„. We define:

  â„_(>a)â€…:=â€…{bâ€‰âˆˆâ€‰â„â€‰: bâ€…>â€…a}
  â€…=â€…â„â€…âˆ–â€…â„_(â‰¤a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.5 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Hole 1`] = `
"Definition 1.6.6.7.5.  Let aâ€‰âˆˆâ€‰â„. We define:

  â„_(â‰ a)â€…:=â€…{bâ€‰âˆˆâ€‰â„â€‰: bâ€…â‰ â€…a}
  â€…=â€…â„_(<a)â€…âˆªâ€…â„_(>a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.6 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Negative%20numbers 1`] = `
"Definition 1.6.6.7.6.  We define:

  â„_âˆ’â€…:=â€…â„_(<0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„â€‰: aâ€…<â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.7 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Nonpositive%20numbers 1`] = `
"Definition 1.6.6.7.7.  We define:

  â„_0^âˆ’â€…:=â€…â„_(â‰¤0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„â€‰: aâ€…â‰¤â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.8 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Nonnegative%20numbers 1`] = `
"Definition 1.6.6.7.8.  We define:

  â„_0^+â€…:=â€…â„_(â‰¥0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„â€‰: aâ€…â‰¥â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.9 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Positive%20numbers 1`] = `
"Definition 1.6.6.7.9.  We define:

  â„_+â€…:=â€…â„_(>0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„â€‰: aâ€…>â€…0}

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.7.10 data/libraries/hlm/Essentials/Numbers/Real/Subsets/Nonzero%20numbers 1`] = `
"Definition 1.6.6.7.10.  We define:

  â„_Â±â€…:=â€…â„_(â‰ 0)
  â€…=â€…{aâ€‰âˆˆâ€‰â„â€‰: aâ€…â‰ â€…0}
  â€…=â€…â„_âˆ’â€…âˆªâ€…â„_+

Equality.  No proof."
`;

exports[`render hlm library: 1.6.6.8 data/libraries/hlm/Essentials/Numbers/Real/product 1`] = `
"Definition 1.6.6.8.  Let a,â€Šbâ€‰âˆˆâ€‰â„. We define

  aâ€Šâ‹…â€Šb

by:

  [r_a]â€Šâ‹…â€Š[r_b]â€…:=â€…[r_aâ€Šâ‹…â€Šr_b]  (r_a is a sequence on â„š, r_b is a sequence on â„š with suitable conditions)

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.9 data/libraries/hlm/Essentials/Numbers/Real/quotient 1`] = `
"Definition 1.6.6.9.  Let bâ€‰âˆˆâ€‰â„, aâ€‰âˆˆâ€‰â„_Â±. For xâ€‰âˆˆâ€‰â„, we define:

  b/aâ€…=â€…x â€Š:â‡” â€Šbâ€…=â€…xâ€Šâ‹…â€Ša

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.10 data/libraries/hlm/Essentials/Numbers/Real/power 1`] = `
"Definition 1.6.6.10.  Let aâ€‰âˆˆâ€‰â„, nâ€‰âˆˆâ€‰â„•. We define

  a^n

by:

  a^0â€…:=â€…1
  a^(x+1)â€…:=â€…a^xâ€Šâ‹…â€Ša  (xâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.6.11 data/libraries/hlm/Essentials/Numbers/Real/power%20to%20integer 1`] = `
"Definition 1.6.6.11.  Let aâ€‰âˆˆâ€‰â„, bâ€‰âˆˆâ€‰â„¤ such that aâ€…â‰ â€…0 or bâ€…â‰¥â€…0. We define:

  a^bâ€…:=â€…{a^b if bâ€…â‰¥â€…0, 1/(a^(âˆ’b)) if bâ€…<â€…0"
`;

exports[`render hlm library: 1.6.6.12 data/libraries/hlm/Essentials/Numbers/Real/Power%20base%20product%20law 1`] = `
"Proposition 1.6.6.12.  Let a,â€Šbâ€‰âˆˆâ€‰â„, nâ€‰âˆˆâ€‰â„•. Then:

  (aâ€Šâ‹…â€Šb)^nâ€…=â€…a^nâ€Šâ‹…â€Šb^n

No proof."
`;

exports[`render hlm library: 1.6.6.13 data/libraries/hlm/Essentials/Numbers/Real/Power%20base%20quotient%20law 1`] = `
"Proposition 1.6.6.13.  Let bâ€‰âˆˆâ€‰â„, aâ€‰âˆˆâ€‰â„_Â±, nâ€‰âˆˆâ€‰â„•_+. Then:

  (b/a)^nâ€…=â€…(b^n)/(a^n)

No proof."
`;

exports[`render hlm library: 1.6.6.14 data/libraries/hlm/Essentials/Numbers/Real/root 1`] = `
"Definition 1.6.6.14.  Let aâ€‰âˆˆâ€‰â„_0^+, nâ€‰âˆˆâ€‰â„•. For râ€‰âˆˆâ€‰â„_0^+, we define:

  nâˆšaâ€…=â€…r â€Š:â‡” â€Šaâ€…=â€…r^n

Well-definedness.  No proof."
`;

exports[`render hlm library: 1.6.6.15 data/libraries/hlm/Essentials/Numbers/Real/square%20root 1`] = `
"Definition 1.6.6.15.  Let aâ€‰âˆˆâ€‰â„_0^+. We define:

  âˆšaâ€…:=â€…2âˆša"
`;

exports[`render hlm library: 1.6.6.16 data/libraries/hlm/Essentials/Numbers/Real/rational 1`] = `
"Definition 1.6.6.16.  Let aâ€‰âˆˆâ€‰â„. We define:

  a is rational â€Š:â‡” â€Šaâ€…âˆˆâ€…â„š
   â€Šâ‡” â€Šâˆƒâ€†bâ€‰âˆˆâ€‰â„¤_Â±, câ€‰âˆˆâ€‰â„¤â€‰: aâ€…=â€…c/b
   â€Šâ‡” â€Šâˆƒ!â€†dâ€‰âˆˆâ€‰â„¤_+, eâ€‰âˆˆâ€‰â„¤ s.t. d and e are coprimeâ€‰: aâ€…=â€…e/d

  a is irrational â€Š:â‡” â€Ša is not rational

Equivalence.  No proof."
`;

exports[`render hlm library: 1.6.6.17 data/libraries/hlm/Essentials/Numbers/Real/Roots%20of%20primes%20are%20irrational 1`] = `
"Theorem 1.6.6.17.  Let pâ€‰âˆˆâ€‰â„™, nâ€‰âˆˆâ€‰â„•_(>1). Then:

  nâˆšp is irrational

Proof.  Assume nâˆšp is rational.

â‡’^def âˆƒâ€†aâ€‰âˆˆâ€‰â„¤_+, bâ€‰âˆˆâ€‰â„¤ s.t. a and b are coprimeâ€‰: nâˆšpâ€…=â€…b/a

â‡’^def pâ€…=â€…(b/a)^n

â‡’^1.6.6.13 pâ€…=â€…(b^n)/(a^n)

â‡’^def pâ€Šâ‹…â€Ša^nâ€…=â€…b^n

We have pâ€…âˆ£â€…b^n:

We show that âˆƒâ€†xâ€‰âˆˆâ€‰â„¤â€‰: pâ€Šâ‹…â€Šxâ€…=â€…b^n:

Choose xâ€…:=â€…a^n.

â‡’^1.6.4.22.1 pâ€…âˆ£â€…b

â‡’^def âˆƒâ€†yâ€‰âˆˆâ€‰â„¤â€‰: pâ€Šâ‹…â€Šyâ€…=â€…b

nâ€…âˆˆâ€…â„•_(>1)

â‡’^def nâ€…>â€…1

â‡’^def âˆƒâ€†mâ€‰âˆˆâ€‰â„•_+â€‰: 1â€‰+â€‰mâ€…=â€…n

mâ€…âˆˆâ€…â„•_+

â‡’^def âˆƒâ€†lâ€‰âˆˆâ€‰â„•â€‰: 1â€‰+â€‰lâ€…=â€…m

pâ€Šâ‹…â€Ša^nâ€…=â€…b^n

â‡’^def b^mâ€Šâ‹…â€Šbâ€…=â€…a^nâ€Šâ‹…â€Šp

â‡’^def (b^lâ€Šâ‹…â€Šb)â€Šâ‹…â€Šbâ€…=â€…a^nâ€Šâ‹…â€Šp

â‡’^[pâ‹…yâ€Š=â€Šb] (b^lâ€Šâ‹…â€Š(pâ€Šâ‹…â€Šy))â€Šâ‹…â€Š(pâ€Šâ‹…â€Šy)â€…=â€…a^nâ€Šâ‹…â€Šp

â‡’^1.6.4.20 (b^lâ€Šâ‹…â€Š(pâ€Šâ‹…â€Šy))â€Šâ‹…â€Šyâ€…=â€…a^n

We have pâ€…âˆ£â€…a^n:

We show that âˆƒâ€†zâ€‰âˆˆâ€‰â„¤â€‰: pâ€Šâ‹…â€Šzâ€…=â€…a^n:

Choose zâ€…:=â€…(b^lâ€Šâ‹…â€Šy)â€Šâ‹…â€Šy.

â‡’^1.6.4.22.1 pâ€…âˆ£â€…a

We have âˆƒâ€†qâ€‰âˆˆâ€‰â„™â€‰: [qâ€…âˆ£â€…a and qâ€…âˆ£â€…b]:

Choose qâ€…:=â€…p.

a and b are coprime

â‡’^def âˆ„â€†râ€‰âˆˆâ€‰â„™â€‰: [râ€…âˆ£â€…a and râ€…âˆ£â€…b]

References.

* https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational (for _n_ = 2)
* https://isabelle.in.tum.de/website-Isabelle2012/dist/library/HOL/ex/Sqrt.html (for _n_ = 2)"
`;

exports[`render hlm library: 1.6.6.18 data/libraries/hlm/Essentials/Numbers/Real/Square%20root%20of%20two%20is%20irrational 1`] = `
"Corollary 1.6.6.18.

  âˆš2 is irrational

Proof.

1.6.1.44.2 â‡’ 2 is prime

â‡’^1.6.6.17 2âˆš2 is irrational"
`;

exports[`render hlm library: 1.6.6.19.1 data/libraries/hlm/Essentials/Numbers/Real/Generalized%20sums%20and%20products/inductive%20sum%20(exclusive) 1`] = `
"Definition 1.6.6.19.1.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„ for each iâ€‰âˆˆâ€‰â„•_(<n). We define

  âˆ‘_(iâ€Š<â€Šn)â€‰a_i

by:

  âˆ‘_(iâ€Š<â€Š0)â€‰a_iâ€…:=â€…0
  âˆ‘_(iâ€Š<â€Šm+1)â€‰a_iâ€…:=â€…(âˆ‘_(jâ€Š<â€Šm)â€‰a_j)â€‰+â€‰a_m  (mâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.6.19.2 data/libraries/hlm/Essentials/Numbers/Real/Generalized%20sums%20and%20products/inductive%20product%20(exclusive) 1`] = `
"Definition 1.6.6.19.2.  Let nâ€‰âˆˆâ€‰â„•, let a_iâ€‰âˆˆâ€‰â„ for each iâ€‰âˆˆâ€‰â„•_(<n). We define

  âˆ_(iâ€Š<â€Šn)â€‰a_i

by:

  âˆ_(iâ€Š<â€Š0)â€‰a_iâ€…:=â€…1
  âˆ_(iâ€Š<â€Šm+1)â€‰a_iâ€…:=â€…(âˆ_(jâ€Š<â€Šm)â€‰a_j)â€Šâ‹…â€Ša_m  (mâ€‰âˆˆâ€‰â„•)"
`;

exports[`render hlm library: 1.6.7.1 data/libraries/hlm/Essentials/Numbers/Complex/Complex%20numbers 1`] = `
"Definition 1.6.7.1.  We define:

  â„‚â€…:=:â€…{(r+ið’Š) | r,â€Šiâ€‰âˆˆâ€‰â„}

  (r+ið’Š)â€…=â€…(r'+i'ð’Š) â€Š:â‡” â€Šrâ€…=â€…r' and iâ€…=â€…i'  (r,â€Ši,â€Šr',â€Ši'â€‰âˆˆâ€‰â„)

â„â€…âŠ†:â€…â„‚ via
râ€…=â€…(r+0ð’Š)

Well-definedness.  No proof.

Remarks.

The constructor notation is later justified by a [proposition](Actual%20linear%20combination%20equals%20formal%20linear%20combination)."
`;

exports[`render hlm library: 1.6.7.2 data/libraries/hlm/Essentials/Numbers/Complex/imaginary%20unit 1`] = `
"Definition 1.6.7.2.  We define:

  ð’Šâ€…:=â€…(0+1ð’Š)"
`;

exports[`render hlm library: 1.6.7.3 data/libraries/hlm/Essentials/Numbers/Complex/sum 1`] = `
"Definition 1.6.7.3.  Let a,â€Šbâ€‰âˆˆâ€‰â„‚. We define

  aâ€‰+â€‰b

by:

  (r_a+i_að’Š)â€‰+â€‰(r_b+i_bð’Š)â€…:=â€…((r_aâ€‰+â€‰r_b)+(i_aâ€‰+â€‰i_b)ð’Š)  (r_a,â€Ši_aâ€‰âˆˆâ€‰â„, r_b,â€Ši_bâ€‰âˆˆâ€‰â„)"
`;

exports[`render hlm library: 1.6.7.4 data/libraries/hlm/Essentials/Numbers/Complex/Sum%20is%20associative 1`] = `
"Proposition 1.6.7.4.

  + is associative

No proof."
`;

exports[`render hlm library: 1.6.7.5 data/libraries/hlm/Essentials/Numbers/Complex/Sum%20is%20commutative 1`] = `
"Proposition 1.6.7.5.

  + is commutative

No proof."
`;

exports[`render hlm library: 1.6.7.6 data/libraries/hlm/Essentials/Numbers/Complex/inverse 1`] = `
"Definition 1.6.7.6.  Let aâ€‰âˆˆâ€‰â„‚. We define

  âˆ’a

by:

  âˆ’(r_a+i_að’Š)â€…:=â€…((âˆ’r_a)+(âˆ’i_a)ð’Š)  (r_a,â€Ši_aâ€‰âˆˆâ€‰â„)"
`;

exports[`render hlm library: 1.6.7.7 data/libraries/hlm/Essentials/Numbers/Complex/difference 1`] = `
"Definition 1.6.7.7.  Let b,â€Šaâ€‰âˆˆâ€‰â„‚. We define

  bâ€‰âˆ’â€‰a

by:

  (r_b+i_bð’Š)â€‰âˆ’â€‰(r_a+i_að’Š)â€…:=â€…((r_bâ€‰âˆ’â€‰r_a)+(i_bâ€‰âˆ’â€‰i_a)ð’Š)  (r_b,â€Ši_bâ€‰âˆˆâ€‰â„, r_a,â€Ši_aâ€‰âˆˆâ€‰â„)
  â€…=â€…bâ€‰+â€‰(âˆ’a)

Equality.  No proof."
`;

exports[`render hlm library: 1.6.7.8 data/libraries/hlm/Essentials/Numbers/Complex/product 1`] = `
"Definition 1.6.7.8.  Let a,â€Šbâ€‰âˆˆâ€‰â„‚. We define

  aâ€Šâ‹…â€Šb

by:

  (r_a+i_að’Š)â€Šâ‹…â€Š(r_b+i_bð’Š)â€…:=â€…((r_aâ€Šâ‹…â€Šr_bâ€‰âˆ’â€‰i_aâ€Šâ‹…â€Ši_b)+(r_aâ€Šâ‹…â€Ši_bâ€‰+â€‰i_aâ€Šâ‹…â€Šr_b)ð’Š)  (r_a,â€Ši_aâ€‰âˆˆâ€‰â„, r_b,â€Ši_bâ€‰âˆˆâ€‰â„)"
`;

exports[`render hlm library: 1.6.7.9 data/libraries/hlm/Essentials/Numbers/Complex/Product%20is%20associative 1`] = `
"Proposition 1.6.7.9.

  â‹… is associative

No proof."
`;

exports[`render hlm library: 1.6.7.10 data/libraries/hlm/Essentials/Numbers/Complex/Product%20is%20commutative 1`] = `
"Proposition 1.6.7.10.

  â‹… is commutative

No proof."
`;

exports[`render hlm library: 1.6.7.11 data/libraries/hlm/Essentials/Numbers/Complex/Actual%20linear%20combination%20equals%20formal%20linear%20combination 1`] = `
"Proposition 1.6.7.11.  Let r,â€Šiâ€‰âˆˆâ€‰â„. Then:

  (r+ið’Š)â€…=â€…râ€‰+â€‰iâ€Šâ‹…â€Šð’Š

No proof.

Remarks.

This proposition justifies the notation used for the constructor. Note that the operations on the right are operations on complex numbers, i.e. on the embedding of the real numbers _r_ and _i_ into the complex numbers."
`;

exports[`render hlm library: 2.1.1 data/libraries/hlm/Algebra/Isomorphisms/element%20transform 1`] = `
"Definition 2.1.1.  Let X,â€ŠY be sets, Ï†â€‰:â€‰Xâ€‰â†”â€‰Y be a bijection, xâ€‰âˆˆâ€‰X. We define:

  Ï†[x]â€…:=â€…Ï†(x)

Remarks.

The definitions in this section are somewhat technical. Their purpose is to implement a generic notion of â€œisomorphismâ€ that can be checked purely syntactically. If it can be determined that the equality definition of a constructor does not identify any non-isomorphic objects, definitions based on the decomposition of that constructor are automatically well-defined.

Each of the definitions transforms an object defined on *X* into the equivalent object defined on *Y*, according to the given bijection. The first definition is rather trivial. The other definitions are stated in such a way that the transformation can be identified as a mere relabeling of elements."
`;

exports[`render hlm library: 2.1.2 data/libraries/hlm/Algebra/Isomorphisms/function%20transform 1`] = `
"Definition 2.1.2.  Let X,â€ŠY be sets, Ï†â€‰:â€‰Xâ€‰â†”â€‰Y be a bijection, fâ€‰:â€‰Xâ€‰â†’â€‰X be a function. We define

  Ï†[f]

by:

  Ï†[(Xâ€‰â†’â€‰X, xâ€‰â†¦â€‰z_x)]â€…:=â€…(Yâ€‰â†’â€‰Y, yâ€‰â†¦â€‰Ï†(z_(Ï†^-1(y))))  (z_xâ€‰âˆˆâ€‰X for each xâ€‰âˆˆâ€‰X)
  â€…=â€…Ï†â€‰âˆ˜â€‰(fâ€‰âˆ˜â€‰Ï†^-1)

Equality.  No proof."
`;

exports[`render hlm library: 2.1.3 data/libraries/hlm/Algebra/Isomorphisms/inner%20operation%20transform 1`] = `
"Definition 2.1.3.  Let X,â€ŠY be sets, Ï†â€‰:â€‰Xâ€‰â†”â€‰Y be a bijection, âˆ—â€‰:â€‰Xâ€‰Ã—â€‰Xâ€‰â†’â€‰X be an operation on X. We define

  Ï†[âˆ—]

by:

  Ï†[(Xâ€‰Ã—â€‰Xâ€‰â†’â€‰X, xâ€‰â†¦â€‰z_x)]â€…:=â€…(Yâ€‰Ã—â€‰Yâ€‰â†’â€‰Y, (y_1,â€Šy_2)â€‰â†¦â€‰Ï†(z_(Ï†^-1(y_1),Ï†^-1(y_2))))  (z_xâ€‰âˆˆâ€‰X for each xâ€‰âˆˆâ€‰Xâ€‰Ã—â€‰X)
  â€…=â€…Ï†â€‰âˆ˜â€‰(âˆ—â€‰âˆ˜â€‰(Ï†â€‰Ã—â€‰Ï†)^-1)

Equality.  No proof."
`;

exports[`render hlm library: 2.1.4 data/libraries/hlm/Algebra/Isomorphisms/relation%20transform 1`] = `
"Definition 2.1.4.  Let X,â€ŠY be sets, Ï†â€‰:â€‰Xâ€‰â†”â€‰Y be a bijection, â‰º be a relation on X. We define

  Ï†[â‰º]

by:

  Ï†[[p_x_1,x_2]_(x_1,x_2â€Šâˆˆâ€ŠX)]â€…:=â€…[p_Ï†^-1(y_1),Ï†^-1(y_2)]_(y_1,y_2â€Šâˆˆâ€ŠY)  (p_x_1,x_2 is a proposition for each x_1,â€Šx_2â€‰âˆˆâ€‰X)"
`;

exports[`render hlm library: 2.1.5 data/libraries/hlm/Algebra/Isomorphisms/morphism%20transform 1`] = `
"Definition 2.1.5.  Let X_1,â€ŠX_2,â€ŠX_3,â€ŠY_1,â€ŠY_2,â€ŠY_3 be sets, Ï†_1â€‰:â€‰X_1â€‰â†”â€‰Y_1, Ï†_2â€‰:â€‰X_2â€‰â†”â€‰Y_2, Ï†_3â€‰:â€‰X_3â€‰â†”â€‰Y_3 be bijections, âˆ™â€‰:â€‰X_1â€‰Ã—â€‰X_2â€‰â†’â€‰X_3 be an operation. We define

  (Ï†_1,â€ŠÏ†_2,â€ŠÏ†_3)[âˆ™]

by:

  (Ï†_1,â€ŠÏ†_2,â€ŠÏ†_3)[(X_1â€‰Ã—â€‰X_2â€‰â†’â€‰X_3, xâ€‰â†¦â€‰z_x)]â€…:=â€…(Y_1â€‰Ã—â€‰Y_2â€‰â†’â€‰Y_3, (y_1,â€Šy_2)â€‰â†¦â€‰Ï†_3(z_((Ï†_1)^-1(y_1),(Ï†_2)^-1(y_2))))  (z_xâ€‰âˆˆâ€‰X_3 for each xâ€‰âˆˆâ€‰X_1â€‰Ã—â€‰X_2)
  â€…=â€…Ï†_3â€‰âˆ˜â€‰(âˆ™â€‰âˆ˜â€‰(Ï†_1â€‰Ã—â€‰Ï†_2)^-1)

Equality.  No proof."
`;

exports[`render hlm library: 2.2.1 data/libraries/hlm/Algebra/Pointed%20sets/Pointed%20sets 1`] = `
"Definition 2.2.1.  We define:

  ð“Ÿð“½ð“¢ð“®ð“½â€…:=:â€…{[S,â€Šs] | S is a set, sâ€‰âˆˆâ€‰S}

  [S,â€Šs]â€…=â€…[T,â€Št] â€Š:â‡” â€Šâˆƒâ€†Ï†â€‰:â€‰Sâ€‰â†”â€‰Tâ€‰: Ï†[s]â€…=â€…t  (S is a set, sâ€‰âˆˆâ€‰S, T is a set, tâ€‰âˆˆâ€‰T)

We write â€œlet ð’ be a pointed setâ€ for â€œlet ð’â€‰âˆˆâ€‰ð“Ÿð“½ð“¢ð“®ð“½.â€

Remarks.

Strictly speaking, the elements of this set are not pointed sets but isomorphism classes of pointed sets, which are similar to [cardinal numbers](../../Essentials/Numbers/Cardinal/Cardinal%20numbers). Due to the rules of HLM, it is not even possible to define pointed sets (or other structures) in a way that would distinguish two isomorphic structures. In particular, the requirement to specify an equality definition, together with the way two arbitrary sets are treated as separate types, make sure that in the most general case, equality is in fact the same as isomorphism. (It is possible to identify more structures, but not fewer.)

References.

* https://en.wikipedia.org/wiki/Pointed_set"
`;

exports[`render hlm library: 2.2.2 data/libraries/hlm/Algebra/Pointed%20sets/Carrier 1`] = `
"Definition 2.2.2.  Let ð’ be a pointed set. We define

  Carrier(ð’)

by:

  Carrier([S,â€Šs])â€…:=â€…S  (S is a set, sâ€‰âˆˆâ€‰S)

We write â€œlet xâ€‰âˆˆâ€‰ð’â€ for â€œlet xâ€‰âˆˆâ€‰Carrier(ð’).â€

Remarks.

This definition retrieves a representative carrier set from a pointed set (which is actually an equivalence class of pointed sets), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.2.3 data/libraries/hlm/Algebra/Pointed%20sets/base%20point 1`] = `
"Definition 2.2.3.  Let ð’ be a pointed set. We define

  base(ð’)

by:

  base([S,â€Šs])â€…:=â€…s  (S is a set, sâ€‰âˆˆâ€‰S)"
`;

exports[`render hlm library: 2.2.4 data/libraries/hlm/Algebra/Pointed%20sets/Homomorphisms 1`] = `
"Definition 2.2.4.  Let ð’,â€Šð“ be pointed sets. We define:

  Hom(ð’,â€Šð“)â€…:=â€…{fâ€‰:â€‰Carrier(ð’)â€‰â†’â€‰Carrier(ð“)â€‰: f(base(ð’))â€…=â€…base(ð“)}

We write â€œlet Ï†â€‰:â€‰ð’â€‰â†’â€‰ð“ be a homomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Hom(ð’,â€Šð“).â€"
`;

exports[`render hlm library: 2.2.5 data/libraries/hlm/Algebra/Pointed%20sets/Isomorphisms 1`] = `
"Definition 2.2.5.  Let ð’,â€Šð“ be pointed sets. We define:

  Iso(ð’,â€Šð“)â€…:=â€…{homomorphisms Ï†â€‰:â€‰ð’â€‰â†’â€‰ð“â€‰: Ï† is bijective}
  â€…=â€…{fâ€‰:â€‰Carrier(ð’)â€‰â†”â€‰Carrier(ð“)â€‰: f(base(ð’))â€…=â€…base(ð“)}

We write â€œlet Ï†â€‰:â€‰ð’â€‰â†”â€‰ð“ be an isomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Iso(ð’,â€Šð“).â€

Equality.  No proof."
`;

exports[`render hlm library: 2.2.6 data/libraries/hlm/Algebra/Pointed%20sets/identity 1`] = `
"Definition 2.2.6.  Let ð’ be a pointed set. We define:

  id_ð’â€…:=â€…id_(Carrier(ð’))"
`;

exports[`render hlm library: 2.2.7 data/libraries/hlm/Algebra/Pointed%20sets/Equality%20criterion 1`] = `
"Proposition 2.2.7.  Let ð’,â€Šð“ be pointed sets. Then the following are equivalent:

  1. Iso(ð’,â€Šð“) is nonempty
  2. ð’â€…=â€…ð“

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of pointed sets."
`;

exports[`render hlm library: 2.2.8 data/libraries/hlm/Algebra/Pointed%20sets/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.2.8.  Let ð’,â€Šð“ be pointed sets, Ï†â€‰:â€‰ð’â€‰â†”â€‰ð“ be an isomorphism. Then:

  Ï†^-1â€…âˆˆâ€…Iso(ð“,â€Šð’)

No proof."
`;

exports[`render hlm library: 2.2.9 data/libraries/hlm/Algebra/Pointed%20sets/subset%20of%20pointed%20set 1`] = `
"Definition 2.2.9.  Let ð’ be a pointed set, Sâ€‰âŠ†â€‰Carrier(ð’). We define:

  S is a pointed subset of ð’ â€Š:â‡” â€Šbase(ð’)â€…âˆˆâ€…S"
`;

exports[`render hlm library: 2.2.10 data/libraries/hlm/Algebra/Pointed%20sets/subset%20as%20pointed%20set 1`] = `
"Definition 2.2.10.  Let ð’ be a pointed set, Sâ€‰âŠ†â€‰Carrier(ð’) such that S is a pointed subset of ð’. We define:

  [S]â€…:=â€…[S,â€Šbase(ð’)]"
`;

exports[`render hlm library: 2.2.11 data/libraries/hlm/Algebra/Pointed%20sets/pointed%20subset 1`] = `
"Definition 2.2.11.  Let ð’,â€Šð“ be pointed sets. We define:

  ð’â€…â‰¤â€…ð“ â€Š:â‡” â€Šâˆƒâ€†homomorphism Ï†â€‰:â€‰ð’â€‰â†’â€‰ð“â€‰: Ï† is injective
   â€Šâ‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð“)â€‰: [S is a pointed subset of ð“ and ð’â€…=â€…[S]]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.3.1 data/libraries/hlm/Algebra/Magmas/Magmas 1`] = `
"Definition 2.3.1.  We define:

  ð“œð“ªð“°â€…:=:â€…{[S,â€Šâˆ—] | S is a set, âˆ—â€‰:â€‰Sâ€‰Ã—â€‰Sâ€‰â†’â€‰S is an operation on S}

  [S,â€Šâˆ—]â€…=â€…[T,â€Šâ‹†] â€Š:â‡” â€Šâˆƒâ€†Ï†â€‰:â€‰Sâ€‰â†”â€‰Tâ€‰: Ï†[âˆ—]â€…=â€…â‹†  (S is a set, âˆ—â€‰:â€‰Sâ€‰Ã—â€‰Sâ€‰â†’â€‰S is an operation on S, T is a set, â‹†â€‰:â€‰Tâ€‰Ã—â€‰Tâ€‰â†’â€‰T is an operation on T)

We write â€œlet ðŒ be a magmaâ€ for â€œlet ðŒâ€‰âˆˆâ€‰ð“œð“ªð“°.â€

Remarks.

Strictly speaking, the elements of this set are not magmas but isomorphism classes of magmas. Due to the rules of HLM, it is not even possible to define magmas (or other structures) in a way that would distinguish two isomorphic structures. In particular, the requirement to specify an equality definition, together with the way two arbitrary sets are treated as separate types, make sure that in the most general case, equality is in fact the same as isomorphism. (It is possible to identify more structures, but not fewer.)

References.

* https://en.wikipedia.org/wiki/Magma_(algebra)"
`;

exports[`render hlm library: 2.3.2 data/libraries/hlm/Algebra/Magmas/Carrier 1`] = `
"Definition 2.3.2.  Let ðŒ be a magma. We define

  Carrier(ðŒ)

by:

  Carrier([M,â€Šâˆ—])â€…:=â€…M  (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M)

We write â€œlet aâ€‰âˆˆâ€‰ðŒâ€ for â€œlet aâ€‰âˆˆâ€‰Carrier(ðŒ).â€

Remarks.

This definition retrieves a representative carrier set from a magma (which is actually an equivalence class of magmas), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.3.3 data/libraries/hlm/Algebra/Magmas/operation 1`] = `
"Definition 2.3.3.  Let ðŒ be a magma, a,â€Šbâ€‰âˆˆâ€‰ðŒ. We define:

  aâ€‰â€¢â€‰bâ€…:=â€…{aâ€‰âˆ—â€‰b if ðŒâ€…=â€…[M,â€Šâˆ—] (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M)

Remarks.

This definition lets us multiply elements without decomposing the magma."
`;

exports[`render hlm library: 2.3.4 data/libraries/hlm/Algebra/Magmas/associative 1`] = `
"Definition 2.3.4.  Let ðŒ be a magma. We define

  ðŒ is associative

by:

  [M,â€Šâˆ—] is associative â€Š:â‡” â€Šâˆ— is associative  (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M)"
`;

exports[`render hlm library: 2.3.5 data/libraries/hlm/Algebra/Magmas/commutative 1`] = `
"Definition 2.3.5.  Let ðŒ be a magma. We define

  ðŒ is commutative

by:

  [M,â€Šâˆ—] is commutative â€Š:â‡” â€Šâˆ— is commutative  (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M)"
`;

exports[`render hlm library: 2.3.6 data/libraries/hlm/Algebra/Magmas/Homomorphisms 1`] = `
"Definition 2.3.6.  Let ðŒ,â€Šð be magmas. We define:

  Hom(ðŒ,â€Šð)â€…:=â€…{fâ€‰:â€‰Carrier(ðŒ)â€‰â†’â€‰Carrier(ð)â€‰: âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ðŒâ€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)}

We write â€œlet Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ð be a homomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Hom(ðŒ,â€Šð).â€"
`;

exports[`render hlm library: 2.3.7 data/libraries/hlm/Algebra/Magmas/Isomorphisms 1`] = `
"Definition 2.3.7.  Let ðŒ,â€Šð be magmas. We define:

  Iso(ðŒ,â€Šð)â€…:=â€…{homomorphisms Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ðâ€‰: Ï† is bijective}
  â€…=â€…{fâ€‰:â€‰Carrier(ðŒ)â€‰â†”â€‰Carrier(ð)â€‰: âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ðŒâ€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)}

We write â€œlet Ï†â€‰:â€‰ðŒâ€‰â†”â€‰ð be an isomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Iso(ðŒ,â€Šð).â€

Equality.  No proof."
`;

exports[`render hlm library: 2.3.8 data/libraries/hlm/Algebra/Magmas/identity 1`] = `
"Definition 2.3.8.  Let ðŒ be a magma. We define:

  id_ðŒâ€…:=â€…id_(Carrier(ðŒ))"
`;

exports[`render hlm library: 2.3.9 data/libraries/hlm/Algebra/Magmas/Equality%20criterion 1`] = `
"Proposition 2.3.9.  Let ðŒ,â€Šð be magmas. Then the following are equivalent:

  1. Iso(ðŒ,â€Šð) is nonempty
  2. ðŒâ€…=â€…ð

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of magmas."
`;

exports[`render hlm library: 2.3.10 data/libraries/hlm/Algebra/Magmas/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.3.10.  Let ðŒ,â€Šð be magmas, Ï†â€‰:â€‰ðŒâ€‰â†”â€‰ð be an isomorphism. Then:

  Ï†^-1â€…âˆˆâ€…Iso(ð,â€ŠðŒ)

No proof."
`;

exports[`render hlm library: 2.3.11 data/libraries/hlm/Algebra/Magmas/submagma%20set 1`] = `
"Definition 2.3.11.  Let ðŒ be a magma, Sâ€‰âŠ†â€‰Carrier(ðŒ). We define:

  S is a submagma of ðŒ â€Š:â‡” â€Šâˆ€â€†a,â€Šbâ€‰âˆˆâ€‰Sâ€‰: aâ€‰â€¢â€‰bâ€…âˆˆâ€…S"
`;

exports[`render hlm library: 2.3.12 data/libraries/hlm/Algebra/Magmas/subset%20magma 1`] = `
"Definition 2.3.12.  Let ðŒ be a magma, Sâ€‰âŠ†â€‰Carrier(ðŒ) such that S is a submagma of ðŒ. We define:

  [S]â€…:=â€…{[S,â€Šâˆ—âˆ£_S] if ðŒâ€…=â€…[M,â€Šâˆ—] (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M)"
`;

exports[`render hlm library: 2.3.13 data/libraries/hlm/Algebra/Magmas/submagma 1`] = `
"Definition 2.3.13.  Let ðŒ,â€Šð be magmas. We define:

  ðŒâ€…â‰¤â€…ð â€Š:â‡” â€Šâˆƒâ€†homomorphism Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ðâ€‰: Ï† is injective
   â€Šâ‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð)â€‰: [S is a submagma of ð and ðŒâ€…=â€…[S]]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.3.14.1 data/libraries/hlm/Algebra/Magmas/Free%20magma/Binary%20trees 1`] = `
"Definition 2.3.14.1.  Let S be a set. We define:

  ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S)â€…:=:â€…{(s) | sâ€‰âˆˆâ€‰S, a^b | a,â€Šbâ€‰âˆˆâ€‰ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S)}

  (s)â€…=â€…(s') â€Š:â‡” â€Šsâ€…=â€…s'  (s,â€Šs'â€‰âˆˆâ€‰S)

  a^bâ€…=â€…a'^b' â€Š:â‡” â€Šaâ€…=â€…a' and bâ€…=â€…b'  (a,â€Šb,â€Ša',â€Šb'â€‰âˆˆâ€‰ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S))

Sâ€…âŠ†:â€…ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S) via
xâ€…=â€…(x)

Well-definedness.  No proof.

For S'â€‰âŠ†â€‰S, we canonically treat elements of ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S') as elements of ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S).

Remarks.

This is an inductive definition of binary trees with leafs labeled by elements of _S_. It does not really belong in this section but is required for the definition of a free magma."
`;

exports[`render hlm library: 2.3.14.2 data/libraries/hlm/Algebra/Magmas/Free%20magma/free%20magma 1`] = `
"Definition 2.3.14.2.  Let S be a set, Tâ€‰:=â€‰ð“‘ð“²ð“·ð“£ð“»ð“®ð“®(S). We define:

  free_ð“œð“°ð“¶(S)â€…:=â€…[T,â€Š(Tâ€‰Ã—â€‰Tâ€‰â†’â€‰T, (a,â€Šb)â€‰â†¦â€‰a^b)]"
`;

exports[`render hlm library: 2.3.14.3 data/libraries/hlm/Algebra/Magmas/Free%20magma/free%20on%20set 1`] = `
"Definition 2.3.14.3.  Let ðŒ be a magma, Sâ€‰âŠ†â€‰Carrier(ðŒ). We define:

  ðŒ is free on S â€Š:â‡” â€ŠðŒâ€…=â€…free_ð“œð“°ð“¶(S)
   â€Šâ‡” â€Šâˆ€â€†magmas ð, fâ€‰:â€‰Sâ€‰â†’â€‰Carrier(ð)â€‰: âˆƒ!â€†homomorphism Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ðâ€‰: Ï†âˆ£_Sâ€…=â€…f

Equivalence.  No proof."
`;

exports[`render hlm library: 2.3.14.4 data/libraries/hlm/Algebra/Magmas/Free%20magma/free 1`] = `
"Definition 2.3.14.4.  Let ðŒ be a magma. We define:

  ðŒ is free â€Š:â‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ðŒ)â€‰: ðŒ is free on S"
`;

exports[`render hlm library: 2.4.1 data/libraries/hlm/Algebra/Semigroups/Semigroups 1`] = `
"Definition 2.4.1.  We define:

  ð“¢ð“®ð“¶ð“²ð“–ð“»ð“¹â€…:=â€…{magmas ð’â€‰: ð’ is associative}

We write â€œlet ð’ be a semigroupâ€ for â€œlet ð’â€‰âˆˆâ€‰ð“¢ð“®ð“¶ð“²ð“–ð“»ð“¹.â€

References.

* https://en.wikipedia.org/wiki/Semigroup"
`;

exports[`render hlm library: 2.5.1 data/libraries/hlm/Algebra/Monoids/Monoids 1`] = `
"Definition 2.5.1.  We define:

  ð“œð“¸ð“·â€…:=:â€…{[S,â€Šâˆ—,â€Še] | S is a set, âˆ—â€‰:â€‰Sâ€‰Ã—â€‰Sâ€‰â†’â€‰S is an associative operation on S, eâ€‰âˆˆâ€‰S such that [âˆ€â€†aâ€‰âˆˆâ€‰Sâ€‰: [aâ€‰âˆ—â€‰eâ€…=â€…a and eâ€‰âˆ—â€‰aâ€…=â€…a]]}

  [S,â€Šâˆ—,â€Še]â€…=â€…[T,â€Šâ‹†,â€Šf] â€Š:â‡” â€Šâˆƒâ€†Ï†â€‰:â€‰Sâ€‰â†”â€‰Tâ€‰: [Ï†[âˆ—]â€…=â€…â‹† and Ï†[e]â€…=â€…f]  (S is a set, âˆ—â€‰:â€‰Sâ€‰Ã—â€‰Sâ€‰â†’â€‰S is an operation on S, eâ€‰âˆˆâ€‰S, T is a set, â‹†â€‰:â€‰Tâ€‰Ã—â€‰Tâ€‰â†’â€‰T is an operation on T, fâ€‰âˆˆâ€‰T with suitable conditions)

We write â€œlet ðŒ be a monoidâ€ for â€œlet ðŒâ€‰âˆˆâ€‰ð“œð“¸ð“·.â€

References.

* https://en.wikipedia.org/wiki/Monoid"
`;

exports[`render hlm library: 2.5.2 data/libraries/hlm/Algebra/Monoids/Carrier 1`] = `
"Definition 2.5.2.  Let ðŒ be a monoid. We define

  Carrier(ðŒ)

by:

  Carrier([M,â€Šâˆ—,â€Še])â€…:=â€…M  (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M, eâ€‰âˆˆâ€‰M with suitable conditions)

We write â€œlet aâ€‰âˆˆâ€‰ðŒâ€ for â€œlet aâ€‰âˆˆâ€‰Carrier(ðŒ).â€

Remarks.

This definition retrieves a representative carrier set from a monoid (which is actually an equivalence class of monoids), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.5.3 data/libraries/hlm/Algebra/Monoids/operation 1`] = `
"Definition 2.5.3.  Let ðŒ be a monoid, a,â€Šbâ€‰âˆˆâ€‰ðŒ. We define:

  aâ€‰â€¢â€‰bâ€…:=â€…{aâ€‰âˆ—â€‰b if ðŒâ€…=â€…[M,â€Šâˆ—,â€Še] (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M, eâ€‰âˆˆâ€‰M with suitable conditions)

Remarks.

This definition lets us multiply elements without decomposing the monoid."
`;

exports[`render hlm library: 2.5.4 data/libraries/hlm/Algebra/Monoids/identity%20element 1`] = `
"Definition 2.5.4.  Let ðŒ be a monoid. We define

  1_ðŒ

by:

  1_[M,âˆ—,e]â€…:=â€…e  (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M, eâ€‰âˆˆâ€‰M with suitable conditions)"
`;

exports[`render hlm library: 2.5.5 data/libraries/hlm/Algebra/Monoids/commutative 1`] = `
"Definition 2.5.5.  Let ðŒ be a monoid. We define

  ðŒ is commutative

by:

  [M,â€Šâˆ—,â€Še] is commutative â€Š:â‡” â€Šâˆ— is commutative  (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M, eâ€‰âˆˆâ€‰M with suitable conditions)"
`;

exports[`render hlm library: 2.5.6 data/libraries/hlm/Algebra/Monoids/Homomorphisms 1`] = `
"Definition 2.5.6.  Let ðŒ,â€Šð be monoids. We define:

  Hom(ðŒ,â€Šð)â€…:=â€…{fâ€‰:â€‰Carrier(ðŒ)â€‰â†’â€‰Carrier(ð)â€‰: [âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ðŒâ€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)] and f(1_ðŒ)â€…=â€…1_ð}

We write â€œlet Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ð be a homomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Hom(ðŒ,â€Šð).â€"
`;

exports[`render hlm library: 2.5.7 data/libraries/hlm/Algebra/Monoids/Isomorphisms 1`] = `
"Definition 2.5.7.  Let ðŒ,â€Šð be monoids. We define:

  Iso(ðŒ,â€Šð)â€…:=â€…{homomorphisms Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ðâ€‰: Ï† is bijective}
  â€…=â€…{fâ€‰:â€‰Carrier(ðŒ)â€‰â†”â€‰Carrier(ð)â€‰: [âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ðŒâ€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)] and f(1_ðŒ)â€…=â€…1_ð}

We write â€œlet Ï†â€‰:â€‰ðŒâ€‰â†”â€‰ð be an isomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Iso(ðŒ,â€Šð).â€

Equality.  No proof."
`;

exports[`render hlm library: 2.5.8 data/libraries/hlm/Algebra/Monoids/identity 1`] = `
"Definition 2.5.8.  Let ðŒ be a monoid. We define:

  id_ðŒâ€…:=â€…id_(Carrier(ðŒ))"
`;

exports[`render hlm library: 2.5.9 data/libraries/hlm/Algebra/Monoids/Equality%20criterion 1`] = `
"Proposition 2.5.9.  Let ðŒ,â€Šð be monoids. Then the following are equivalent:

  1. Iso(ðŒ,â€Šð) is nonempty
  2. ðŒâ€…=â€…ð

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of monoids."
`;

exports[`render hlm library: 2.5.10 data/libraries/hlm/Algebra/Monoids/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.5.10.  Let ðŒ,â€Šð be monoids, Ï†â€‰:â€‰ðŒâ€‰â†”â€‰ð be an isomorphism. Then:

  Ï†^-1â€…âˆˆâ€…Iso(ð,â€ŠðŒ)

No proof."
`;

exports[`render hlm library: 2.5.11 data/libraries/hlm/Algebra/Monoids/submonoid%20set 1`] = `
"Definition 2.5.11.  Let ðŒ be a monoid, Sâ€‰âŠ†â€‰Carrier(ðŒ). We define:

  S is a submonoid of ðŒ â€Š:â‡” â€Š[âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰Sâ€‰: aâ€‰â€¢â€‰bâ€…âˆˆâ€…S] and 1_ðŒâ€…âˆˆâ€…S"
`;

exports[`render hlm library: 2.5.12 data/libraries/hlm/Algebra/Monoids/subset%20monoid 1`] = `
"Definition 2.5.12.  Let ðŒ be a monoid, Sâ€‰âŠ†â€‰Carrier(ðŒ) such that S is a submonoid of ðŒ. We define:

  [S]â€…:=â€…{[S,â€Šâˆ—âˆ£_S,â€Še] if ðŒâ€…=â€…[M,â€Šâˆ—,â€Še] (M is a set, âˆ—â€‰:â€‰Mâ€‰Ã—â€‰Mâ€‰â†’â€‰M is an operation on M, eâ€‰âˆˆâ€‰M with suitable conditions)"
`;

exports[`render hlm library: 2.5.13 data/libraries/hlm/Algebra/Monoids/submonoid 1`] = `
"Definition 2.5.13.  Let ðŒ,â€Šð be monoids. We define:

  ðŒâ€…â‰¤â€…ð â€Š:â‡” â€Šâˆƒâ€†homomorphism Ï†â€‰:â€‰ðŒâ€‰â†’â€‰ðâ€‰: Ï† is injective
   â€Šâ‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð)â€‰: [S is a submonoid of ð and ðŒâ€…=â€…[S]]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.5.14.1 data/libraries/hlm/Algebra/Monoids/Examples/Natural%20numbers%20with%20addition 1`] = `
"Definition 2.5.14.1.  We define:

  (â„•,â€Š+)â€…:=â€…[â„•,â€Š+,â€Š0]"
`;

exports[`render hlm library: 2.5.14.2 data/libraries/hlm/Algebra/Monoids/Examples/Natural%20numbers%20with%20multiplication 1`] = `
"Definition 2.5.14.2.  We define:

  (â„•,â€Šâ‹…)â€…:=â€…[â„•,â€Šâ‹…,â€Š1]"
`;

exports[`render hlm library: 2.6.1 data/libraries/hlm/Algebra/Groups/Groups 1`] = `
"Definition 2.6.1.  We define:

  ð“–ð“»ð“¹â€…:=:â€…{[S,â€Šâˆ—,â€Še,â€Ši] | S is a set, âˆ—â€‰:â€‰Sâ€‰Ã—â€‰Sâ€‰â†’â€‰S is an associative operation on S, eâ€‰âˆˆâ€‰S such that [âˆ€â€†aâ€‰âˆˆâ€‰Sâ€‰: [aâ€‰âˆ—â€‰eâ€…=â€…a and eâ€‰âˆ—â€‰aâ€…=â€…a]], iâ€‰:â€‰Sâ€‰â†’â€‰S is a function such that [âˆ€â€†aâ€‰âˆˆâ€‰Sâ€‰: [aâ€‰âˆ—â€‰i(a)â€…=â€…e and i(a)â€‰âˆ—â€‰aâ€…=â€…e]]}

  [S,â€Šâˆ—,â€Še,â€Ši]â€…=â€…[T,â€Šâ‹†,â€Šf,â€Šj] â€Š:â‡” â€Šâˆƒâ€†Ï†â€‰:â€‰Sâ€‰â†”â€‰Tâ€‰: [Ï†[âˆ—]â€…=â€…â‹† and Ï†[e]â€…=â€…f and Ï†[i]â€…=â€…j]  (S is a set, âˆ—â€‰:â€‰Sâ€‰Ã—â€‰Sâ€‰â†’â€‰S is an operation on S, eâ€‰âˆˆâ€‰S, iâ€‰:â€‰Sâ€‰â†’â€‰S is a function, T is a set, â‹†â€‰:â€‰Tâ€‰Ã—â€‰Tâ€‰â†’â€‰T is an operation on T, fâ€‰âˆˆâ€‰T, jâ€‰:â€‰Tâ€‰â†’â€‰T is a function with suitable conditions)

We write â€œlet ð† be a groupâ€ for â€œlet ð†â€‰âˆˆâ€‰ð“–ð“»ð“¹.â€

References.

* https://en.wikipedia.org/wiki/Group_(mathematics)"
`;

exports[`render hlm library: 2.6.2 data/libraries/hlm/Algebra/Groups/Carrier 1`] = `
"Definition 2.6.2.  Let ð† be a group. We define

  Carrier(ð†)

by:

  Carrier([G,â€Šâˆ—,â€Še,â€Ši])â€…:=â€…G  (G is a set, âˆ—â€‰:â€‰Gâ€‰Ã—â€‰Gâ€‰â†’â€‰G is an operation on G, eâ€‰âˆˆâ€‰G, iâ€‰:â€‰Gâ€‰â†’â€‰G is a function with suitable conditions)

We write â€œlet aâ€‰âˆˆâ€‰ð†â€ for â€œlet aâ€‰âˆˆâ€‰Carrier(ð†).â€

Remarks.

This definition retrieves a representative carrier set from a group (which is actually an equivalence class of groups), and enables typical abuse of notation."
`;

exports[`render hlm library: 2.6.3 data/libraries/hlm/Algebra/Groups/operation 1`] = `
"Definition 2.6.3.  Let ð† be a group, a,â€Šbâ€‰âˆˆâ€‰ð†. We define:

  aâ€‰â€¢â€‰bâ€…:=â€…{aâ€‰âˆ—â€‰b if ð†â€…=â€…[G,â€Šâˆ—,â€Še,â€Ši] (G is a set, âˆ—â€‰:â€‰Gâ€‰Ã—â€‰Gâ€‰â†’â€‰G is an operation on G, eâ€‰âˆˆâ€‰G, iâ€‰:â€‰Gâ€‰â†’â€‰G is a function with suitable conditions)

Remarks.

This definition lets us multiply elements without decomposing the group."
`;

exports[`render hlm library: 2.6.4 data/libraries/hlm/Algebra/Groups/identity%20element 1`] = `
"Definition 2.6.4.  Let ð† be a group. We define

  1_ð†

by:

  1_[G,âˆ—,e,i]â€…:=â€…e  (G is a set, âˆ—â€‰:â€‰Gâ€‰Ã—â€‰Gâ€‰â†’â€‰G is an operation on G, eâ€‰âˆˆâ€‰G, iâ€‰:â€‰Gâ€‰â†’â€‰G is a function with suitable conditions)"
`;

exports[`render hlm library: 2.6.5 data/libraries/hlm/Algebra/Groups/inverse%20element 1`] = `
"Definition 2.6.5.  Let ð† be a group, aâ€‰âˆˆâ€‰ð†. We define:

  a^-1â€…:=â€…{i(a) if ð†â€…=â€…[G,â€Šâˆ—,â€Še,â€Ši] (G is a set, âˆ—â€‰:â€‰Gâ€‰Ã—â€‰Gâ€‰â†’â€‰G is an operation on G, eâ€‰âˆˆâ€‰G, iâ€‰:â€‰Gâ€‰â†’â€‰G is a function with suitable conditions)"
`;

exports[`render hlm library: 2.6.6 data/libraries/hlm/Algebra/Groups/abelian 1`] = `
"Definition 2.6.6.  Let ð† be a group. We define

  ð† is abelian

by:

  [G,â€Šâˆ—,â€Še,â€Ši] is abelian â€Š:â‡” â€Šâˆ— is commutative  (G is a set, âˆ—â€‰:â€‰Gâ€‰Ã—â€‰Gâ€‰â†’â€‰G is an operation on G, eâ€‰âˆˆâ€‰G, iâ€‰:â€‰Gâ€‰â†’â€‰G is a function with suitable conditions)"
`;

exports[`render hlm library: 2.6.7 data/libraries/hlm/Algebra/Groups/Homomorphisms 1`] = `
"Definition 2.6.7.  Let ð†,â€Šð‡ be groups. We define:

  Hom(ð†,â€Šð‡)â€…:=â€…{fâ€‰:â€‰Carrier(ð†)â€‰â†’â€‰Carrier(ð‡)â€‰: [âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ð†â€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)] and f(1_ð†)â€…=â€…1_ð‡ and âˆ€â€†câ€‰âˆˆâ€‰ð†â€‰: f(c^-1)â€…=â€…(f(c))^-1}
  â€…=â€…{fâ€‰:â€‰Carrier(ð†)â€‰â†’â€‰Carrier(ð‡)â€‰: âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ð†â€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)}

We write â€œlet Ï†â€‰:â€‰ð†â€‰â†’â€‰ð‡ be a homomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Hom(ð†,â€Šð‡).â€

Equality.  No proof."
`;

exports[`render hlm library: 2.6.8 data/libraries/hlm/Algebra/Groups/Isomorphisms 1`] = `
"Definition 2.6.8.  Let ð†,â€Šð‡ be groups. We define:

  Iso(ð†,â€Šð‡)â€…:=â€…{homomorphisms Ï†â€‰:â€‰ð†â€‰â†’â€‰ð‡â€‰: Ï† is bijective}
  â€…=â€…{fâ€‰:â€‰Carrier(ð†)â€‰â†”â€‰Carrier(ð‡)â€‰: âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰ð†â€‰: f(aâ€‰â€¢â€‰b)â€…=â€…f(a)â€‰â€¢â€‰f(b)}

We write â€œlet Ï†â€‰:â€‰ð†â€‰â†”â€‰ð‡ be an isomorphismâ€ for â€œlet Ï†â€‰âˆˆâ€‰Iso(ð†,â€Šð‡).â€

Equality.  No proof."
`;

exports[`render hlm library: 2.6.9 data/libraries/hlm/Algebra/Groups/Kernel 1`] = `
"Definition 2.6.9.  Let ð†,â€Šð‡ be groups, Ï†â€‰:â€‰ð†â€‰â†’â€‰ð‡ be a homomorphism. We define:

  Ker(Ï†)â€…:=â€…{gâ€‰âˆˆâ€‰ð†â€‰: Ï†(g)â€…=â€…1_ð‡}"
`;

exports[`render hlm library: 2.6.10 data/libraries/hlm/Algebra/Groups/identity 1`] = `
"Definition 2.6.10.  Let ð† be a group. We define:

  id_ð†â€…:=â€…id_(Carrier(ð†))"
`;

exports[`render hlm library: 2.6.11 data/libraries/hlm/Algebra/Groups/Equality%20criterion 1`] = `
"Proposition 2.6.11.  Let ð†,â€Šð‡ be groups. Then the following are equivalent:

  1. Iso(ð†,â€Šð‡) is nonempty
  2. ð†â€…=â€…ð‡

No proof.

Remarks.

This follows immediately from the HLM-specific definition of equality of groups."
`;

exports[`render hlm library: 2.6.12 data/libraries/hlm/Algebra/Groups/Inverse%20of%20isomorphism%20is%20also%20isomorphism 1`] = `
"Proposition 2.6.12.  Let ð†,â€Šð‡ be groups, Ï†â€‰:â€‰ð†â€‰â†”â€‰ð‡ be an isomorphism. Then:

  Ï†^-1â€…âˆˆâ€…Iso(ð‡,â€Šð†)

No proof."
`;

exports[`render hlm library: 2.6.13 data/libraries/hlm/Algebra/Groups/subgroup%20set 1`] = `
"Definition 2.6.13.  Let ð† be a group, Sâ€‰âŠ†â€‰Carrier(ð†). We define:

  S is a subgroup of ð† â€Š:â‡” â€Š[âˆ€â€†a,â€Šbâ€‰âˆˆâ€‰Sâ€‰: aâ€‰â€¢â€‰bâ€…âˆˆâ€…S] and 1_ð†â€…âˆˆâ€…S and âˆ€â€†câ€‰âˆˆâ€‰Sâ€‰: c^-1â€…âˆˆâ€…S"
`;

exports[`render hlm library: 2.6.14 data/libraries/hlm/Algebra/Groups/subset%20group 1`] = `
"Definition 2.6.14.  Let ð† be a group, Sâ€‰âŠ†â€‰Carrier(ð†) such that S is a subgroup of ð†. We define:

  [S]â€…:=â€…{[S,â€Šâˆ—âˆ£_S,â€Še,â€Šiâˆ£_S^S] if ð†â€…=â€…[G,â€Šâˆ—,â€Še,â€Ši] (G is a set, âˆ—â€‰:â€‰Gâ€‰Ã—â€‰Gâ€‰â†’â€‰G is an operation on G, eâ€‰âˆˆâ€‰G, iâ€‰:â€‰Gâ€‰â†’â€‰G is a function with suitable conditions)"
`;

exports[`render hlm library: 2.6.15 data/libraries/hlm/Algebra/Groups/subgroup 1`] = `
"Definition 2.6.15.  Let ð†,â€Šð‡ be groups. We define:

  ð†â€…â‰¤â€…ð‡ â€Š:â‡” â€Šâˆƒâ€†homomorphism Ï†â€‰:â€‰ð†â€‰â†’â€‰ð‡â€‰: Ï† is injective
   â€Šâ‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð‡)â€‰: [S is a subgroup of ð‡ and ð†â€…=â€…[S]]

Equivalence.  No proof."
`;

exports[`render hlm library: 2.6.16 data/libraries/hlm/Algebra/Groups/normal%20subgroup%20set 1`] = `
"Definition 2.6.16.  Let ð† be a group, Sâ€‰âŠ†â€‰Carrier(ð†). We define:

  S is a normal subgroup of ð† â€Š:â‡” â€ŠS is a subgroup of ð† and âˆ€â€†sâ€‰âˆˆâ€‰S, gâ€‰âˆˆâ€‰ð†â€‰: (gâ€‰â€¢â€‰s)â€‰â€¢â€‰g^-1â€…âˆˆâ€…S
   â€Šâ‡” â€Šâˆƒâ€†group ð‡, homomorphism Ï†â€‰:â€‰ð†â€‰â†’â€‰ð‡â€‰: Sâ€…=â€…Ker(Ï†)

Equivalence.  No proof."
`;

exports[`render hlm library: 2.6.17 data/libraries/hlm/Algebra/Groups/normal%20subgroup 1`] = `
"Definition 2.6.17.  Let ð†,â€Šð‡ be groups. We define:

  ð†â€…âŠ´â€…ð‡ â€Š:â‡” â€Šâˆƒâ€†Sâ€‰âŠ†â€‰Carrier(ð‡)â€‰: [S is a normal subgroup of ð‡ and ð†â€…=â€…[S]]"
`;

exports[`render hlm library: 2.6.18 data/libraries/hlm/Algebra/Groups/quotient%20group 1`] = `
"Definition 2.6.18.  Let ð† be a group, Sâ€‰âŠ†â€‰Carrier(ð†) such that S is a normal subgroup of ð†, âˆ¼â€‰:=â€‰[âˆƒâ€†sâ€‰âˆˆâ€‰Sâ€‰: gâ€‰â€¢â€‰sâ€…=â€…h]_(g,hâ€Šâˆˆâ€ŠCarrier(ð†)), Tâ€‰:=â€‰Carrier(ð†)âˆ•âˆ¼. We define:

  ð†âˆ•Sâ€…:=â€…[T,â€Š(Tâ€‰Ã—â€‰Tâ€‰â†’â€‰T, xâ€‰â†¦â€‰{{{[gâ€‰â€¢â€‰h]_âˆ¼ if uâ€…=â€…[h]_âˆ¼ (hâ€‰âˆˆâ€‰ð†) if tâ€…=â€…[g]_âˆ¼ (gâ€‰âˆˆâ€‰ð†) if xâ€…=â€…(t,â€Šu) (tâ€‰âˆˆâ€‰T, uâ€‰âˆˆâ€‰T)),â€Š[1_ð†]_âˆ¼,â€Š(Tâ€‰â†’â€‰T, tâ€‰â†¦â€‰{[g^-1]_âˆ¼ if tâ€…=â€…[g]_âˆ¼ (gâ€‰âˆˆâ€‰ð†))]"
`;

exports[`render hlm library: 3.1.1 data/libraries/hlm/Linear%20algebra/Essentials/Matrices 1`] = `
"Definition 3.1.1.  Let S be a set, m,â€Šnâ€‰âˆˆâ€‰â„•. We define:

  S^(mÃ—n)â€…:=:â€…{(a_i,j)_iâ€Š<â€Šm,jâ€Š<â€Šn | a_i,jâ€‰âˆˆâ€‰S for each iâ€‰âˆˆâ€‰â„•_(<m) and jâ€‰âˆˆâ€‰â„•_(<n)}

  (a_i,j)_iâ€Š<â€Šm,jâ€Š<â€Šnâ€…=â€…(b_i,j)_iâ€Š<â€Šm,jâ€Š<â€Šn â€Š:â‡” â€Šâˆ€â€†iâ€‰âˆˆâ€‰â„•_(<m), jâ€‰âˆˆâ€‰â„•_(<n)â€‰: a_i,jâ€…=â€…b_i,j  (a_i,jâ€‰âˆˆâ€‰S for each iâ€‰âˆˆâ€‰â„•_(<m) and jâ€‰âˆˆâ€‰â„•_(<n), b_i,jâ€‰âˆˆâ€‰S for each iâ€‰âˆˆâ€‰â„•_(<m) and jâ€‰âˆˆâ€‰â„•_(<n))

For S'â€‰âŠ†â€‰S, we canonically treat elements of S'^(mÃ—n) as elements of S^(mÃ—n)."
`;

exports[`render hlm library: 3.1.2 data/libraries/hlm/Linear%20algebra/Essentials/Vectors 1`] = `
"Definition 3.1.2.  Let S be a set, nâ€‰âˆˆâ€‰â„•. We define:

  S^nâ€…:=â€…S^(1Ã—n)"
`;

exports[`render hlm library: 4.1 data/libraries/hlm/Category%20theory/Categories 1`] = `
"Definition 4.1.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ð“’ð“ªð“½_uâ€…:=:â€…{[O, (M_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠO), (i_ð‚)_(ð‚â€Šâˆˆâ€ŠO), (âˆ˜_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠO)]_u | O is a set, M_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰O, i_ð‚â€‰âˆˆâ€‰M_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰O, âˆ˜_ðƒ,ð„,ð…â€‰:â€‰M_ð„,ð…â€‰Ã—â€‰M_ðƒ,ð„â€‰â†’â€‰M_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰O, [âˆ€â€†ð–,â€Šð—,â€Šð˜,â€Šð™â€‰âˆˆâ€‰O, fâ€‰âˆˆâ€‰M_ð–,ð—, gâ€‰âˆˆâ€‰M_ð—,ð˜, hâ€‰âˆˆâ€‰M_ð˜,ð™â€‰: (hâ€‰âˆ˜_ð—,ð˜,ð™â€‰g)â€‰âˆ˜_ð–,ð—,ð™â€‰fâ€…=â€…hâ€‰âˆ˜_ð–,ð˜,ð™â€‰(gâ€‰âˆ˜_ð–,ð—,ð˜â€‰f)], [âˆ€â€†ð—,â€Šð˜â€‰âˆˆâ€‰O, fâ€‰âˆˆâ€‰M_ð—,ð˜â€‰: [i_ð˜â€‰âˆ˜_ð—,ð˜,ð˜â€‰fâ€…=â€…f and fâ€‰âˆ˜_ð—,ð—,ð˜â€‰i_ð—â€…=â€…f]], [âˆ€â€†ð—,â€Šð˜â€‰âˆˆâ€‰O s.t. [âˆƒâ€†fâ€‰âˆˆâ€‰M_ð—,ð˜, gâ€‰âˆˆâ€‰M_ð˜,ð—â€‰: [fâ€‰âˆ˜_ð˜,ð—,ð˜â€‰gâ€…=â€…i_ð˜ and gâ€‰âˆ˜_ð—,ð˜,ð—â€‰fâ€…=â€…i_ð—]]â€‰: ð—â€…=â€…ð˜]}

  [O, (M_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠO), (i_ð‚)_(ð‚â€Šâˆˆâ€ŠO), (âˆ˜_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠO)]_uâ€…=â€…[P, (N_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠP), (j_ð‚)_(ð‚â€Šâˆˆâ€ŠP), (âˆ™_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠP)]_u â€Š:â‡” â€Šâˆƒâ€†Ï†â€‰:â€‰Oâ€‰â†”â€‰P, Ïˆ_ð€,ðâ€‰:â€‰M_ð€,ðâ€‰â†”â€‰N_Ï†[ð€],Ï†[ð] f.e. ð€,â€Šðâ€‰âˆˆâ€‰Oâ€‰: [[âˆ€â€†ð‚â€‰âˆˆâ€‰Oâ€‰: Ïˆ_ð‚,ð‚[i_ð‚]â€…=â€…j_(Ï†[ð‚])] and âˆ€â€†ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰Oâ€‰: (Ïˆ_ð„,ð…,â€ŠÏˆ_ðƒ,ð„,â€ŠÏˆ_ðƒ,ð…)[âˆ˜_ðƒ,ð„,ð…]â€…=â€…âˆ™_Ï†[ðƒ],Ï†[ð„],Ï†[ð…]]  (O is a set, M_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰O, i_ð‚â€‰âˆˆâ€‰M_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰O, âˆ˜_ðƒ,ð„,ð…â€‰:â€‰M_ð„,ð…â€‰Ã—â€‰M_ðƒ,ð„â€‰â†’â€‰M_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰O, P is a set, N_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰P, j_ð‚â€‰âˆˆâ€‰N_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰P, âˆ™_ðƒ,ð„,ð…â€‰:â€‰N_ð„,ð…â€‰Ã—â€‰N_ðƒ,ð„â€‰â†’â€‰N_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰P with suitable conditions)

We write â€œlet ð“’ be a u-small categoryâ€ for â€œlet ð“’â€‰âˆˆâ€‰ð“’ð“ªð“½_u.â€

Remarks.

This definition of categories includes the additional requirement that all categories are [skeletal](https://en.wikipedia.org/wiki/Skeleton_(category_theory)). The reasoning behind this is that I expect the equality definition above, which is derived purely syntactically, to be equivalent to _isomorphism_ of categories, not _equivalence_. That is, without this restriction, two isomorphic categories would be considered equal, but two equivalent categories would not necessarily be. (This needs to be verified.)

For skeletal categories, the two concepts coincide. Since in HLM, all of the usual examples of categories happen to be skeletal anyway, and we care about equivalence much more than isomorphism, it makes sense to include this requirement directly in the definition of a category.

The natural number _u_ is required to be able to define a category of (smaller) categories or functors, which would otherwise be prevented by non-circularity rules. Informally, _u_ can be regarded as a â€œuniverse sizeâ€ that is relevant only in the context of category theory. (The â€œuniversesâ€ that are implicit in other contexts are already large enough.)

References.

* https://en.wikipedia.org/wiki/Category_(mathematics)
* http://mathworld.wolfram.com/Category.html
* https://proofwiki.org/wiki/Definition:Category
* https://ncatlab.org/nlab/show/category"
`;

exports[`render hlm library: 4.2 data/libraries/hlm/Category%20theory/Objects 1`] = `
"Definition 4.2.  Let uâ€‰âˆˆâ€‰â„•, ð“’ be a u-small category. We define

  Ob(ð“’)

by:

  Ob([O, (M_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠO), (i_ð‚)_(ð‚â€Šâˆˆâ€ŠO), (âˆ˜_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠO)]_u)â€…:=â€…O  (O is a set, M_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰O, i_ð‚â€‰âˆˆâ€‰M_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰O, âˆ˜_ðƒ,ð„,ð…â€‰:â€‰M_ð„,ð…â€‰Ã—â€‰M_ðƒ,ð„â€‰â†’â€‰M_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰O with suitable conditions)

We write â€œlet ð—â€‰âˆˆâ€‰ð“’â€ for â€œlet ð—â€‰âˆˆâ€‰Ob(ð“’).â€

Remarks.

This definition retrieves a representative set of objects from a category (which is actually an equivalence class of categories), and enables typical abuse of notation."
`;

exports[`render hlm library: 4.3 data/libraries/hlm/Category%20theory/Morphisms 1`] = `
"Definition 4.3.  Let uâ€‰âˆˆâ€‰â„•, ð“’ be a u-small category, ð—,â€Šð˜â€‰âˆˆâ€‰ð“’. We define:

  (ð—â€‰â†’â€‰ð˜)â€…:=â€…{M_ð—,ð˜ if ð“’â€…=â€…[O, (M_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠO), (i_ð‚)_(ð‚â€Šâˆˆâ€ŠO), (âˆ˜_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠO)]_u (O is a set, M_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰O, i_ð‚â€‰âˆˆâ€‰M_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰O, âˆ˜_ðƒ,ð„,ð…â€‰:â€‰M_ð„,ð…â€‰Ã—â€‰M_ðƒ,ð„â€‰â†’â€‰M_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰O with suitable conditions)

We write â€œlet Fâ€‰:â€‰ð—â€‰â†’â€‰ð˜ be a morphismâ€ for â€œlet Fâ€‰âˆˆâ€‰(ð—â€‰â†’â€‰ð˜).â€

References.

* https://en.wikipedia.org/wiki/Morphism
* http://mathworld.wolfram.com/Morphism.html
* https://proofwiki.org/wiki/Definition:Morphism
* https://ncatlab.org/nlab/show/morphism"
`;

exports[`render hlm library: 4.4 data/libraries/hlm/Category%20theory/identity 1`] = `
"Definition 4.4.  Let uâ€‰âˆˆâ€‰â„•, ð“’ be a u-small category, ð—â€‰âˆˆâ€‰ð“’. We define:

  id_ð—â€…:=â€…{i_ð— if ð“’â€…=â€…[O, (M_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠO), (i_ð‚)_(ð‚â€Šâˆˆâ€ŠO), (âˆ˜_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠO)]_u (O is a set, M_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰O, i_ð‚â€‰âˆˆâ€‰M_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰O, âˆ˜_ðƒ,ð„,ð…â€‰:â€‰M_ð„,ð…â€‰Ã—â€‰M_ðƒ,ð„â€‰â†’â€‰M_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰O with suitable conditions)

References.

* https://proofwiki.org/wiki/Definition:Identity_Morphism"
`;

exports[`render hlm library: 4.5 data/libraries/hlm/Category%20theory/composition 1`] = `
"Definition 4.5.  Let uâ€‰âˆˆâ€‰â„•, ð“’ be a u-small category, ð—,â€Šð˜,â€Šð™â€‰âˆˆâ€‰ð“’, fâ€‰:â€‰ð—â€‰â†’â€‰ð˜, gâ€‰:â€‰ð˜â€‰â†’â€‰ð™ be morphisms. We define:

  gâ€‰âˆ˜â€‰fâ€…:=â€…{gâ€‰âˆ˜_ð—,ð˜,ð™â€‰f if ð“’â€…=â€…[O, (M_ð€,ð)_(ð€,ðâ€Šâˆˆâ€ŠO), (i_ð‚)_(ð‚â€Šâˆˆâ€ŠO), (âˆ˜_ðƒ,ð„,ð…)_(ðƒ,ð„,ð…â€Šâˆˆâ€ŠO)]_u (O is a set, M_ð€,ð is a set for each ð€,â€Šðâ€‰âˆˆâ€‰O, i_ð‚â€‰âˆˆâ€‰M_ð‚,ð‚ for each ð‚â€‰âˆˆâ€‰O, âˆ˜_ðƒ,ð„,ð…â€‰:â€‰M_ð„,ð…â€‰Ã—â€‰M_ðƒ,ð„â€‰â†’â€‰M_ðƒ,ð… is an operation for each ðƒ,â€Šð„,â€Šð…â€‰âˆˆâ€‰O with suitable conditions)

References.

* https://proofwiki.org/wiki/Definition:Composition_of_Morphisms"
`;

exports[`render hlm library: 4.6.1 data/libraries/hlm/Category%20theory/Functors/Functors 1`] = `
"Definition 4.6.1.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories. We define:

  (ð“’â€‰â†’â€‰ð““)â€…:=:â€…{(ð“’â€‰â†’â€‰ð““, ð—â€‰â†¦â€‰ðƒ_ð—, (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰d_ð˜,ð™,f) | ðƒ_ð—â€‰âˆˆâ€‰ð““ for each ð—â€‰âˆˆâ€‰ð“’, d_ð˜,ð™,fâ€‰:â€‰ðƒ_ð˜â€‰â†’â€‰ðƒ_ð™ is a morphism for each ð˜,â€Šð™â€‰âˆˆâ€‰ð“’ and fâ€‰:â€‰ð˜â€‰â†’â€‰ð™, [âˆ€â€†ð—â€‰âˆˆâ€‰ð“’â€‰: d_ð—,ð—,id_ð—â€…=â€…id_(ðƒ_ð—)], [âˆ€â€†ð—,â€Šð˜,â€Šð™â€‰âˆˆâ€‰ð“’, fâ€‰:â€‰ð—â€‰â†’â€‰ð˜, gâ€‰:â€‰ð˜â€‰â†’â€‰ð™â€‰: d_ð—,ð™,gâˆ˜fâ€…=â€…d_ð˜,ð™,gâ€‰âˆ˜â€‰d_ð—,ð˜,f]}

  (ð“’â€‰â†’â€‰ð““, ð—â€‰â†¦â€‰ðƒ_ð—, (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰d_ð˜,ð™,f)â€…=â€…(ð“’â€‰â†’â€‰ð““, ð—â€‰â†¦â€‰ðƒ'_ð—, (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰d'_ð˜,ð™,f) â€Š:â‡” â€Š[âˆ€â€†ð—â€‰âˆˆâ€‰ð“’â€‰: ðƒ_ð—â€…=â€…ðƒ'_ð—] and âˆ€â€†ð˜,â€Šð™â€‰âˆˆâ€‰ð“’, fâ€‰:â€‰ð˜â€‰â†’â€‰ð™â€‰: d_ð˜,ð™,fâ€…=â€…d'_ð˜,ð™,f  (ðƒ_ð—â€‰âˆˆâ€‰ð““ for each ð—â€‰âˆˆâ€‰ð“’, d_ð˜,ð™,fâ€‰:â€‰ðƒ_ð˜â€‰â†’â€‰ðƒ_ð™ is a morphism for each ð˜,â€Šð™â€‰âˆˆâ€‰ð“’ and fâ€‰:â€‰ð˜â€‰â†’â€‰ð™, ðƒ'_ð—â€‰âˆˆâ€‰ð““ for each ð—â€‰âˆˆâ€‰ð“’, d'_ð˜,ð™,fâ€‰:â€‰ðƒ'_ð˜â€‰â†’â€‰ðƒ'_ð™ is a morphism for each ð˜,â€Šð™â€‰âˆˆâ€‰ð“’ and fâ€‰:â€‰ð˜â€‰â†’â€‰ð™ with suitable conditions)

We write â€œlet Fâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be a functorâ€ for â€œlet Fâ€‰âˆˆâ€‰(ð“’â€‰â†’â€‰ð““).â€

We write â€œlet Fâ€‰:â€‰â€Šð“’â€‰â†’â€‰ð““, ð—â€‰â†¦â€‰ðƒ_ð—, (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰d_ð˜,ð™,fâ€ for â€œlet Fâ€‰:=â€‰(ð“’â€‰â†’â€‰ð““, ð—â€‰â†¦â€‰ðƒ_ð—, (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰d_ð˜,ð™,f).â€

Remarks.

This definition requires both categories to live in a common universe, which is not strictly required.

References.

* https://en.wikipedia.org/wiki/Functor
* http://mathworld.wolfram.com/Functor.html
* https://proofwiki.org/wiki/Definition:Functor
* https://ncatlab.org/nlab/show/functor"
`;

exports[`render hlm library: 4.6.2 data/libraries/hlm/Category%20theory/Functors/object%20value 1`] = `
"Definition 4.6.2.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, Fâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be a functor, ð—â€‰âˆˆâ€‰ð“’. We define

  F(ð—)

by:

  (ð“’â€‰â†’â€‰ð““, ð€â€‰â†¦â€‰ðƒ_ð€, (fâ€‰:â€‰ðâ€‰â†’â€‰ð‚)â€‰â†¦â€‰d_ð,ð‚,f)(ð—)â€…:=â€…ðƒ_ð—  (ðƒ_ð€â€‰âˆˆâ€‰ð““ for each ð€â€‰âˆˆâ€‰ð“’, d_ð,ð‚,fâ€‰:â€‰ðƒ_ðâ€‰â†’â€‰ðƒ_ð‚ is a morphism for each ð,â€Šð‚â€‰âˆˆâ€‰ð“’ and fâ€‰:â€‰ðâ€‰â†’â€‰ð‚ with suitable conditions)"
`;

exports[`render hlm library: 4.6.3 data/libraries/hlm/Category%20theory/Functors/morphism%20value 1`] = `
"Definition 4.6.3.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, Fâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be a functor, ð˜,â€Šð™â€‰âˆˆâ€‰ð“’, fâ€‰:â€‰ð˜â€‰â†’â€‰ð™ be a morphism. We define

  F(f)

by:

  (ð“’â€‰â†’â€‰ð““, ð€â€‰â†¦â€‰ðƒ_ð€, (gâ€‰:â€‰ðâ€‰â†’â€‰ð‚)â€‰â†¦â€‰d_ð,ð‚,g)(f)â€…:=â€…d_ð˜,ð™,f  (ðƒ_ð€â€‰âˆˆâ€‰ð““ for each ð€â€‰âˆˆâ€‰ð“’, d_ð,ð‚,gâ€‰:â€‰ðƒ_ðâ€‰â†’â€‰ðƒ_ð‚ is a morphism for each ð,â€Šð‚â€‰âˆˆâ€‰ð“’ and gâ€‰:â€‰ðâ€‰â†’â€‰ð‚ with suitable conditions)"
`;

exports[`render hlm library: 4.6.4 data/libraries/hlm/Category%20theory/Functors/identity 1`] = `
"Definition 4.6.4.  Let uâ€‰âˆˆâ€‰â„•, ð“’ be a u-small category. We define:

  id_ð“’â€‰:â€‰â€Šð“’â€‰â†’â€‰ð“’, ð—â€‰â†¦â€‰ð—, (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰f"
`;

exports[`render hlm library: 4.6.5 data/libraries/hlm/Category%20theory/Functors/composition 1`] = `
"Definition 4.6.5.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““,â€Šð“” be u-small categories, Fâ€‰:â€‰ð“’â€‰â†’â€‰ð““, Gâ€‰:â€‰ð““â€‰â†’â€‰ð“” be functors. We define:

  Gâ€‰âˆ˜â€‰Fâ€‰:â€‰â€Šð“’â€‰â†’â€‰ð“”, ð—â€‰â†¦â€‰G(F(ð—)), (fâ€‰:â€‰ð˜â€‰â†’â€‰ð™)â€‰â†¦â€‰G(F(f))"
`;

exports[`render hlm library: 4.7.1 data/libraries/hlm/Category%20theory/Natural%20transformations/Infranatural%20transformations 1`] = `
"Definition 4.7.1.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, F,â€ŠGâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be functors. We define:

  (Fâ€‰â‡€â€‰G)â€…:=:â€…{(n_ð—)_(ð—â€Šâˆˆâ€Šð“’) | n_ð—â€‰:â€‰F(ð—)â€‰â†’â€‰G(ð—) is a morphism for each ð—â€‰âˆˆâ€‰ð“’}

  (n_ð—)_(ð—â€Šâˆˆâ€Šð“’)â€…=â€…(m_ð—)_(ð—â€Šâˆˆâ€Šð“’) â€Š:â‡” â€Šâˆ€â€†ð—â€‰âˆˆâ€‰ð“’â€‰: n_ð—â€…=â€…m_ð—  (n_ð—â€‰:â€‰F(ð—)â€‰â†’â€‰G(ð—) is a morphism for each ð—â€‰âˆˆâ€‰ð“’, m_ð—â€‰:â€‰F(ð—)â€‰â†’â€‰G(ð—) is a morphism for each ð—â€‰âˆˆâ€‰ð“’)

We write â€œlet Î·â€‰:â€‰Fâ€‰â‡€â€‰G be an infranatural transformationâ€ for â€œlet Î·â€‰âˆˆâ€‰(Fâ€‰â‡€â€‰G).â€

References.

* https://en.wikipedia.org/wiki/Natural_transformation"
`;

exports[`render hlm library: 4.7.2 data/libraries/hlm/Category%20theory/Natural%20transformations/component 1`] = `
"Definition 4.7.2.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, F,â€ŠGâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be functors, Î·â€‰:â€‰Fâ€‰â‡€â€‰G be an infranatural transformation, ð—â€‰âˆˆâ€‰ð“’. We define

  Î·_ð—

by:

  ((n_ð˜)_(ð˜â€Šâˆˆâ€Šð“’))_ð—â€…:=â€…n_ð—  (n_ð˜â€‰:â€‰F(ð˜)â€‰â†’â€‰G(ð˜) is a morphism for each ð˜â€‰âˆˆâ€‰ð“’)"
`;

exports[`render hlm library: 4.7.3 data/libraries/hlm/Category%20theory/Natural%20transformations/identity 1`] = `
"Definition 4.7.3.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, Fâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be a functor. We define:

  id_Fâ€…:=â€…(id_(F(ð—)))_(ð—â€Šâˆˆâ€Šð“’)
  â€…=â€…(F(id_ð—))_(ð—â€Šâˆˆâ€Šð“’)

Equality.  No proof."
`;

exports[`render hlm library: 4.7.4 data/libraries/hlm/Category%20theory/Natural%20transformations/vertical%20composition 1`] = `
"Definition 4.7.4.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, F,â€ŠG,â€ŠHâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be functors, Î·â€‰:â€‰Fâ€‰â‡€â€‰G, Îµâ€‰:â€‰Gâ€‰â‡€â€‰H be infranatural transformations. We define:

  Îµâ€‰âˆ˜â€‰Î·â€…:=â€…(Îµ_ð—â€‰âˆ˜â€‰Î·_ð—)_(ð—â€Šâˆˆâ€Šð“’)

References.

* https://en.wikipedia.org/wiki/Natural_transformation#Operations_with_natural_transformations"
`;

exports[`render hlm library: 4.7.5 data/libraries/hlm/Category%20theory/Natural%20transformations/Natural%20transformations 1`] = `
"Definition 4.7.5.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories, F,â€ŠGâ€‰:â€‰ð“’â€‰â†’â€‰ð““ be functors. We define:

  (Fâ€‰â‡’â€‰G)â€…:=â€…{Î·â€‰:â€‰Fâ€‰â‡€â€‰Gâ€‰: âˆ€â€†ð—,â€Šð˜â€‰âˆˆâ€‰ð“’, fâ€‰:â€‰ð—â€‰â†’â€‰ð˜â€‰: Î·_ð˜â€‰âˆ˜â€‰F(f)â€…=â€…G(f)â€‰âˆ˜â€‰Î·_ð—}

We write â€œlet Î·â€‰:â€‰Fâ€‰â‡’â€‰G be a natural transformationâ€ for â€œlet Î·â€‰âˆˆâ€‰(Fâ€‰â‡’â€‰G).â€

References.

* https://en.wikipedia.org/wiki/Natural_transformation
* http://mathworld.wolfram.com/NaturalTransformation.html
* https://proofwiki.org/wiki/Definition:Natural_Transformation
* https://ncatlab.org/nlab/show/natural+transformation"
`;

exports[`render hlm library: 4.8.1 data/libraries/hlm/Category%20theory/Individual%20categories/elements 1`] = `
"Definition 4.8.1.  Let uâ€‰âˆˆâ€‰â„•, S be a set. We define:

  ð„ð¥ðžð¦_u(S)â€…:=â€…[S, ({a}â€…âˆ©â€…{b})_(a,bâ€Šâˆˆâ€ŠS), (c)_(câ€Šâˆˆâ€ŠS), (({e}â€…âˆ©â€…{f})â€‰Ã—â€‰({d}â€…âˆ©â€…{e})â€‰â†’â€‰({d}â€…âˆ©â€…{f}), xâ€‰â†¦â€‰e)_(d,e,fâ€Šâˆˆâ€ŠS)]_u

Remarks.

This is one possible formalization of the discrete category obtained from elements of _S_. Note that the existence of an _x_ in the definition of morphism composition implies that _d_=_e_=_f_.

References.

* https://en.wikipedia.org/wiki/Discrete_category
* https://ncatlab.org/nlab/show/discrete+category#CategoricalMeaning"
`;

exports[`render hlm library: 4.8.2 data/libraries/hlm/Category%20theory/Individual%20categories/cardinals 1`] = `
"Definition 4.8.2.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ð’ðžð­_uâ€…:=â€…[ð“’ð“»ð“­, (Hom(ð€,â€Šð))_(ð€,ðâ€Šâˆˆâ€Šð“’ð“»ð“­), (id_ð‚)_(ð‚â€Šâˆˆâ€Šð“’ð“»ð“­), (âˆ˜)_(ðƒ,ð„,ð…â€Šâˆˆâ€Šð“’ð“»ð“­)]_u

Remarks.

The objects of this category are actually isomorphism classes of sets, i.e. cardinal numbers. In HLM, arbitrary sets cannot be used as objects because it is impossible to ask whether two arbitrary sets are equal. However, cardinal numbers work fine as a replacement. The situation with other categories is similar.

References.

* https://en.wikipedia.org/wiki/Category_of_sets
* https://ncatlab.org/nlab/show/Set"
`;

exports[`render hlm library: 4.8.3 data/libraries/hlm/Category%20theory/Individual%20categories/ordinals 1`] = `
"Definition 4.8.3.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ð–ð¨ð¬ðžð­_uâ€…:=â€…[ð“žð“»ð“­, (Hom(ð€,â€Šð))_(ð€,ðâ€Šâˆˆâ€Šð“žð“»ð“­), (id_ð‚)_(ð‚â€Šâˆˆâ€Šð“žð“»ð“­), (âˆ˜)_(ðƒ,ð„,ð…â€Šâˆˆâ€Šð“žð“»ð“­)]_u

Remarks.

The objects of this category are actually isomorphism classes of well-ordered sets, i.e. ordinal numbers."
`;

exports[`render hlm library: 4.8.4 data/libraries/hlm/Category%20theory/Individual%20categories/magmas 1`] = `
"Definition 4.8.4.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ðŒðšð _uâ€…:=â€…[ð“œð“ªð“°, (Hom(ð€,â€Šð))_(ð€,ðâ€Šâˆˆâ€Šð“œð“ªð“°), (id_ð‚)_(ð‚â€Šâˆˆâ€Šð“œð“ªð“°), (âˆ˜)_(ðƒ,ð„,ð…â€Šâˆˆâ€Šð“œð“ªð“°)]_u

Remarks.

The objects of this category are actually isomorphism classes of magmas.

References.

* https://en.wikipedia.org/wiki/Category_of_magmas"
`;

exports[`render hlm library: 4.8.5 data/libraries/hlm/Category%20theory/Individual%20categories/monoids 1`] = `
"Definition 4.8.5.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ðŒð¨ð§_uâ€…:=â€…[ð“œð“¸ð“·, (Hom(ð€,â€Šð))_(ð€,ðâ€Šâˆˆâ€Šð“œð“¸ð“·), (id_ð‚)_(ð‚â€Šâˆˆâ€Šð“œð“¸ð“·), (âˆ˜)_(ðƒ,ð„,ð…â€Šâˆˆâ€Šð“œð“¸ð“·)]_u

Remarks.

The objects of this category are actually isomorphism classes of monoids."
`;

exports[`render hlm library: 4.8.6 data/libraries/hlm/Category%20theory/Individual%20categories/groups 1`] = `
"Definition 4.8.6.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ð†ð«ð©_uâ€…:=â€…[ð“–ð“»ð“¹, (Hom(ð€,â€Šð))_(ð€,ðâ€Šâˆˆâ€Šð“–ð“»ð“¹), (id_ð‚)_(ð‚â€Šâˆˆâ€Šð“–ð“»ð“¹), (âˆ˜)_(ðƒ,ð„,ð…â€Šâˆˆâ€Šð“–ð“»ð“¹)]_u

Remarks.

The objects of this category are actually isomorphism classes of groups."
`;

exports[`render hlm library: 4.8.7 data/libraries/hlm/Category%20theory/Individual%20categories/categories 1`] = `
"Definition 4.8.7.  Let uâ€‰âˆˆâ€‰â„•. We define:

  ð‚ðšð­(u)â€…:=â€…[ð“’ð“ªð“½_u, (ð“â€‰â†’â€‰ð“‘)_(ð“,ð“‘â€Šâˆˆâ€Šð“’ð“ªð“½_u), (id_ð“’)_(ð“’â€Šâˆˆâ€Šð“’ð“ªð“½_u), (âˆ˜)_(ð““,ð“”,ð“•â€Šâˆˆâ€Šð“’ð“ªð“½_u)]_(u+1)

Remarks.

This defines the category of small categories, or, more generally, a category in _V_ of all categories in _U_.

References.

* https://en.wikipedia.org/wiki/Category_of_small_categories
* https://ncatlab.org/nlab/show/Cat"
`;

exports[`render hlm library: 4.8.8 data/libraries/hlm/Category%20theory/Individual%20categories/functors 1`] = `
"Definition 4.8.8.  Let uâ€‰âˆˆâ€‰â„•, ð“’,â€Šð““ be u-small categories. We define:

  ð…ð®ð§(ð“’,â€Šð““)â€…:=â€…[ð“’â€‰â†’â€‰ð““, (Aâ€‰â‡’â€‰B)_(A,Bâ€Šâˆˆâ€Š(ð“’â†’ð““)), (id_C)_(Câ€Šâˆˆâ€Š(ð“’â†’ð““)), (âˆ˜)_(D,E,Fâ€Šâˆˆâ€Š(ð“’â†’ð““))]_(u+1)

References.

* https://en.wikipedia.org/wiki/Functor_category
* https://ncatlab.org/nlab/show/functor+category"
`;

exports[`render hlm library: 5.1 data/libraries/hlm/Formal%20systems/Variables 1`] = `
"Definition 5.1.  We define:

  ð“¥ð“ªð“»â€…:=:â€…{(n) | nâ€‰âˆˆâ€‰â„•}

  (m)â€…=â€…(n) â€Š:â‡” â€Šmâ€…=â€…n  (m,â€Šnâ€‰âˆˆâ€‰â„•)

Remarks.

This definition formalizes an infinite supply of variables. Each variable is identified by a natural number, but that number is not used anywhere. In fact, any infinite set would do.

Therefore, variables in the modelled language do not carry a name. Instead, we use bound variables in HLM (i.e. in the meta language) to model variables in the target language, and these bound variables have a name in HLM.

As a consequence, Î±-equivalent terms are never distinguishable."
`;

exports[`render hlm library: 5.2 data/libraries/hlm/Formal%20systems/Fresh%20variables 1`] = `
"Definition 5.2.  Let Vâ€‰âŠ†â€‰ð“¥ð“ªð“» such that V is finite. We define:

  Fresh(V)â€…:=â€…ð“¥ð“ªð“»â€…âˆ–â€…V

Remarks.

This is just the subset of variables that do not appear in _V_. It should be used whenever a new bound variable is needed."
`;

exports[`render hlm library: 5.3 data/libraries/hlm/Formal%20systems/Rewriting%20rules 1`] = `
"Definition 5.3.  Let T be a set. We define:

  ð“¡ð“®ð”€ð“»(T)â€…:=:â€…{lâ€‰â†’â€‰r | l,â€Šrâ€‰âˆˆâ€‰T}

  (lâ€‰â†’â€‰r)â€…=â€…(l'â€‰â†’â€‰r') â€Š:â‡” â€Šlâ€…=â€…l' and râ€…=â€…r'  (l,â€Šr,â€Šl',â€Šr'â€‰âˆˆâ€‰T)

For T'â€‰âŠ†â€‰T, we canonically treat elements of ð“¡ð“®ð”€ð“»(T') as elements of ð“¡ð“®ð”€ð“»(T).

Remarks.

This definition just provides some useful notation for rewriting rules for terms in _T_. It is actually equivalent to the Cartesian product of _T_ with itself."
`;

exports[`render hlm library: 5.4.1 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/Terms 1`] = `
"Definition 5.4.1.  Let Vâ€‰âŠ†â€‰ð“¥ð“ªð“» such that V is finite. We define:

  ð“£_Vâ€…:=:â€…{(x) | xâ€‰âˆˆâ€‰V, Î»x.â€ŠM_x | M_xâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{x}) for each xâ€‰âˆˆâ€‰Fresh(V), [âˆ€â€†x,â€Šyâ€‰âˆˆâ€‰Fresh(V)â€‰: M_x[xâ€…:=â€…y]â€…=â€…M_y], Mâ€ŠN | M,â€ŠNâ€‰âˆˆâ€‰ð“£_V}

  (x)â€…=â€…(y) â€Š:â‡” â€Šxâ€…=â€…y  (x,â€Šyâ€‰âˆˆâ€‰V)

  Î»x.â€ŠM_xâ€…=â€…Î»x.â€ŠM'_x â€Š:â‡” â€Šâˆ€â€†xâ€‰âˆˆâ€‰Fresh(V)â€‰: M_xâ€…=â€…M'_x  (M_xâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{x}) for each xâ€‰âˆˆâ€‰Fresh(V), M'_xâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{x}) for each xâ€‰âˆˆâ€‰Fresh(V) with suitable conditions)
   â€Šâ‡” â€Šâˆƒâ€†xâ€‰âˆˆâ€‰Fresh(V)â€‰: M_xâ€…=â€…M'_x

  Mâ€ŠNâ€…=â€…M'â€ŠN' â€Š:â‡” â€ŠMâ€…=â€…M' and Nâ€…=â€…N'  (M,â€ŠN,â€ŠM',â€ŠN'â€‰âˆˆâ€‰ð“£_V)

Vâ€…âŠ†:â€…ð“£_V via
xâ€…=â€…(x)

Well-definedness.  No proof.

Remarks.

This formalization of the untyped lambda calculus is fairly standard except for one thing: The right side of a lambda abstraction depends on the value of the bound variable used to define it (which is kind of the point of bound variables). To prevent wild pseudo-terms that actually differ in nontrivial ways depending on the variable, there needs to be an additional substitutability constraint. Although substitution is defined later, we can use it in this case because we are applying it to subterms only (i.e. we are employing mutual induction).

References.

* https://en.wikipedia.org/wiki/Lambda_calculus
* https://ncatlab.org/nlab/show/lambda-calculus#https://ncatlab.org/nlab/show/lambda-calculus#pure_lambda_calculus"
`;

exports[`render hlm library: 5.4.2 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/substitution 1`] = `
"Definition 5.4.2.  Let Vâ€‰âŠ†â€‰ð“¥ð“ªð“» such that V is finite, Tâ€‰âˆˆâ€‰ð“£_V, xâ€‰âˆˆâ€‰V, Râ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆ–â€Š{x}). We define

  T[xâ€…:=â€…R]

by:

  (y)[xâ€…:=â€…R]â€…:=â€…{R if xâ€…=â€…y, (y) if xâ€…â‰ â€…y  (yâ€‰âˆˆâ€‰V)
  (Î»y.â€ŠM_y)[xâ€…:=â€…R]â€…:=â€…Î»z.â€ŠM_z[xâ€…:=â€…R]  (M_yâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{y}) for each yâ€‰âˆˆâ€‰Fresh(V) with suitable conditions)
  (Mâ€ŠN)[xâ€…:=â€…R]â€…:=â€…M[xâ€…:=â€…R]â€ŠN[xâ€…:=â€…R]  (M,â€ŠNâ€‰âˆˆâ€‰ð“£_V)

Remarks.

Note that we do not allow _x_ to appear free in _R_. This ensures that _x_ does not appear free in the result either, which is important for e.g. the definition of [beta reduction](beta%20reduction).

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Substitution
* https://ncatlab.org/nlab/show/substitution#avoiding+variable+capture"
`;

exports[`render hlm library: 5.4.3 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/rewritable 1`] = `
"Definition 5.4.3.  Let Vâ€‰âŠ†â€‰ð“¥ð“ªð“» such that V is finite, â„œâ€‰âŠ†â€‰ð“¡ð“®ð”€ð“»(ð“£_V), L,â€ŠRâ€‰âˆˆâ€‰ð“£_V. We define:

  Lâ€…â†’_â„œâ€…R â€Š:â‡” â€Š(Lâ€‰â†’â€‰R)â€…âˆˆâ€…â„œ or {false if Râ€…=â€…(z) (zâ€‰âˆˆâ€‰V), {false if Lâ€…=â€…(y) (yâ€‰âˆˆâ€‰V), âˆ€â€†vâ€‰âˆˆâ€‰Fresh(V)â€‰: M_vâ€…â†’_â„œâ€…N_v if Lâ€…=â€…Î»y.â€ŠM_y (M_yâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{y}) for each yâ€‰âˆˆâ€‰Fresh(V) with suitable conditions), false if Lâ€…=â€…Mâ€ŠN (M,â€ŠNâ€‰âˆˆâ€‰ð“£_V) if Râ€…=â€…Î»z.â€ŠN_z (N_zâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{z}) for each zâ€‰âˆˆâ€‰Fresh(V) with suitable conditions), {false if Lâ€…=â€…(y) (yâ€‰âˆˆâ€‰V), false if Lâ€…=â€…Î»y.â€ŠM_y (M_yâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{y}) for each yâ€‰âˆˆâ€‰Fresh(V) with suitable conditions), [Mâ€…â†’_â„œâ€…O and Nâ€…=â€…P] or [Mâ€…=â€…O and Nâ€…â†’_â„œâ€…P] if Lâ€…=â€…Mâ€ŠN (M,â€ŠNâ€‰âˆˆâ€‰ð“£_V) if Râ€…=â€…Oâ€ŠP (O,â€ŠPâ€‰âˆˆâ€‰ð“£_V)

Remarks.

This definition checks whether a rewrite rule matches a pair of terms. It considers both the pair itself as well as all subterms. Structural induction on both sides makes the definition a bit complicated."
`;

exports[`render hlm library: 5.4.4 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/beta%20reduction 1`] = `
"Definition 5.4.4.  Let Vâ€‰âŠ†â€‰ð“¥ð“ªð“» such that V is finite. We define:

  Î²_Vâ€…:=â€…{(Î»z.â€ŠM_z)â€ŠNâ€‰â†’â€‰M_y[yâ€…:=â€…N]â€‰: M_xâ€‰âˆˆâ€‰ð“£_(Vâ€Šâˆªâ€Š{x}) for each xâ€‰âˆˆâ€‰Fresh(V), Nâ€‰âˆˆâ€‰ð“£_V, yâ€‰âˆˆâ€‰Fresh(V)}

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction
* https://ncatlab.org/nlab/show/beta-reduction"
`;

exports[`render hlm library: 5.4.5 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/eta%20conversion 1`] = `
"Definition 5.4.5.  Let Vâ€‰âŠ†â€‰ð“¥ð“ªð“» such that V is finite. We define:

  Î·_Vâ€…:=â€…{Î»z.â€ŠMâ€Šzâ€‰â†’â€‰Mâ€‰: Mâ€‰âˆˆâ€‰ð“£_V}

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion
* https://ncatlab.org/nlab/show/eta-conversion"
`;

exports[`render hlm library: 5.4.6.1 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/Combinators/identity 1`] = `
"Definition 5.4.6.1.  We define:

  ð—œâ€…:=â€…Î»x.â€Šx

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.2 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/Combinators/constant 1`] = `
"Definition 5.4.6.2.  We define:

  ð—žâ€…:=â€…Î»x.â€ŠÎ»y.â€Šx

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.3 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/Combinators/substitution 1`] = `
"Definition 5.4.6.3.  We define:

  ð—¦â€…:=â€…Î»x.â€ŠÎ»y.â€ŠÎ»z.â€Š(xâ€Šz)â€Š(yâ€Šz)

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.4 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/Combinators/omega 1`] = `
"Definition 5.4.6.4.  We define:

  ðžˆâ€…:=â€…Î»x.â€Šxâ€Šx

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;

exports[`render hlm library: 5.4.6.5 data/libraries/hlm/Formal%20systems/Untyped%20lambda%20calculus/Combinators/fixed-point 1`] = `
"Definition 5.4.6.5.  We define:

  ð—¬â€…:=â€…Î»f.â€Š(Î»x.â€Šfâ€Š(xâ€Šx))â€Š(Î»x.â€Šfâ€Š(xâ€Šx))

References.

* https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms"
`;
